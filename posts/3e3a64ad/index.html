<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Soul"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://evan.beee.top" crossorigin><link rel="canonical" href="https://soulmate.org.cn/posts/3e3a64ad/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="网络通信"><meta property="og:url" content="https://soulmate.org.cn/posts/3e3a64ad/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://soulmate.org.cn/images/redefine-og.webp"><meta property="article:published_time" content="2025-05-08T02:59:41.000Z"><meta property="article:modified_time" content="2025-05-13T11:36:16.953Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="手写Spring"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://soulmate.org.cn/images/redefine-og.webp"><link rel="icon" type="image/png" href="https://s1.imagehub.cc/images/2025/03/20/fa445647b4dd59405fb63c8cc69ecd1a.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="https://s1.imagehub.cc/images/2025/03/20/fa445647b4dd59405fb63c8cc69ecd1a.png"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="https://s1.imagehub.cc/images/2025/03/20/fa445647b4dd59405fb63c8cc69ecd1a.png"><title>网络通信 | Soul的小站</title><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/css/build/tailwind.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Geist/geist.css"><script id="hexo-configurations">window.config={hostname:"soulmate.org.cn",root:"/",language:"zh-CN",path:"search.json"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"dark"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"Soul的小站",subtitle:{text:["Loading..."],hitokoto:{enable:!0,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!1,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/Soulmate404",instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"个人邮箱soulmate200@foxmail.com,欢迎讨论",show_on_mobile:!0,links:null},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2024/11/11 11:45:14"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/"><img src="https://s1.imagehub.cc/images/2025/03/20/fa445647b4dd59405fb63c8cc69ecd1a.png" class="w-full h-full rounded-sm"> </a><a class="logo-title" href="/">Soul的小站</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a href="/tags"><i class="fa-regular fa-tags fa-fw"></i> 标签</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/tags"><span>标签 </span><i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">网络通信</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="https://s1.imagehub.cc/images/2025/03/20/9437097c42693d851287aaac0c8b1de9.png"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Soul</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2025-05-08 10:59:41</span> <span class="mobile">2025-05-08 10:59:41</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-05-13 19:36:16</span> <span class="mobile">2025-05-13 19:36:16</span> <span class="hover-info">更新</span> </span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E6%89%8B%E5%86%99Spring/">手写Spring</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>8.7k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>40 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><p>今天我们来聊聊网络通信的部分，我们知道的是Spring框架使用的是一个名为<code>DispatchServlet</code>的类作为网络通信的处理器，而这个类实际上来自于TomCat中的Servlet，我们先一层层推进看看这些东西到底是怎么实现的</p><h2 id="DispatchServlet分析"><a href="#DispatchServlet分析" class="headerlink" title="DispatchServlet分析"></a>DispatchServlet分析</h2><p>从流程上看，首先存在一个简单的服务器用于监听端口，一般是TomCat，在TomCat发现请求后会转发给DisPatchServlet中的doService方法，其实现如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="built_in">this</span>.logRequest(request);  </span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;  </span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  </span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();  </span><br><span class="line">        <span class="keyword">while</span>(attrNames.hasMoreElements()) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String)attrNames.nextElement();  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">&quot;org.springframework.web.servlet&quot;</span>)) &#123;  </span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="built_in">this</span>.getWebApplicationContext());  </span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);  </span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);  </span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="built_in">this</span>.getThemeSource());  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);  </span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;  </span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));  </span><br><span class="line">        &#125;  </span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());  </span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">previousRequestPath</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;  </span><br><span class="line">        previousRequestPath = (RequestPath)request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);  </span><br><span class="line">        ServletRequestPathUtils.parseAndCache(request);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的一大堆都是缓存机制和纠错机制，有兴趣的可以自己学习，其实很简单  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.doDispatch(request, response);<span class="comment">//这里是重点，开始分发  </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath) &#123;  </span><br><span class="line">            ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>也就是说真正的分发出现在<code>doDispatch</code>方法中，我们再去这个方法看一看发生了什么</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;  </span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                processedRequest = <span class="built_in">this</span>.checkMultipart(request);<span class="comment">//检查是否是Multipart类型的请求  </span></span><br><span class="line">                multipartRequestParsed = processedRequest != request;</span><br><span class="line">                <span class="comment">//在这一步获得一个包含了我们自定义的Controller和拦截器的处理器  </span></span><br><span class="line">                mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);  </span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    <span class="built_in">this</span>.noHandlerFound(processedRequest, response);  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());  </span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();  </span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);<span class="comment">//判断是否的Get类型的请求  </span></span><br><span class="line">                <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                <span class="comment">//对方法为Get的请求，使用getLastModified方法检查锁请求的资源是否发生变动，如果资源没有发生修改则返回304，说明资源没有发生变动，要求使用客户端缓存的资源  </span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());  </span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;  </span><br><span class="line">                        <span class="keyword">return</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里开始调用拦截器的prehandle方法，如果方法返回false那么直接返回拒绝执行  </span></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在这里真正执行了处理器中的内容，获得了一个ModeAndView对象  </span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  </span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这一步用于检查是否包含View视图，如果包含那么将视图用request命名  </span></span><br><span class="line">                <span class="built_in">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                <span class="comment">//这一步开始再次调用拦截器，处理拦截器中的postHandle</span></span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">                dispatchException = ex;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable err) &#123;  </span><br><span class="line">                dispatchException = <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler dispatch failed: &quot;</span> + err, err);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这一步实际上将结果返回  </span></span><br><span class="line">            <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;  </span><br><span class="line">            triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler processing failed: &quot;</span> + err, err));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;  </span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.cleanupMultipart(processedRequest);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>好的，我们现在发现追到可<code>processDispatchResult</code>方法，我们继续查看，看看这个方法干了什么</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv, <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//公共的异常处理流程  </span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;  </span><br><span class="line">            <span class="type">ModelAndViewDefiningException</span> <span class="variable">mavDefiningException</span> <span class="operator">=</span> (ModelAndViewDefiningException)exception;  </span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);  </span><br><span class="line">            mv = mavDefiningException.getModelAndView();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>;  </span><br><span class="line">            mv = <span class="built_in">this</span>.processHandlerException(request, response, handler, exception);  </span><br><span class="line">            errorView = mv != <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试对可能存在的视图进行渲染  </span></span><br><span class="line">	    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">	    <span class="comment">//调用渲染方法，如果存在视图名则进行渲染否则什么都不做，将渲染结果写到response中 </span></span><br><span class="line">        <span class="built_in">this</span>.render(mv, request, response);  </span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;  </span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在不存在异步处理机制的情况下执行，异步处理有一套独立的机制  </span></span><br><span class="line">    <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用拦截器中的AfterCompletion方法  </span></span><br><span class="line">            mappedHandler.triggerAfterCompletion(request, response, (Exception)<span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>到这里Spring的处理流程就已经结束了，剩下的部分由TomCat完成，将对应的相应返回。</p><h2 id="TomCat机制分析"><a href="#TomCat机制分析" class="headerlink" title="TomCat机制分析"></a>TomCat机制分析</h2><p>通过上面的那些分析，我们已经走完了Spring在网络通信中负责的任务，接下来我们就要去TomCat中看一看了，研究一下在实际的网络通信流程中TomCat到底在干什么。</p><p>接下来的内容需要你对 java 的异步 IO 机制有一定的了解，可以参考<br><a href="https://soulmate.org.cn/2025/05/07/NIO%E4%BD%93%E7%B3%BB/">NIO 机制</a></p><p>TomCat有几个核心组件，分别是<code>Connector</code>,<code>Server</code>,<code>Service</code>.当我们通过脚本启动TomCat时这几个组件都会开始运行，其中Connecter负责监听端口，所以我们先从这个组件开始</p><p>在启动这个组件时会调用下面的方法</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="built_in">this</span>.protocolHandler != <span class="literal">null</span> ? <span class="built_in">this</span>.protocolHandler.getId() : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//一连串的异常检查  </span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.getPortWithOffset() &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(sm.getString(<span class="string">&quot;coyoteConnector.invalidPort&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.getPortWithOffset()&#125;));  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.setState(LifecycleState.STARTING);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.protocolHandler != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.service != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.protocolHandler.setUtilityExecutor(<span class="built_in">this</span>.service.getServer().getUtilityExecutor());<span class="comment">//获取一个用于处理非核心任务的线程池  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.protocolHandler.start();<span class="comment">//启动协议处理器  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerStartFailed&quot;</span>), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们注意到这个方法的实质就是在进行了几个基本的检查之后启动了一个叫做 <code>protocolHandler</code> 的对象，这个对象被称为协议处理器，这个处理器有多个实现用来适配不同的协议如HTTP1.0,HTTP1.1,AJP等，我们这里以当下比较常用的HTTP1.1为例，HTTP1.1对应的协议处理器叫做 <code>HTTP11NIOProtocol</code>,但你会发现里面并没有start方法的实现，往上找几层继承后你会来到一个叫做 <code>AbstractProtocol</code> 的类，这个类中实现了start方法</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.getLog().isInfoEnabled()) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.start&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.getName()&#125;));  </span><br><span class="line">        <span class="built_in">this</span>.logPortOffset();  </span><br><span class="line">    &#125;<span class="comment">//获取日志对象记录日志  </span></span><br><span class="line">    <span class="built_in">this</span>.endpoint.start();<span class="comment">//endpoint是TomCat自己实现的线程池，启动线程池  </span></span><br><span class="line">    <span class="built_in">this</span>.monitorFuture = <span class="built_in">this</span>.getUtilityExecutor().scheduleWithFixedDelay(() -&gt; <span class="built_in">this</span>.startAsyncTimeout(), <span class="number">0L</span>, <span class="number">60L</span>, TimeUnit.SECONDS);<span class="comment">//调用之前Connecter设置的非核心任务的线程池，添加一个定时任务，作用是每60秒启动检查是否有异步任务超时  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这部分的核心是启动了线程池，我们继续前进看看这个线程池的启动方法</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//start方法实现在AbstractEndPoint类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.bindState == AbstractEndpoint.BindState.UNBOUND) &#123;<span class="comment">//检查端口绑定状态，如果等于没有绑定  </span></span><br><span class="line">        <span class="built_in">this</span>.bindWithCleanup();<span class="comment">//进行绑定并执行必要的清理工作</span></span><br><span class="line">        <span class="built_in">this</span>.bindState = AbstractEndpoint.BindState.BOUND_ON_START;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">this</span>.startInternal();<span class="comment">//内部启动  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们先看看这个绑定端口的方法，这个方法的实现有两个版本，分别是<code>NioEndPoint</code>和<code>Nio2EndPoint</code>，这两个类分别使用了java的1.0和2.0的NIO API，我们这里统一看2.0版本的API</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面那个有清理的bindWithCleanup就是在下面这个方法外套了一个异常捕获</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.getExecutor() == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.createExecutor();<span class="comment">//如果线程池不存在那么创建一个新的线程池 </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.getExecutor() <span class="keyword">instanceof</span> ExecutorService) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.threadGroup = AsynchronousChannelGroup.withThreadPool((ExecutorService)<span class="built_in">this</span>.getExecutor());  </span><br><span class="line">	    &#125;<span class="comment">//创建一个异步服务套接字组共享上面创建的线程池,负责接下来的实际网络通信</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.internalExecutor) &#123;  </span><br><span class="line">        log.warn(sm.getString(<span class="string">&quot;endpoint.nio2.exclusiveExecutor&quot;</span>));<span class="comment">//检查线程池是否是TomCat内部创建的，如果不是则做出警告 </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">this</span>.serverSock = AsynchronousServerSocketChannel.open(<span class="built_in">this</span>.threadGroup);<span class="comment">//打开上面的套接字组</span></span><br><span class="line">    <span class="built_in">this</span>.socketProperties.setProperties(<span class="built_in">this</span>.serverSock);<span class="comment">//配置套接字相关的属性  </span></span><br><span class="line">    <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="built_in">this</span>.getAddress(), <span class="built_in">this</span>.getPortWithOffset());<span class="comment">//创建监听端口的相关信息  </span></span><br><span class="line">    <span class="built_in">this</span>.serverSock.bind(addr, <span class="built_in">this</span>.getAcceptCount());<span class="comment">//绑定端口 </span></span><br><span class="line">    <span class="built_in">this</span>.initialiseSsl();<span class="comment">//初始化ssl相关内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们暂时就到这一步，有兴趣的话可以自己进一步看看异步套接字组的实现，接下来我们看看另一个内部启动方法，我们继续选择NIO2版本的实现</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.running) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.allClosed = <span class="literal">false</span>;  </span><br><span class="line">        <span class="built_in">this</span>.running = <span class="literal">true</span>;  </span><br><span class="line">        <span class="built_in">this</span>.paused = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.socketProperties.getProcessorCache() != <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.processorCache = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>(<span class="number">128</span>, <span class="built_in">this</span>.socketProperties.getProcessorCache());  </span><br><span class="line">        &#125;<span class="comment">//创建一个线程安全的栈作为处理器缓存 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">actualBufferPool</span> <span class="operator">=</span> <span class="built_in">this</span>.socketProperties.getActualBufferPool(<span class="built_in">this</span>.isSSLEnabled() ? <span class="built_in">this</span>.getSniParseLimit() * <span class="number">2</span> : <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (actualBufferPool != <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.nioChannels = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>(<span class="number">128</span>, actualBufferPool);  </span><br><span class="line">        &#125;<span class="comment">//创建缓存池来缓存网络IO中的建立的通道</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getExecutor() == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.createExecutor();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">this</span>.initializeConnectionLatch();<span class="comment">//创建一个连接计数器  </span></span><br><span class="line">        <span class="built_in">this</span>.startAcceptorThread();<span class="comment">//初始化监听线程 </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们继续往下追查监听线程的任务，</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThread</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.acceptor == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.acceptor = <span class="keyword">new</span> <span class="title class_">Nio2Acceptor</span>(<span class="built_in">this</span>);  </span><br><span class="line">        <span class="built_in">this</span>.acceptor.setThreadName(<span class="built_in">this</span>.getName() + <span class="string">&quot;-Acceptor&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">this</span>.acceptor.state = AcceptorState.RUNNING;  </span><br><span class="line">    <span class="built_in">this</span>.getExecutor().execute(<span class="built_in">this</span>.acceptor);  </span><br><span class="line">&#125;<span class="comment">//看来下一个目标是acceptor</span></span><br></pre></td></tr></table></figure></div><p>我直接贴对应的run方法</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!Nio2Endpoint.<span class="built_in">this</span>.isPaused()) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Nio2Endpoint.<span class="built_in">this</span>.countUpOrAwaitConnection();<span class="comment">//计数或等待连接，如果连接数没有达到最大那么计数器加一，如果达到最大则当前线程等待  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException var2) &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (!Nio2Endpoint.<span class="built_in">this</span>.isPaused()) &#123;  </span><br><span class="line">            Nio2Endpoint.<span class="built_in">this</span>.serverSock.accept((Object)<span class="literal">null</span>, <span class="built_in">this</span>);<span class="comment">// 监听端口然后处理信息  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.state = AcceptorState.PAUSED;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.state = AcceptorState.PAUSED;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>好吧，我们的下一步是accept方法，这个方法在叠了几层继承后有这样的实现,看起来有点复杂</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;AsynchronousSocketChannel&gt; <span class="title function_">implAccept</span><span class="params">(Object att, CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; handler)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isOpen()) &#123;<span class="comment">//如果没有打开，那么直接进入异常处理流程  </span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClosedChannelException</span>();  </span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> CompletedFuture.withFailure(e);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            Invoker.invoke(<span class="built_in">this</span>, handler, att, (Object)<span class="literal">null</span>, e);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.localAddress == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotYetBoundException</span>();  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isAcceptKilled()) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Accept not allowed due cancellation&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.accepting.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AcceptPendingException</span>();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//从这里开始进入正常情况的处理流程  </span></span><br><span class="line">        <span class="type">FileDescriptor</span> <span class="variable">newfd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDescriptor</span>();  </span><br><span class="line">        InetSocketAddress[] isaa = <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>[<span class="number">1</span>];  </span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exc</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.begin();<span class="comment">//这里只是简单的为接下来的操作加了一个读锁  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Net.accept(<span class="built_in">this</span>.fd, newfd, isaa);<span class="comment">//这个方法是使用C++实现的，看不了源码，比较遗憾，但就是这个方法实现了对端口的监听，其中this.fd就是对之前绑定的端口的描述,返回的n是接收到的可用连接数 </span></span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">2</span>) &#123;<span class="comment">//如果n是-2，当前不存在可用的连接事件</span></span><br><span class="line">                PendingFuture&lt;AsynchronousSocketChannel, Object&gt; result = <span class="literal">null</span>;  </span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>.updateLock) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="built_in">this</span>.acceptHandler = <span class="literal">null</span>;  </span><br><span class="line">                        result = <span class="keyword">new</span> <span class="title class_">PendingFuture</span>(<span class="built_in">this</span>);  </span><br><span class="line">                        <span class="built_in">this</span>.acceptFuture = result;  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        <span class="built_in">this</span>.acceptHandler = handler;  </span><br><span class="line">                        <span class="built_in">this</span>.acceptAttachment = att;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="built_in">this</span>.acceptAcc = System.getSecurityManager() == <span class="literal">null</span> ? <span class="literal">null</span> : AccessController.getContext();  </span><br><span class="line">                    <span class="built_in">this</span>.acceptPending = <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="built_in">this</span>.port.startPoll(<span class="built_in">this</span>.fdVal, Net.POLLIN);</span><br><span class="line">                <span class="comment">//这里是通过对系统底层的异步IO机制注册事件监听，相当于向选择器注册对对应事件的监听  </span></span><br><span class="line">                <span class="type">PendingFuture</span> <span class="variable">var8</span> <span class="operator">=</span> result;</span><br><span class="line">                <span class="comment">//既然不存在可用的监听事件，那么返回一个PendingFuture表示待处理并结束当前线程的运行  </span></span><br><span class="line">                <span class="keyword">return</span> var8;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var17) &#123;  </span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">x</span> <span class="operator">=</span> var17;  </span><br><span class="line">            <span class="keyword">if</span> (var17 <span class="keyword">instanceof</span> ClosedChannelException) &#123;  </span><br><span class="line">                x = <span class="keyword">new</span> <span class="title class_">AsynchronousCloseException</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">            exc = x;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.end();<span class="comment">//释放读锁  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">child</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">if</span> (exc == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                child = <span class="built_in">this</span>.finishAccept(newfd, isaa[<span class="number">0</span>], (AccessControlContext)<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//这里创建了一个新的异步通道，将由这个异步通道负责接下来对连接的处理  </span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;  </span><br><span class="line">                exc = x;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">this</span>.enableAccept();<span class="comment">//重置标志位，运行继续创建连接  </span></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;<span class="comment">//如果没有提供完成处理器，那么返回一个表示完成的future对象  </span></span><br><span class="line">            <span class="keyword">return</span> CompletedFuture.withResult(child, exc);  </span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="comment">//如果存在回调处理器那么调用处理器进行处理，注意，这里的回调并不是发生在当前线程  </span></span><br><span class="line">            Invoker.invokeIndirectly(<span class="built_in">this</span>, handler, att, child, exc); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里要特别说明两个关键点</p><ul><li>文件描述符：上面的方法中使用了文件描述符来指代一个网络通信，这来自于unix系统的万物皆文件的思想，注意，这个类本身就叫做UnixAsynchronousServerSocketChannelImpl，在操作系统中所有的文件都有一个非负的整数作为标识，而万物皆文件，自然而然的网络连接也是一个文件，所以我们通过这个数字来访问网络通信（注意，这是 Linux 版本的实现方式，在 Windows 上存在另一套实现方式）</li><li>第二个问题是我们一直捋到这里都没有发现一个循环机制，那么为什么可以持续监听端口？我们这里选择的是nio2版本的处理流程，如果你选择去查看nio1.0版本的流程，你会发现一个while循环，但在新的版本中使用了另一种的办法：回调机制<br>我们可以从头捋一捋这一套机制，首先回到 <code>Nio2EndPointAcceptor</code> 这个类，这个类的声明如下</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Nio2Acceptor</span> <span class="keyword">extends</span> <span class="title class_">Acceptor</span>&lt;AsynchronousSocketChannel&gt;  </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;</span><br></pre></td></tr></table></figure></div><p>可以看到这个类实现了一个叫做 CompletionHandler 的接口，也就是我们前面提到的完成处理器，结构如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompletionHandler</span>&lt;V, A&gt; &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(V var1, A var2)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable var1, A var2)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个接口的实现规定了当某种操作结束时针对是否失败的不同情况的不同处理方法，而 Acceptor 中对 Completed 方法的实现如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socket,  </span></span><br><span class="line"><span class="params">        Void attachment)</span> &#123;  </span><br><span class="line">    <span class="comment">// Successful accept, reset the error delay  </span></span><br><span class="line">    errorDelay = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// Continue processing the socket on the current thread  </span></span><br><span class="line">    <span class="comment">// Configure the socket    if (isRunning() &amp;&amp; !isPaused()) &#123;  </span></span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;  </span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getConnectionCount() &lt; getMaxConnections()) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// This will not block  </span></span><br><span class="line">                countUpOrAwaitConnection();<span class="comment">//如果当前连接数小于最大值则当前连接数加1，否则阻塞 </span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                <span class="comment">// Ignore  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>); <span class="comment">//看，这里有一次调用了accept方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// Accept again on a new thread since countUpOrAwaitConnection may block  </span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;  </span><br><span class="line">            closeSocket(socket);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (isRunning()) &#123;  </span><br><span class="line">            state = AcceptorState.PAUSED;  </span><br><span class="line">        &#125;  </span><br><span class="line">        destroySocket(socket);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>还记得吗，Acceptor 的 run 方法实现其实也是调用了 <code>serverSock.accept(null, this)</code> 方法，注意，这个方法的两个参数分别如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(A var1, CompletionHandler&lt;AsynchronousSocketChannel, ? <span class="built_in">super</span> A&gt; var2)</span>;</span><br></pre></td></tr></table></figure></div><p>也就是说这里将自己做回完成处理器传入，进一步的，这个方法的实现是上面的 implAccept，这个方法在通道正常打开的情况下执行下面的代码</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileDescriptor</span> <span class="variable">newfd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDescriptor</span>();  </span><br><span class="line">        InetSocketAddress[] isaa = <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>[<span class="number">1</span>];  </span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exc</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.begin();<span class="comment">//这里只是简单的为接下来的操作加了一个读锁  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Net.accept(<span class="built_in">this</span>.fd, newfd, isaa);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *这个方法时是真正的连接方法，根据文件描述符去查询是否有可用的连接，这个方法时基于异步的NIO机制实现的，不会发生阻</span></span><br><span class="line"><span class="comment">            *塞，其中返回的n是发现的可用的连接事件，及OP_Accept事件</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">2</span>) &#123;<span class="comment">//如果n是-2，当前不存在可用的连接事件</span></span><br><span class="line">                PendingFuture&lt;AsynchronousSocketChannel, Object&gt; result = <span class="literal">null</span>;  </span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>.updateLock) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="built_in">this</span>.acceptHandler = <span class="literal">null</span>;  </span><br><span class="line">                        result = <span class="keyword">new</span> <span class="title class_">PendingFuture</span>(<span class="built_in">this</span>);  </span><br><span class="line">                        <span class="built_in">this</span>.acceptFuture = result;  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        <span class="built_in">this</span>.acceptHandler = handler;  </span><br><span class="line">                        <span class="built_in">this</span>.acceptAttachment = att;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="built_in">this</span>.acceptAcc = System.getSecurityManager() == <span class="literal">null</span> ? <span class="literal">null</span> : AccessController.getContext();  </span><br><span class="line">                    <span class="built_in">this</span>.acceptPending = <span class="literal">true</span>;  </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="built_in">this</span>.port.startPoll(<span class="built_in">this</span>.fdVal, Net.POLLIN);</span><br><span class="line">                <span class="comment">//这个方法是阻塞的，直到出现对应的事件才会继续执行  </span></span><br><span class="line">                <span class="type">PendingFuture</span> <span class="variable">var8</span> <span class="operator">=</span> result;</span><br><span class="line">                <span class="comment">//既然不存在可用的监听事件，那么返回一个PendingFuture表示待处理并结束当前线程的运行  </span></span><br><span class="line">                <span class="keyword">return</span> var8;  </span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure></div><p>这里有一点需要解释：既然 startPoll 方法是阻塞的，然后又返回了一个 PendingFuture，但在更上层的 completeed 和 run 方法中没有对返回值有任何处理呢？这源于对操作系统底层的回调机制的的处理，在 startPoll 方法中，向操作系统注册了对对应事件的监听，如果发生了对应事件，操作系统将会调用对应的回调方法将连接加入通道组，这个过程发生在操作系统中，所以在代码中不可见。<br>当然，也存在当前有可用连接的情况，此时向下执行</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousSocketChannel</span> <span class="variable">child</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">if</span> (exc == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        child = <span class="built_in">this</span>.finishAccept(newfd, isaa[<span class="number">0</span>], (AccessControlContext)<span class="literal">null</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;  </span><br><span class="line">        exc = x;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">this</span>.enableAccept();  </span><br><span class="line"><span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> CompletedFuture.withResult(child, exc);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    Invoker.invokeIndirectly(<span class="built_in">this</span>, handler, att, child, exc);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们可以先看看这个 finishAccept 方法到底做了些什么</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AsynchronousSocketChannel <span class="title function_">finishAccept</span><span class="params">(FileDescriptor newfd, <span class="keyword">final</span> InetSocketAddress remote, AccessControlContext acc)</span> <span class="keyword">throws</span> IOException, SecurityException &#123;  </span><br><span class="line">    <span class="type">AsynchronousSocketChannel</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        ch = <span class="keyword">new</span> <span class="title class_">UnixAsynchronousSocketChannelImpl</span>(<span class="built_in">this</span>.port, newfd, remote);</span><br><span class="line">        <span class="comment">//创建一个新的异步通道，三个参数分别为绑定的端口，表示新连接的文件描述符，以及连接的相关信息remote</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;  </span><br><span class="line">        nd.close(newfd);  </span><br><span class="line">        <span class="keyword">throw</span> x;  </span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="comment">//下面是对安全管理的一些设置，我们暂且略过</span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (acc != <span class="literal">null</span>) &#123;  </span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;  </span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();  </span><br><span class="line">                    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        sm.checkAccept(remote.getAddress().getHostAddress(), remote.getPort());  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;, acc);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();  </span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;  </span><br><span class="line">                sm.checkAccept(remote.getAddress().getHostAddress(), remote.getPort());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> ch;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException var8) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ch.close();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable suppressed) &#123;  </span><br><span class="line">            var8.addSuppressed(suppressed);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">throw</span> var8;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后还有一个值得一看的是 Invoker 的执行流程</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;V, A&gt; <span class="keyword">void</span> <span class="title function_">invokeIndirectly</span><span class="params">(AsynchronousChannel channel, <span class="keyword">final</span> CompletionHandler&lt;V, ? <span class="built_in">super</span> A&gt; handler, <span class="keyword">final</span> A attachment, <span class="keyword">final</span> V result, <span class="keyword">final</span> Throwable exc)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        ((Groupable)channel).group().executeOnPooledThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//可以看到在这里使用了对应的线程池在新的线程中执行了下面的任务  </span></span><br><span class="line">                <span class="type">GroupAndInvokeCount</span> <span class="variable">thisGroupAndInvokeCount</span> <span class="operator">=</span> (GroupAndInvokeCount)Invoker.myGroupAndInvokeCount.get();  </span><br><span class="line">                <span class="keyword">if</span> (thisGroupAndInvokeCount != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    thisGroupAndInvokeCount.setInvokeCount(<span class="number">1</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                Invoker.invokeUnchecked(handler, attachment, result, exc);  </span><br><span class="line">                <span class="comment">//这个方法就是直接调用了completed方法</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException var6) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ShutdownChannelGroupException</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>走到这一步，一个连接就被建立了起来，那么接下来了，是谁去处理连接后的任务呢，我们需要再往回倒一倒，看看 completed 方法</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socket,  </span></span><br><span class="line"><span class="params">        Void attachment)</span> &#123;  </span><br><span class="line">    <span class="comment">// Successful accept, reset the error delay  </span></span><br><span class="line">    errorDelay = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// Continue processing the socket on the current thread  </span></span><br><span class="line">    <span class="comment">// Configure the socket    if (isRunning() &amp;&amp; !isPaused()) &#123;  </span></span><br><span class="line">        <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;  </span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getConnectionCount() &lt; getMaxConnections()) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// This will not block  </span></span><br><span class="line">                countUpOrAwaitConnection();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                <span class="comment">// Ignore  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// Accept again on a new thread since countUpOrAwaitConnection may block  </span></span><br><span class="line">            getExecutor().execute(<span class="built_in">this</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里，setSocketOptions中的参数为刚刚建立的连接，也就是说这里有对刚建立的连接的进一步处理 </span></span><br><span class="line">        <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;  </span><br><span class="line">            closeSocket(socket);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (isRunning()) &#123;  </span><br><span class="line">            state = AcceptorState.PAUSED;  </span><br><span class="line">        &#125;  </span><br><span class="line">        destroySocket(socket);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>所以我们看看 <code>setSocketOption</code> 方法的实现</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(AsynchronousSocketChannel socket)</span> &#123;  </span><br><span class="line">    <span class="type">Nio2SocketWrapper</span> <span class="variable">socketWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">// Allocate channel and wrapper  </span></span><br><span class="line">        <span class="type">Nio2Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">if</span> (nioChannels != <span class="literal">null</span>) &#123;  </span><br><span class="line">            channel = nioChannels.pop();  </span><br><span class="line">        &#125;<span class="comment">//这个nioChannels就是在EndPoint启动时创建的通道缓存</span></span><br><span class="line">        <span class="comment">//如果没可用的通道就创建一个，如果有那么直接用  </span></span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(  </span><br><span class="line">                    socketProperties.getAppReadBufSize(),  </span><br><span class="line">                    socketProperties.getAppWriteBufSize(),  </span><br><span class="line">                    socketProperties.getDirectBuffer());  </span><br><span class="line">            <span class="keyword">if</span> (isSSLEnabled()) &#123;  </span><br><span class="line">                channel = <span class="keyword">new</span> <span class="title class_">SecureNio2Channel</span>(bufhandler, <span class="built_in">this</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              </span><br><span class="line">                channel = <span class="keyword">new</span> <span class="title class_">Nio2Channel</span>(bufhandler);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个SocketWrapper  </span></span><br><span class="line">        <span class="type">Nio2SocketWrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Nio2SocketWrapper</span>(channel, <span class="built_in">this</span>);  </span><br><span class="line">        <span class="comment">//将刚刚创建的连接通道打包进去</span></span><br><span class="line">        channel.reset(socket, newWrapper);</span><br><span class="line">        <span class="comment">//connections是一个Map，以当前连接的异步通道为键，新打包的Wrapper为值放进去  </span></span><br><span class="line">        connections.put(socket, newWrapper);  </span><br><span class="line">        socketWrapper = newWrapper;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Set socket properties  </span></span><br><span class="line">        socketProperties.setProperties(socket);  </span><br><span class="line">  </span><br><span class="line">        socketWrapper.setReadTimeout(getConnectionTimeout());  </span><br><span class="line">        socketWrapper.setWriteTimeout(getConnectionTimeout());  </span><br><span class="line">        socketWrapper.setKeepAliveLeft(Nio2Endpoint.<span class="built_in">this</span>.getMaxKeepAliveRequests());  </span><br><span class="line">        <span class="comment">// Continue processing on the same thread as the acceptor is async</span></span><br><span class="line">        <span class="comment">//开始对通道中的信息进行处理，监听可用的读事件  </span></span><br><span class="line">        <span class="keyword">return</span> processSocket(socketWrapper, SocketEvent.OPEN_READ, <span class="literal">false</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">        ExceptionUtils.handleThrowable(t);  </span><br><span class="line">        log.error(sm.getString(<span class="string">&quot;endpoint.socketOptionsError&quot;</span>), t);  </span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="literal">null</span>) &#123;  </span><br><span class="line">            destroySocket(socket);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Tell to close the socket if needed  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>顺其自然的我们继续找 processSocket 方法</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,  </span></span><br><span class="line"><span class="params">        SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取缓存的处理器Processor，如果不存在那么创建一个 </span></span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">if</span> (processorCache != <span class="literal">null</span>) &#123;  </span><br><span class="line">            sc = processorCache.pop();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="literal">null</span>) &#123;  </span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果处理器存在那么重新将处理器与当前的wrapper关联  </span></span><br><span class="line">            sc.reset(socketWrapper, event);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();  </span><br><span class="line">        <span class="comment">//如果要求分发，在线程池执行，否则直接在当前线程执行</span></span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;  </span><br><span class="line">            executor.execute(sc);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//刚刚的setSocketOption用的是false，直接在当前线程执行</span></span><br><span class="line">            sc.run();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;  </span><br><span class="line">        getLog().warn(sm.getString(<span class="string">&quot;endpoint.executor.fail&quot;</span>, socketWrapper) , ree);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">        ExceptionUtils.handleThrowable(t);  </span><br><span class="line">        <span class="comment">// This means we got an OOM or similar creating a thread, or that  </span></span><br><span class="line">        <span class="comment">// the pool and its queue are full        getLog().error(sm.getString(&quot;endpoint.process.fail&quot;), t);  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>那么刚刚 run 的是什么呢</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> socketWrapper.getLock();  </span><br><span class="line">    lock.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (socketWrapper.isClosed()) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        doRun();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>好吧，加个锁，然后继续 run</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">launch</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">int</span> handshake;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="comment">//这里时对TCP连接三次握手机制的检查，0表示完成了握手过程</span></span><br><span class="line">                <span class="keyword">if</span> (socketWrapper.getSocket().isHandshakeComplete()) &#123;  </span><br><span class="line">                    <span class="comment">// No TLS handshaking required. Let the handler  </span></span><br><span class="line">                    <span class="comment">// process this socket / event combination.                    </span></span><br><span class="line">                    handshake = <span class="number">0</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == SocketEvent.STOP || event == SocketEvent.DISCONNECT ||  </span><br><span class="line">                        event == SocketEvent.ERROR) &#123;  </span><br><span class="line">                    <span class="comment">// Unable to complete the TLS handshake. Treat it as  </span></span><br><span class="line">                    <span class="comment">// if the handshake failed.                    handshake = -1;  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    handshake = socketWrapper.getSocket().handshake();  </span><br><span class="line">                    event = SocketEvent.OPEN_READ;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;  </span><br><span class="line">                handshake = -<span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">if</span> (logHandshake.isDebugEnabled()) &#123;  </span><br><span class="line">                    logHandshake.debug(sm.getString(<span class="string">&quot;endpoint.err.handshake&quot;</span>,  </span><br><span class="line">                            socketWrapper.getRemoteAddr(), Integer.toString(socketWrapper.getRemotePort())), x);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (handshake == <span class="number">0</span>) &#123;  </span><br><span class="line">                SocketState state;  </span><br><span class="line">                <span class="comment">// Process the request from this socket</span></span><br><span class="line">                <span class="comment">//这里真正的发生了处理  </span></span><br><span class="line">                state = getHandler().process(socketWrapper, Objects.requireNonNullElse(event, SocketEvent.OPEN_READ));</span><br><span class="line">                <span class="comment">//检查处理完后的状态  </span></span><br><span class="line">                <span class="keyword">if</span> (state == SocketState.CLOSED) &#123;  </span><br><span class="line">                    <span class="comment">// Close socket and pool  </span></span><br><span class="line">                    socketWrapper.close();</span><br><span class="line">                    <span class="comment">//如果状态标识为需要升级协议，将launch变为true </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.UPGRADING) &#123;  </span><br><span class="line">                    launch = <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == -<span class="number">1</span> ) &#123;  </span><br><span class="line">                getHandler().process(socketWrapper, SocketEvent.CONNECT_FAIL);  </span><br><span class="line">                socketWrapper.close();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (VirtualMachineError vme) &#123;  </span><br><span class="line">            ExceptionUtils.handleThrowable(vme);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;endpoint.processing.fail&quot;</span>), t);  </span><br><span class="line">            <span class="keyword">if</span> (socketWrapper != <span class="literal">null</span>) &#123;  </span><br><span class="line">                socketWrapper.close();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (launch) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//新创建一个处理器处理进一步处理  </span></span><br><span class="line">                    getExecutor().execute(<span class="keyword">new</span> <span class="title class_">SocketProcessor</span>(socketWrapper, SocketEvent.OPEN_READ));  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (running) &#123;  </span><br><span class="line">                        log.error(sm.getString(<span class="string">&quot;endpoint.launch.fail&quot;</span>),  </span><br><span class="line">                                npe);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            socketWrapper = <span class="literal">null</span>;  </span><br><span class="line">            event = <span class="literal">null</span>;  </span><br><span class="line">            <span class="comment">//return to cache</span></span><br><span class="line">            <span class="comment">//然后将当前的处理器重新放到缓存中  </span></span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; processorCache != <span class="literal">null</span>) &#123;  </span><br><span class="line">                processorCache.push(<span class="built_in">this</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>接下来看看 process 方法在干什么，这个方法不太好找，位于 AbstractProtocol 类中，而且比较长，所以我只截取部分</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Processor</span> <span class="variable">processor</span> <span class="operator">=</span> (Processor) wrapper.takeCurrentProcessor();</span><br><span class="line"><span class="comment">//在这里获取处理器</span></span><br><span class="line">state = processor.process(wrapper, status);<span class="comment">//调用处理器的process方法</span></span><br></pre></td></tr></table></figure></div><p>这个 process 方法的实现也不好找，位于AbstractProcessorLight，看一眼具体的实现</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> SocketState <span class="title function_">process</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">SocketState</span> <span class="variable">state</span> <span class="operator">=</span> SocketState.CLOSED;  </span><br><span class="line">    Iterator&lt;DispatchType&gt; dispatches = <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (dispatches != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="type">DispatchType</span> <span class="variable">nextDispatch</span> <span class="operator">=</span> dispatches.next();  </span><br><span class="line">            <span class="keyword">if</span> (getLog().isTraceEnabled()) &#123;  </span><br><span class="line">                getLog().trace(<span class="string">&quot;Processing dispatch type: [&quot;</span> + nextDispatch + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            state = dispatch(nextDispatch.getSocketStatus());  </span><br><span class="line">            <span class="keyword">if</span> (!dispatches.hasNext()) &#123;  </span><br><span class="line">                state = checkForPipelinedData(state, socketWrapper);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.DISCONNECT) &#123;  </span><br><span class="line">            <span class="comment">// Do nothing here, just wait for it to get recycled  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;  </span><br><span class="line">            state = dispatch(status);  </span><br><span class="line">            state = checkForPipelinedData(state, socketWrapper);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_WRITE) &#123;  </span><br><span class="line">            <span class="comment">// Extra write event likely after async, ignore  </span></span><br><span class="line">            state = SocketState.LONG;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_READ) &#123;</span><br><span class="line">        <span class="comment">//当时传入的状态是读，所以我们直接看这里  </span></span><br><span class="line">            state = service(socketWrapper);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.CONNECT_FAIL) &#123;  </span><br><span class="line">            logAccess(socketWrapper);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// Default to closing the socket if the SocketEvent passed in  </span></span><br><span class="line">            <span class="comment">// is not consistent with the current state of the Processor            </span></span><br><span class="line">            state = SocketState.CLOSED;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (getLog().isTraceEnabled()) &#123;  </span><br><span class="line">            getLog().trace(  </span><br><span class="line">                    <span class="string">&quot;Socket: [&quot;</span> + socketWrapper + <span class="string">&quot;], Status in: [&quot;</span> + status + <span class="string">&quot;], State out: [&quot;</span> + state + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * If state is already CLOSED don&#x27;t call asyncPostProcess() as that will likely change the state to some         </span></span><br><span class="line"><span class="comment">         * other value causing processing to continue when it should cease. The AsyncStateMachine will be recycled         </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">          as part of the Processor clean-up on CLOSED so it doesn&#x27;t matter what state it is left in at this point.        </span></span><br><span class="line"><span class="comment">           */</span>        </span><br><span class="line">         <span class="keyword">if</span> (isAsync() &amp;&amp; state != SocketState.CLOSED) &#123;  </span><br><span class="line">            state = asyncPostProcess();  </span><br><span class="line">            <span class="keyword">if</span> (getLog().isTraceEnabled()) &#123;  </span><br><span class="line">                getLog().trace(  </span><br><span class="line">                        <span class="string">&quot;Socket: [&quot;</span> + socketWrapper + <span class="string">&quot;], State after async post processing: [&quot;</span> + state + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (dispatches == <span class="literal">null</span> || !dispatches.hasNext()) &#123;  </span><br><span class="line">            <span class="comment">// Only returns non-null iterator if there are  </span></span><br><span class="line">            <span class="comment">// dispatches to process.            </span></span><br><span class="line">            dispatches = getIteratorAndClearDispatches();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">while</span> (state == SocketState.ASYNC_END || dispatches != <span class="literal">null</span> &amp;&amp; state != SocketState.CLOSED);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> state;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>所以接下来我们要看看 service 方法，这个方法也比较长，所以我们只看看关键部分</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">setSocketWrapper(socketWrapper);<span class="comment">//直接将打包好的连接放进处理器，之后直接通过处理器来获得对应的信息</span></span><br><span class="line"><span class="comment">//首先是这部分，开始尝试对HTTP请求进行解析</span></span><br><span class="line"><span class="keyword">if</span> (!inputBuffer.parseRequestLine(keptAlive, protocol.getConnectionTimeout(),  </span><br><span class="line">        protocol.getKeepAliveTimeout())) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (inputBuffer.getParsingRequestLinePhase() == -<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> SocketState.UPGRADING;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handleIncompleteRequestLineRead()) &#123;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Process the Protocol component of the request line  </span></span><br><span class="line"><span class="comment">// Need to know if this is an HTTP 0.9 request before trying to  </span></span><br><span class="line"><span class="comment">// parse headers.</span></span><br><span class="line"><span class="comment">//开始获取请求的协议  </span></span><br><span class="line">prepareRequestProtocol();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (protocol.isPaused()) &#123;  </span><br><span class="line">    <span class="comment">// 503 - Service unavailable  </span></span><br><span class="line">    response.setStatus(<span class="number">503</span>);  </span><br><span class="line">    setErrorState(ErrorState.CLOSE_CLEAN, <span class="literal">null</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    keptAlive = <span class="literal">true</span>;  </span><br><span class="line">    <span class="comment">// Set this every time in case limit has been changed via JMX  </span></span><br><span class="line">    request.getMimeHeaders().setLimit(protocol.getMaxHeaderCount());  </span><br><span class="line">    <span class="comment">// Don&#x27;t parse headers for HTTP/0.9  </span></span><br><span class="line">    <span class="keyword">if</span> (!http09 &amp;&amp; !inputBuffer.parseHeaders()) &#123;  </span><br><span class="line">        <span class="comment">// We&#x27;ve read part of the request, don&#x27;t recycle it  </span></span><br><span class="line">        <span class="comment">// instead associate it with the socket        </span></span><br><span class="line">        openSocket = <span class="literal">true</span>;  </span><br><span class="line">        readComplete = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (!protocol.getDisableUploadTimeout()) &#123;  </span><br><span class="line">        socketWrapper.setReadTimeout(protocol.getConnectionUploadTimeout());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们今天只讨论网络通信本身，不会深入的探究具体的对请求的解析流程，所以如果对请求的解析实现有兴趣可以自己看看。<br>接下来会运行到这里</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;  </span><br><span class="line">    <span class="comment">// Setting up filters, and parse some request headers  </span></span><br><span class="line">    rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      </span><br><span class="line">        prepareRequest();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">        ExceptionUtils.handleThrowable(t);  </span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;  </span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;http11processor.request.prepare&quot;</span>), t);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 500 - Internal Server Error  </span></span><br><span class="line">        response.setStatus(<span class="number">500</span>);  </span><br><span class="line">        setErrorState(ErrorState.CLOSE_CLEAN, t);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>prepareRequest 方法负责将收到的请求信息转换为能够使用的键值对形式，还是和上面的一样，HTTP 信息解析不属于我们今天讨论的内容，有需要可以自己了解<br>接下来就是正式的请求处理了<br></p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;<span class="comment">//如果运行进行IO  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);<span class="comment">//将状态切换为正在处理  </span></span><br><span class="line">        getAdapter().service(request, response);<span class="comment">//调用Adapter进行处理，此时请求的信息已经被封装到了request中</span></span><br><span class="line">        <span class="keyword">if</span> (keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; !isAsync() &amp;&amp;  </span><br><span class="line">                statusDropsConnection(response.getStatus())) &#123;  </span><br><span class="line">            setErrorState(ErrorState.CLOSE_CLEAN, <span class="literal">null</span>);  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div><br>在这里，我们终于见到了 Tomcat 的下一个重要组件：Adapter。这个组件时一个转换组件，负责将获得的 HTTP 请求信息转换为容器能够处理的形式。<p></p><p>我们在上一部分中看到了 Adapter 组件被调用，adapter 会尝试着对信息做分离，然后将需要处理的信息投送到对应的 Container 组件中进行处理，我们使用 Tomcat 时提供的 Servlet 就是容器的一种，负责具体的业务处理<br>上面我们看到了 adapter 方法被调用，在完成几个异常检查之后会有下面的流程</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对请求中的信息做必要的处理</span></span><br><span class="line">postParseSuccess = postParseRequest(req, request, res, response);  </span><br><span class="line"><span class="keyword">if</span> (postParseSuccess) &#123;  </span><br><span class="line">    <span class="comment">// check valves if we support async</span></span><br><span class="line">    <span class="comment">//检查是否支持异步  </span></span><br><span class="line">    request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());  </span><br><span class="line">    <span class="comment">// Calling the container</span></span><br><span class="line">    <span class="comment">//开始获取正确的容器然后对请求进行处理  </span></span><br><span class="line">    connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>解释一下最后一行的一长串流式调用，首先获得当前的 connector 对应的 Service，然后从 service 中获取容器，此处的获取容器方法固定返回 Engine 容器，Engine 一般在每个 Service 中只有一个，是顶层容器，负责将请求分发给真正负责处理的容器。然后从 Engine 中获得处理管线，处理管线由一个基本容器 BaseContainer 和一系列可选包装器（Valves）组成，这些包装器负责在正式的请求处理前的检查工作与请求结束后的资源清理工作。Tomcat 原生实现了大量的 Valve，具体可以看一下这张图<br><img lazyload src="/images/loading.svg" data-src="/../img/Pasted%20image%2020250512223207.png"><br>在默认的情况下 Engine 中的 Valve 是一个 StandardEngineValve（当然可以通过配置加一些实现），实现如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Select the Host to be used for this Request  </span></span><br><span class="line">    <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();  </span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!response.isError()) &#123;  </span><br><span class="line">            response.sendError(<span class="number">404</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;  </span><br><span class="line">        request.setAsyncSupported(host.getPipeline().isAsyncSupported());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Ask this Host to process this request  </span></span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们可以看到这里实际上是将请求分发到了 HOST 容器，HOST 容器包含一个 StandardHostValve，实现如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Select the Context to be used for this Request  </span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> request.getContext(); </span><br><span class="line">    <span class="comment">//尝试获取请求的上下文容器 </span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// Don&#x27;t overwrite an existing error  </span></span><br><span class="line">        <span class="keyword">if</span> (!response.isError()) &#123;  </span><br><span class="line">            response.sendError(<span class="number">404</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;  </span><br><span class="line">        request.setAsyncSupported(context.getPipeline().isAsyncSupported());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">asyncAtStart</span> <span class="operator">=</span> request.isAsync();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!asyncAtStart &amp;&amp; !context.fireRequestInitEvent(request.getRequest())) &#123;  </span><br><span class="line">           <span class="keyword">return</span>;  </span><br><span class="line">           <span class="comment">//异步请求检查</span></span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">.        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;</span><br><span class="line">            <span class="comment">//尝试将请求分发给context容器  </span></span><br><span class="line">                context.getPipeline().getFirst().invoke(request, response);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">            ExceptionUtils.handleThrowable(t);  </span><br><span class="line">            container.getLogger().error(sm.getString(<span class="string">&quot;standardHostValve.exception&quot;</span>, request.getRequestURI()), t);  </span><br><span class="line">.            <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;  </span><br><span class="line">                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);  </span><br><span class="line">                throwable(request, response, t);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在请求又回到了Host的控制下  </span></span><br><span class="line">        response.setSuspended(<span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);  </span><br><span class="line">        <span class="comment">//如果context容器刚刚已经销毁了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//如果程序需要进行错误报告  </span></span><br><span class="line">        <span class="keyword">if</span> (response.isErrorReportRequired()) &#123;</span><br><span class="line">            <span class="comment">//接下来检测是否运行更进一步的IO  </span></span><br><span class="line">            <span class="type">AtomicBoolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);  </span><br><span class="line">            response.getCoyoteResponse().action(ActionCode.IS_IO_ALLOWED, result);</span><br><span class="line">            <span class="comment">//如果允许IO，那么渲染一个错误页面  </span></span><br><span class="line">            <span class="keyword">if</span> (result.get()) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    throwable(request, response, t);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    status(request, response);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!request.isAsync() &amp;&amp; !asyncAtStart) &#123;  </span><br><span class="line">            context.fireRequestDestroyEvent(request.getRequest());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//刷新长连接的最后一次访问的时间  </span></span><br><span class="line">        <span class="keyword">if</span> (context.getAlwaysAccessSession()) &#123;  </span><br><span class="line">            request.getSession(<span class="literal">false</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        context.unbind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>接下来是 context 容器的 invoke 方法，这个方法我就不展示了，在 StandardContextValve 中实现，就是做了一点处理后移交给 Wrapper 容器，我们可以看看 Wrapper 在干什么</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在跳过错误检查后开始分配Servlet</span></span><br><span class="line"><span class="comment">// Allocate a servlet instance to process this request  </span></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!unavailable) &#123;  </span><br><span class="line">        servlet = wrapper.allocate();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (UnavailableException e) &#123;  </span><br><span class="line">    container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>, wrapper.getName()), e);  </span><br><span class="line">    checkWrapperAvailable(response, wrapper);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (ServletException e) &#123;  </span><br><span class="line">    container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>, wrapper.getName()),  </span><br><span class="line">            StandardWrapper.getRootCause(e));  </span><br><span class="line">    throwable = e;  </span><br><span class="line">    exception(request, response, e);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">    ExceptionUtils.handleThrowable(e);  </span><br><span class="line">    container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>, wrapper.getName()), e);  </span><br><span class="line">    throwable = e;  </span><br><span class="line">    exception(request, response, e);  </span><br><span class="line">    <span class="comment">// servlet = null; is set here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对，在上面漫长的兜圈子后我们终于看到了我们熟悉的 Servlet，allocate 方法就不看了，就是将 Wrapper 内携带的单例容器返回来而已，如果没有创建单例就自己创建一个</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((servlet != <span class="literal">null</span>) &amp;&amp; (filterChain != <span class="literal">null</span>)) &#123;  </span><br><span class="line">    <span class="comment">// Swallow output if needed  </span></span><br><span class="line">    <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">    <span class="comment">//判断是否需要捕获系统输出，如System.in或System.err  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            SystemLogHandler.startCapture();  </span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;<span class="comment">//异步请求处理  </span></span><br><span class="line">                request.getAsyncContextInternal().doInternalDispatch();  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//调用过滤链</span></span><br><span class="line">                filterChain.doFilter(request.getRequest(), response.getResponse());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">//最后记录刚刚捕获的信息 </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">log</span> <span class="operator">=</span> SystemLogHandler.stopCapture();  </span><br><span class="line">            <span class="keyword">if</span> (log != <span class="literal">null</span> &amp;&amp; !log.isEmpty()) &#123;  </span><br><span class="line">                context.getLogger().info(log);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">//不需要捕获输出那么直接处理</span></span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;  </span><br><span class="line">            request.getAsyncContextInternal().doInternalDispatch();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            filterChain.doFilter(request.getRequest(), response.getResponse());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实质上 Servlet 容器中方法的调用发生在 doFilter 方法中，我们可以看一下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalDoFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span>  </span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Call the next filter if there is one  </span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">        <span class="comment">//顺次获取下一个过滤器  </span></span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !(filterConfig.getFilterDef().getAsyncSupportedBoolean())) &#123;  </span><br><span class="line">                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;  </span><br><span class="line">                <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;  </span><br><span class="line">                <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;  </span><br><span class="line">                <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span> ((HttpServletRequest) req).getUserPrincipal();  </span><br><span class="line">  </span><br><span class="line">                Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; req, res, <span class="built_in">this</span> &#125;;  </span><br><span class="line">                SecurityUtil.doAsPrivilege(<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//再次调用相同的方法，调用下一个过滤器，由于一般情况下过滤器是我们自己实现的，我们会在</span></span><br><span class="line">            <span class="comment">//doFilter中进行过滤，然后手动调用filterChain.doFilter来实现连续的过滤  </span></span><br><span class="line">                filter.doFilter(request, response, <span class="built_in">this</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">            e = ExceptionUtils.unwrapInvocationTargetException(e);  </span><br><span class="line">            ExceptionUtils.handleThrowable(e);  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.filter&quot;</span>), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// We fell off the end of the chain -- call the servlet instance </span></span><br><span class="line">    <span class="comment">//运行到此处说明走完了所有过滤器，接下来调用Servlet容器 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (dispatcherWrapsSameObject) &#123;  </span><br><span class="line">            lastServicedRequest.set(request);  </span><br><span class="line">            lastServicedResponse.set(response);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;  </span><br><span class="line">            request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// Use potentially wrapped request from this point  </span></span><br><span class="line">        <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp; (response <span class="keyword">instanceof</span> HttpServletResponse) &amp;&amp;  </span><br><span class="line">                Globals.IS_SECURITY_ENABLED) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;  </span><br><span class="line">            <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span> ((HttpServletRequest) req).getUserPrincipal();  </span><br><span class="line">            Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; req, res &#125;;  </span><br><span class="line">            SecurityUtil.doAsPrivilege(<span class="string">&quot;service&quot;</span>, servlet, classTypeUsedInService, args, principal);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//一般的HTTP请求直接运行到这里，然后调用Service方法  </span></span><br><span class="line">            servlet.service(request, response);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;  </span><br><span class="line">        e = ExceptionUtils.unwrapInvocationTargetException(e);  </span><br><span class="line">        ExceptionUtils.handleThrowable(e);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.servlet&quot;</span>), e);  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (dispatcherWrapsSameObject) &#123;  </span><br><span class="line">            lastServicedRequest.set(<span class="literal">null</span>);  </span><br><span class="line">            lastServicedResponse.set(<span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>显然，到这一步请求对应的相应已经有了，该返回对应的结果了，那么返回怎么走，来，回忆上面的流程，我们实际是调用了 Adapter 组件的 service 方法，然后一层一层的调用容器，现在我们继续返回 service 方法，看看接下来该干什么，比较关键的是这个</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recycle the wrapper request and response  </span></span><br><span class="line"><span class="keyword">if</span> (!async) &#123;  </span><br><span class="line">    updateWrapperErrorCount(request, response);  </span><br><span class="line">    request.recycle();  </span><br><span class="line">    response.recycle();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们注意到分别调用了请求和响应的 recycle 方法，这个方法会释放对象内所有的引用，即清理对象，使对象可以循环使用。<br>再往回是 processor 的 service 方法，最后部分的实现如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getErrorState().isError() || (protocol.isPaused() &amp;&amp; !isAsync())) &#123;  </span><br><span class="line">    <span class="keyword">return</span> SocketState.CLOSED;<span class="comment">//如果存在错误或者协议处理器中标注被暂停且不是异步请求  </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync()) &#123;  </span><br><span class="line">    <span class="keyword">return</span> SocketState.LONG;  </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUpgrade()) &#123;  </span><br><span class="line">    <span class="keyword">return</span> SocketState.UPGRADING;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (sendfileState == SendfileState.PENDING) &#123;  </span><br><span class="line">        <span class="keyword">return</span> SocketState.SENDFILE;  <span class="comment">//可能的状态为Pending，即等待处理，此时需要发送文件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (openSocket) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (readComplete) &#123;  </span><br><span class="line">                <span class="keyword">return</span> SocketState.OPEN;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> SocketState.LONG;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> SocketState.CLOSED; <span class="comment">//对于一个非异步的，没有出错的，不要求长连接的请求，返回关闭信号</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>接下来是协议处理器的 process 方法，我就不展示了，检测到 closed 状态直接返回，最后一路收到 closed 状态一路关闭与回收，最终关闭 Socket 通道</p><p>我们可以大概的梳理一下上面的过程，当 Tomcat 启动时 Service 组件启动Connector ，Connector组件启动线程池与监听端口的 Acceptor，监听到的请求被 SocketWrapper，SocketWrapper 实现了 Runnable 接口，自己将自己传递给 Protocol 协议处理器，协议处理器内部通过 Adapter 将请求转发给 Container，在经历了 Engine，Host，Context，Wrapper 容器的 Valve 后被传递给负责实际业务逻辑的 Servlet，在 Servlet 内发生实际的请求处理，将相应结果写回。</p><p>在最后的最后，我们再回到一个问题，Spring 框架与 Tomcat 时怎么整合的？答案非常简单，DisPatchServlet 是 HttpServlet 的一个子类，然后在启动时相 Tomcat 只注册了这一个 Servlet，然后由 DisPatchServlet 来调用不同的 Controller 实现。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>终于写完了，心累啊。不过讲了这么多，还是存在不少问题，比如我们实际上没有去关注 TCP 协议，HTTP 协议等内容，只是泛泛的谈了一下 Tomcat 的思路，下期吧，下一篇我们直接从网络架构开讲，好好说说各个协议的实现。</p><p><img lazyload src="/images/loading.svg" data-src="/../img/Pasted%20image%2020250513193551.png"></p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 网络通信</li><li><strong>作者:</strong> Soul</li><li><strong>创建于 :</strong> 2025-05-08 10:59:41</li><li><strong>更新于 :</strong> 2025-05-13 19:36:16</li><li><strong>链接:</strong> https://soulmate.org.cn/posts/3e3a64ad/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/%E6%89%8B%E5%86%99Spring/">#手写Spring</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/posts/4ee2495d/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">互联网结构与网络通信协议</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/posts/81499a4c/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">NIO体系</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">网络通信</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatchServlet%E5%88%86%E6%9E%90"><span class="nav-text">DispatchServlet分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TomCat%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="nav-text">TomCat机制分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="customize-info my-1">欢迎随意转载</div><div class="text-center">&copy; <span>2024</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Soul</a><p class="post-count space-x-0.5"><span>共撰写了 10 篇文章 </span><span>共 56.8k 字</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div class="icp-info my-1"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">蜀ICP备2025146966号</a></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Swup.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/utils.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/main.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/localSearch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/lazyload.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/runtime.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/assets/odometer-theme-minimal.css"><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/typed.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/anime.min.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/essays.js" data-swup-reload-script></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>