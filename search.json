[{"title":"Docker入门","url":"/2025/04/01/Docker%E5%85%A5%E9%97%A8/","content":"最近忙着写项目，好久没更新内容了。而且就在昨天，重装系统的时候我居然忘了把博客的本地文件保存一份！！！现在我已经失去了前面博客的所有内容，不得不花费大量时间重新把前面的内容整理一次，孩子心里苦啊。\n闲话就聊到这里,今天我们来了解一下Docker技术.Docker可以帮助我们快速的实现项目依赖环境的完整打包.方便我们将项目快速的部署到不同的设备上去.\n由于Windows上没有原生的Docker,想要运行需要套几层壳,所以这次我们使用Ubuntu.具体版本为Ubuntu24.04.(当然现在有了WSL2，其实在windows上也不是很麻烦，直接去官网https://www.docker.com/下载即可)\nDocker的安装我们首先来完场Docker的安装.这部分比较简单,先安装一些依赖\nsudo apt-get install ca-certificates curl gnupg lsb-release\n\n然后安装官方的GPG Key\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n然后将Docker的下载地址放到apt的搜索列表中\necho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n接着更新一下列表\nsudo apt update\n\n接着下载Docker的社区版本（Docker分为社区版和商业版）\nsudo apt install docker-ce\n\n可以通过\ndocker --version\n\n来判断是否下载成功\n\nDocker的配置到此完成，我们接下来详细的了解一下Docker的结构\n容器与镜像容器与虚拟机的区别在开始这一板块之前，我们先来思考一个问题：假设我现在使用的是Ubuntu22.04,然后下载一个Ubuntu24.04的Docker，那么我是否能使用Ubuntu24.04的全部功能呢？这个问题在虚拟机上是显然的，但是在Docker中却不那么肯定。\n我们可以看一下这张图：\n\n这张图体现了虚拟机和Docker的重要区别：虚拟机的虚拟是内核级别的，所有的虚拟机相互独立，互不干扰。但是，所有的Docker共用设备的内核空间，只拥有独立的用户空间。也就是说，如果ubuntu22.04的内核支持相关功能，我们是可以顺利使用的，但如果内核不知相关功能，我们就无能为力了。\n此外，还有一点值得注意：容器与镜像的区别。\n直接构建了解了这些，我们开始尝试自己构建一个镜像，每一个应用都运行在操作系统上，所以构建自己的镜像也必须基于最基本的系统镜像，我们一般称这些镜像为Base镜像（当然，在很多时候我们也不一定真的从最基本的镜像开始构建，而是使用一些已经安装了一些必要的环境的镜像开始构建）。我们这里尝试去构建一个包含了jdk的ubuntu镜像\n首先我们拉取一个ubuntu的Base镜像(最近由于DockerHub的限制，很多镜像源都不能用了，如果下载不下来，请自行寻找合适的镜像源或者科学上网)\ndocker pull ubuntu:22.04\n\n这里注意，一个镜像的标准名称通常为name:tag的格式，name用来说明名称，tag用来说明版本\n下载完成后可以通过\ndocker images\n\n来查看当前的所有镜像\n\n可以看到，刚刚下载的Ubuntu镜像小的惊人，只有77.9MB,这是因为作为Base镜像，只保留了最基本的用户空间运行能力，我们平时很多常用的命令都是无法在这个镜像中执行的。\n接下来在容器中运行这个镜像\ndocker run -it ubuntu:22.04\n\n其中i参数指创建一个标准的输入输出接口，t参数指创建一个虚拟的tty设备来作为终端供我们使用，这两个参数一般同时使用，效果如下：\n我们已经进入了基于ubuntu镜像创建的容器的内部\n我们的目的是构建一个包含jdk的ubuntu镜像，所以现在执行下列命令\napt update &amp;&amp; apt install -y openjdk-21-jdk\n\n下载完成后可以使用exit直接退出\n现在查看以下我们的容器\ndocker ps -a\n\n如果不使用a参数则只显示处于运行状态下的容器\n\n接下来执行\ndocker commit 容器ID/名称 新的镜像名\n\nDocker中所有可以使用id的地方都可以使用ID的一部部分，只要能保证具有唯一性就好，例如我们可以在此处使用\ndocker commit fd jdk:21\n\n看一看结果\n\n注意到经过我们的一番操作后镜像的体积发生了巨大的膨胀，这是因为我们在下载jdk时不但下载了jdk,还下载了jdk运行时必要的操作系统依赖。\n对于已经存在的镜像，我们可以\ndocker start name/id #启动现有的镜像docker stop name/id #停止正在运行的镜像\n\n我们可以使用这种方法去构建任何镜像，但这种镜像的构建存在一个问题：不够透明。除你之外没有人知道这个镜像是如何被构建的，对个人使用来说，这种构建方式显然是无所谓的，但是如果这个镜像是面向其他人的，我们就不应该这么做，我们需要使用Dockerfile来完成构建\n通过Dockerfile构建在开始之前我们先删除之前创造的镜像与容器\ndocker rmi 镜像ID #删除镜像docker rm 容器ID #删除容器\n\n同样的，只要输入ID的开头，确保唯一性即可\n接下来我们创建一个名为Dockerfile的文件，并写入如下的内容\nFROM ubuntu:22.04RUN apt update &amp;&amp; apt install -y openjdk-21-jdk\n\n在该文件目录下执行\ndocker build -t jdk:21 .\n\n就能得到和我们之前所构建的jdk镜像完全相同的镜像了\n下面我展示一些在Dockerfile中常使用的命令\nFROM &lt;基础镜像&gt; #从对应的基础镜像开始构建LABEL xxx=xx #给镜像添加元数据，一般用来标识作者，版本等信息ARG xxx=xx #创建一个名为xxx的参数，其值为xx,为此后调用这个值提供方便RUN xxx #在基础镜像内执行xxxCOPY /xx /xxx #将/xx目录下的内容复制到镜像的/xxx目录下ADD https://example.com/file.tar.gz /app/ #与COPY类似，但支持远程下载WORKDIR /xx #设置容器启动时将自动跳转到容器内的/xx目录下ENV xxx=xx #为镜像添加一个名称为xxx的环境变量，其值为xxEXPOSEE xxx #对外暴露容器的xxx端口VOLUME /xx #在容器的/xx目录下创建一个挂载点用于数据持久化，这点我们后面再解释ENTRYPOINT xxx #在容器启动时自动执行xxx,优先级高于CMDCMD xxx #在容器启动时自动执行xxx\n\n当然，这并不是全部的命令，但大多数时候对我们来说已经够用了\n在这部分的最后，让我们了解一下如何将我们所创建的镜像推送到DockerHub，首先自行到Dockerhub创建一个仓库\n\n接下来我们将我们之前的镜像重新命名后推送\ndocker tag jdk:21 myjdk:21docker push 你的用户名/myjdk:21\n\n根据规范，我们必须在推送时添加自己的用户名来保证推送到属于我们自己的仓库，在拉取时同样采用\ndocker pull 你的用户名/myjdk:21\n\n的格式来确保获得正确的镜像\n这一步操作如果网络环境好可以试一试，毕竟一次性要上传800MB,在当前网络环境下有时候会比较困难\nDocker网络管理接下来我们来了解一下Docker的网络管理，我们执行如下的命令\ndocker network ls\n\n\n我们可以看到当前总共有三个网路，这三个网络是Docker在下载时就帮我们创建的，分别对应Docker支持的三种网络类型bridge null host\n我们首先来看看null网络，这个网络中只有一个本地环路，与宿主机的网络环境相互隔离，无法通过网络访问，用于部分有特殊安全需求的环境。如果想使用null网络，可以使用\ndocker run --network=none jdk:21\n\n然后是host网络，如果容器使用的是这种网络，相当于直接使用宿主机的网络环境，在这种网络下，我们，容器中的网络配置与宿主保持一致，不需要镜像额外的开放端口等操作。在这种模式下，网络通信的损失是最小的.如果想使用我们\n最后是bridge网络，或者说是桥接网络，你可以简单的理解为在宿主机上创建了一个虚拟的局域网，宿主机与容器都是这个虚拟局域网的一台设备，不同设备之间通过这个局域网进行信息交互。这也是所有容器的默认网络模式。在这种模式下，我们前面的在Dockerfile中主动暴露端口的行为就有了意义，举个简单的例子\ndocker run -p 1234:80 -n test jdk:21\n\n这里我使用了两个参数，p参数用来指定端口映射，将宿主机的1234端口映射到容器的80端口，此时对宿主机1234端口的访问就会通过桥接网络转发到容器的80端口。n参数是给容器命名的，我们之前所创建的容器起名称都是docker随即生产的，我们可以通过这个参数手动指定。\n在这里你可能会问，那我们之前在Dockerfile中提到的EXPOSE指令又有什么作用呢？这个指令更多的起到提醒作用，用于提醒用户需要将这个端口映射到宿主机中\n我们也可以创建自己的网络，例如这样\ndocker network creat --driver bridge test\n\n这样我们就创建了一个名为test的桥接网络，我们在启动时可以手动指定使用的网络\ndocker run --network=test image\n\n注意，虽然都是使用桥接网络，但是test网络与bridge网络两个网络是互相隔离的，无法互相进行通信，当然，我们也可以主动进行连接\ndocker network connect test containerID/name\n\n此时容器就被主动的连接到了test网络\n容器数据持久化还记得我们上面提到的volume指令吗？对于一个一般的容器，在停止运行时所有运行时产生的数据都将被删除，这无疑是我们所不想看到的，所以我们可以使用VOLUME指令创建挂载点，此时docker会产生一个匿名卷来存储doker对应目录下的数据，这个匿名卷在宿主机上的路径一般为/var/lib/docker/volumes，不过我们可以选择进一步的定制化一些，我们可以将容器的数据挂载到宿主机的指定路径下，使用\ndocker run -v /host/path:/container/path image\n\n此时会将容器的&#x2F;container&#x2F;path与宿主机的&#x2F;host&#x2F;path相互绑定，宿主机与容器任何一方对数据的修改都会在另一方体现\n如果我们使用v参数但不指定宿主机路径，则会在宿主机上自动创建对应路径\n如果我们想要在多个容器之间共享数据呢，聪明的你一定想到创建一个公共目录，经所有容器都挂载到对应的目录。但是我们还有别的办法：直接将一个容器的路径挂载到另一个容器\ndocker run -p 80:80 --volumes-from=data_test test\n\n此时test继承了data_test的挂载信息，在总体容器数量比较多时我们通常会创建一个专门的容器用来管理数据（被称为数据卷容器），例如上面的data_test,所有的容器再继承其挂载方式\nDocker容器管理接下来我们来聊一聊对运行状态下的容器的管理，有以下常用的命令\ndocker log 容器名/ID\n\n可以用来输出容器中的控制台信息（f参数可用来保持持续输出）\ndocker attach 容器ID/名称\n\n直接进入某个运行的容器的内部，注意在完成操作后先按Ctrl+P再按Ctrl+Q退出，千万不要按Ctrl+C这会导致容器停止运行\ndocker exec -it 容器ID/名称\n\n为容器创建一个新的bash终端，如果容器中运行的项目会不断的对控制台输出信息，那么可以通过这个指令开启一个新的终端来对容器进行操作\ndocker stats\n\n用于查看所有容器的状态\ndocker top 容器ID/名称\n\n查看某个容器的所有进程信息\n接下来是几个比较不推荐的\ndocker kill 容器ID/名称 #强制终止容器docker pause 容器ID/名称 #暂停容器docker unpause 容器ID/名称 #与上一条相反\n\n其实还有很多操作，但是这些操作都是偏运维向的，这里就不做介绍了\n常用参数介绍注意，docker非常重视灵活性，所有在dockefile中规定的东西都可以被在启动时覆盖，实际的覆盖操作使用以下这些参数\n\n\n\n参数\n描述\n示例\n\n\n\n\n\n-d\n后台运行容器\ndocker run -d IMAGE\n\n\n\n\n-it\n交互式终端，-i 保持标准输入打开，-t 分配一个伪终端\ndocker run -it IMAGE\n\n\n\n\n--name\n为容器指定一个名称\ndocker run --name mycontainer -d IMAGE\n\n\n\n\n-p\n端口映射，格式为 主机端口:容器端口\ndocker run -p 8080:80 -d IMAGE\n\n\n\n\n-v\n数据卷映射，格式为 主机路径:容器路径[:权限]\ndocker run -v /host/path:/container/path -d IMAGE\n\n\n\n\n--env 或 -e\n设置环境变量\ndocker run --env MY_VAR=value -d IMAGE\n\n\n\n\n--network\n将容器连接到指定的 Docker 网络\ndocker run --network mynetwork -d IMAGE\n\n\n\n\n--restart\n设置容器的重启策略，可选值为 no、on-failure、always、unless-stopped\ndocker run --restart always -d IMAGE\n\n\n\n\n--link\n将容器连接到另一个容器\ndocker run --link other-container:alias -d IMAGE\n\n\n\n\n--cpus\n限制容器使用的 CPU 资源\ndocker run --cpus=&quot;1.5&quot; -d IMAGE\n\n\n\n\n--memory\n限制容器使用的内存\ndocker run --memory=&quot;256m&quot; -d IMAGE\n\n\n\n\n--gpus\n指定容器可以访问的 GPU 设备\ndocker run --gpus all -d IMAGE\n\n\n\n\n--log-driver\n指定日志驱动\ndocker run --log-driver=syslog -d IMAGE\n\n\n\n\n--health-cmd\n配置容器的健康检查命令\n&#96;docker run –health-cmd&#x3D;”curl -f http://localhost/\n\nexit 1” -d IMAGE&#96;\n\n\n--user\n指定容器内进程的用户\ndocker run --user username -d IMAGE\n\n\n\n\n--security-opt\n设置 SELinux 或 AppArmor 配置\ndocker run --security-opt seccomp=unconfined -d IMAGE\n\n\n\n\n--cap-add\n添加容器的 Linux 能力\ndocker run --cap-add=SYS_ADMIN -d IMAGE\n\n\n\n\n--cap-drop\n删除容器的 Linux 能力\ndocker run --cap-drop=SYS_ADMIN -d IMAGE\n\n\n\n\n--privileged\n给容器赋予特权，可以访问主机的设备\ndocker run --privileged -d IMAGE\n\n\n\n\n--tmpfs\n在容器内创建临时文件系统\ndocker run --tmpfs /tmp -d IMAGE\n\n\n\n\n--ulimit\n设置容器的资源限制，如最大打开文件数、最大进程数等\ndocker run --ulimit nofile=1024:1024 -d IMAGE\n\n\n\n\n--hostname\n设置容器的主机名\ndocker run --hostname my_container -d IMAGE\n\n\n\n\n--dns\n指定容器使用的自定义 DNS 服务器\ndocker run --dns 8.8.8.8 -d IMAGE\n\n\n\n\n--dns-search\n指定容器的 DNS 域\ndocker run --dns-search example.com -d IMAGE\n\n\n\n\n--entrypoint\n覆盖镜像的默认入口点\ndocker run --entrypoint /custom_entrypoint -d IMAGE\n\n\n\n\n--rm\n容器退出时自动删除容器\ndocker run --rm -d IMAGE\n\n\n\n\n--mount\n更详细的挂载配置，支持类型 bind、volume、tmpfs\ndocker run --mount type=bind,source=/data,target=/app/data -d IMAGE\n\n\n\n\n--shm-size\n设置容器的共享内存大小\ndocker run --shm-size 2g -d IMAGE\n\n\n\n\n--volume-driver\n指定容器使用的卷驱动程序\ndocker run --volume-driver my_driver -d IMAGE\n\n\n\n\n--env-file\n从文件读取环境变量\ndocker run --env-file=env.list -d IMAGE\n\n\n\n\n--label\n为容器添加元数据标签\ndocker run --label &quot;env=prod&quot; -d IMAGE\n\n\n\n\n需要特别说明的是ENTRYPOINT可以通过--entrypoint  覆盖，而CMD指令可以通过类似\ndocker run my_image echo &quot;Hello, World!&quot;\n\n这样原来的CMD命令将会被覆盖，如果需要的命令过于复杂，你还可以这样\ndocker run my_image &lt; cmd.sh\n\n直接编写一份完整的脚本然后导入\n结语如果你之前来过我的站，你可能会发现所有的之前的文章都已经消失了，由于某次出人意料的事故，所有之前写下的文章都美丽，悲～～～。所以只好从零开始了，有很多东西确实比较有用，有空的话我会尽力再尝试写一份的\n\n","tags":["杂谈"]},{"title":"IDEA中VIM插件的使用","url":"/2025/04/17/IDEA%E4%B8%ADvim%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"  今天我们讲一讲关于idea中vim插件的使用。其实网上一直有这样两波人，一批人在疯狂的吹嘘vim到底有多好用，甚至看不起平时使用IDE的人；另一批人却将vim的使用者称之为装。 从我个人的使用感受上来说，vim确实是个好东西，唯一的问题就是不怎么好上手，在习惯以后确实能够大大提高编码效率。但是真的完全用vim写代码，需要做各种繁琐的配置，给vim安装各种各样的插件，还不一定能百分百达到完整的IDE的效果，所以我的选择是IDEEA加vim插件，使用起来感觉要好很多\nvim插件下载几乎所有的主流IDE都有对应的vim插件，而且大部分还做的不错。在IDEA中打开自带的插件市场搜索vim并下载下面的三个插件\n\n下载完成后你可以看到类似的状态，右下角出现了一个绿色的normal,光标变成了按过Insert键后的样式就说明下载成功了\n\n基本的使用接下来讲一下vim的基本使用，这些操作和vim保持一致，可以在任何一个vim环境中使用。\n我实在懒得把这些东西重写一次，所以直接使用来自于菜鸟教程的表格，这里是原网页https://www.runoob.com/linux/linux-vim.html\n\n\n\n移动光标的方法\n\n\n\n\nh 或 向左箭头键(←)\n光标向左移动一个字符\n\n\nj 或 向下箭头键(↓)\n光标向下移动一个字符\n\n\nk 或 向上箭头键(↑)\n光标向上移动一个字符\n\n\nl 或 向右箭头键(→)\n光标向右移动一个字符\n\n\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！\n\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n[Ctrl] + [d]\n屏幕『向下』移动半页\n\n\n[Ctrl] + [u]\n屏幕『向上』移动半页\n\n\n+\n光标移动到非空格符的下一行\n\n\n-\n光标移动到非空格符的上一行\n\n\nn\n那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\nH\n光标移动到这个屏幕的最上方那一行的第一个字符\n\n\nM\n光标移动到这个屏幕的中央那一行的第一个字符\n\n\nL\n光标移动到这个屏幕的最下方那一行的第一个字符\n\n\nG\n移动到这个档案的最后一行(常用)\n\n\nnG\nn 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！ (常用)\n\n\nn\nn 为数字。光标向下移动 n 行(常用)\n\n\n搜索替换\n\n\n\n&#x2F;word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\n使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！\n\n\n\n:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g\nn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)\n\n\n删除、复制与贴上\n\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\nnx\nn 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\n\n\ndd\n剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nndd\nn 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nd1G\n删除光标所在到第一行的所有数据\n\n\ndG\n删除光标所在到最后一行的所有数据\n\n\nd$\n删除游标所在处，到该行的最后一个字符\n\n\nd0\n那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nnyy\nn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\n\n\ny1G\n复制游标所在行到第一行的所有数据\n\n\nyG\n复制游标所在行到最后一行的所有数据\n\n\ny0\n复制光标所在的那个字符到该行行首的所有数据\n\n\ny$\n复制光标所在的那个字符到该行行尾的所有数据\n\n\np, P\np 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)\n\n\nJ\n将光标所在行与下一行的数据结合成同一行\n\n\nc\n重复删除多个数据，例如向下删除 10 行，[ 10cj ]\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n\n\n\n.\n不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)\n\n\n第二部分：一般模式切换到编辑模式的可用的按钮说明\n\n\n进入输入或取代的编辑模式\n\n\n\n\ni, I\n进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\n\n\na, A\n进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n第三部分：一般模式切换到指令行模式的可用的按钮说明\n\n\n指令行的储存、离开等指令\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)\n\n\nZQ\n不保存，强制退出。效果等同于 :q!。\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！\n\n\nvim 环境的变更\n\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n大家可以自行查看这些操作。你会发现这些操作保证了我们在双手不离开键盘中心区的前提下可以完成几乎所有的编辑操作，用习惯后还是非常爽的\n简单的配置但是从我个人的使用体验上来说，还是要对插件进行一些简单的配置，这样才能用起来更爽。点击normal左侧的彩色v图标\n\n然后选择settings\n\n接下来进入这个页面\n\n可以避免vim插件覆盖一些我们常用的快捷键的功能，比如我将Ctrl+A,Ctrl+C等常用的按键功能保留了下来\n接下来点击应用后关掉这个页面，再次点击v图标，选择Creat ～&#x2F;.ideavimrc 进入vim插件的配置文件\n我在下面贴一下我自己的配置并提供比较详细的注释，又需要的可以自己改写\nbasicPlug &#x27;machakann/vim-highlightedyank&#x27;&quot; Commentary pluginPlug &#x27;tpope/vim-commentary&#x27;&quot; 1. 基础 Vim 行为&quot; ----------------------------set number&quot; 在编辑器左侧显示绝对行号，有助于快速跳转到指定行（如输入 50G）并与同事共享行号定位。vim原生选项。set relativenumber&quot; 将当前行显示为绝对行号，其它行显示相对行号（与当前行的距离）。在进行跳转（例如 5j、3k）或上下文操作时非常直观。set cursorline&quot; 在当前行绘制高亮背景，增强光标位置的视觉识别，减少长文件中定位迷失的可能。set showmode&quot; 在命令行区域显示当前模式（-- INSERT --、-- VISUAL -- 等），方便快速确认当前是普通模式还是插入模式。set showcmd&quot; 当你输入多键命令（例如 d5w）时，实时在底部显示已输入的部分，帮助跟踪复杂映射或宏输入。set incsearch&quot; 在输入搜索模式（/pattern）时，边输入边高亮匹配，实时预览匹配结果，无需回车确认即可判断效果。set hlsearch&quot; 持续高亮所有与搜索模式匹配的项，便于一次性观察整个文件中的分布位置。set scrolloff=5&quot; 光标上下留有 5 行空白，以保持视野中心；在滚动时不至于光标贴近屏幕边缘。set sidescrolloff=5&quot; 同理，左右侧留 5 列空白，适用于超长行的水平滚动。set clipboard+=unnamed&quot; 将 Vim 的剪贴板与系统剪贴板合并，复制/粘贴可直接与 IDEA 与其他应用共享，免去额外切换。set wildmenu&quot; 启用命令行自动补全菜单，按 Tab 循环选择补全项，比原生补全反馈更友好。set wildmode=longest:full,full&quot; 补全方式：先补全公共前缀，再列出所有匹配项。提升多候选补全的效率与准确性。&quot; 2. Leader 键与快捷键映射&quot; ----------------------------let mapleader=&quot; &quot;&quot; 将“Leader 键”设为空格键；避免与常见 Vim 默认映射冲突，空格易按且手感舒适。&quot; 文件与项目操作nnoremap &lt;leader&gt;w :w&lt;CR&gt;&quot; 在普通模式下，按 空格+w 保存当前文件，等效于 :w。nnoremap &lt;leader&gt;q :q&lt;CR&gt;&quot; 按 空格+q 关闭当前编辑窗口。可按需改为 :bd 以保留分屏布局。nnoremap &lt;leader&gt;ff :action FindInPath&lt;CR&gt;&quot; 空格+ff 调用 IDEA 的“全局查找文件/符号”功能（Find in Path），跨项目搜索。nnoremap &lt;leader&gt;fr :action ReplaceInPath&lt;CR&gt;&quot; 空格+fr 调用“全局替换”功能（Replace in Path），在整个项目中批量替换。&quot; 窗口与标签管理nnoremap &lt;leader&gt;tn :tabnew&lt;CR&gt;&quot; 空格+tn 新建一个标签页，便于并行打开多个文件。nnoremap &lt;leader&gt;to :tabonly&lt;CR&gt;&quot; 空格+to 关闭除当前标签外的所有标签，只保留当前视图。imap a; &lt;Esc&gt;&quot; 将&lt;Esc&gt;映射为a;避免误触的同时方便使用，有些人也比较喜欢jj等映射方式&quot; 3. IntelliJ IDEA Action 映射&quot; ----------------------------&quot; IdeaVim 特有命令格式：:action + IDEA 内部 Action ID&quot; 可在 IDEA 中开启 “IdeaVim: Track Action Ids” 来得知鼠标点击或快捷键触发的 Action ID。nnoremap &lt;leader&gt;cf :action ReformatCode&lt;CR&gt;&quot; 空格+cf 触发 IDEA 的“代码格式化”功能，自动应用项目中的代码风格规则。nnoremap &lt;leader&gt;oi :action OptimizeImports&lt;CR&gt;&quot; 空格+oi 调用“优化导入”，自动移除无用 import 并按配置排序。nnoremap gd :action GotoDeclaration&lt;CR&gt;&quot; 在普通模式下按 gd，跳转到光标所在符号的声明位置，便于快速阅读实现细节。nnoremap gr :action FindUsages&lt;CR&gt;&quot; 按 gr 查找符号所有用法，在底部面板中展示所有引用，方便代码审计与重构。nnoremap &lt;leader&gt;r :action Run&lt;CR&gt;&quot; 空格+r 运行当前上下文（文件、测试或应用），等同于点击工具栏 Run 按钮。nnoremap &lt;leader&gt;d :action Debug&lt;CR&gt;&quot; 空格+d 启动调试，自动进入 Debug 模式，便于单步排查逻辑。&quot; 4. 可选：引入本地 Vim 配置&quot; ----------------------------&quot; 如果你同时在终端使用 Vim，可将常用 Vim 配置放在 ~/.vimrc，&quot; 在 IdeaVim 中通过以下命令复用：&quot; source ~/.vimrc\n\n这里反复提到了leader键，所谓的leader键可以理解为一个前缀键，类似于一个自定义的Ctrl键，默认为反斜杠，长按时进入特殊模式，此时可与继续搭配其他案件实现各种各样的功能\n结语刚刚接触时由于记不清各个案件所以会有比较明显的滞涩感，不过只要时间长了用的熟悉了，以后就难以离开这种感觉了\n\n","tags":["杂谈"]},{"title":"JSON解析","url":"/2025/04/07/JSON%E8%A7%A3%E6%9E%90/","content":"  既然要手写一个可用的spring框架，那么网络通信部分是必不可少的，既然涉及到了网络通信，那么显然json解析能力是必须具备的，所以我们今天来试着手写一个json解析器吧\nJSON的规则首先我们研究以下JSON解析的问题，开始之前我们可以先看看JSON的标准\n\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和编写，也易于机器解析和生成。以下是 JSON 的主要规则和特点：\n1. 基本结构\nJSON 数据由两种结构组成：\n对象（Object）：无序的键值对集合，用花括号 &#123;&#125; 表示。\n数组（Array）：有序的值的集合，用方括号 [] 表示。\n\n\n\n2. 数据类型   JSON 支持以下数据类型：\n\n字符串：用双引号 &quot; 括起来的文本，例如 &quot;Hello, World!&quot;\n数字：整数或浮点数，例如 42 或 3.14\n布尔值：true 或 false\n空值：null\n对象：键值对的集合，例如 &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30 &#125;\n数组：值的有序列表，例如 [1, 2, 3, &quot;apple&quot;]\n\n3. 键值对规则\n键（Key）必须是字符串，并且用双引号 &quot; 括起来。\n键和值之间用冒号 : 分隔。\n键值对之间用逗号 , 分隔。\n示例：&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;isStudent&quot;: false&#125;\n\n4. 数组规则\n数组中的值可以是任何 JSON 支持的数据类型。\n数组中的值用逗号 , 分隔。\n示例：[  &quot;apple&quot;,  &quot;banana&quot;,  42,  true,  &#123; &quot;name&quot;: &quot;Alice&quot; &#125;]\n\n5. 嵌套结构\nJSON 支持嵌套的对象和数组。\n示例：&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;traveling&quot;],  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;123 Main St&quot;,    &quot;city&quot;: &quot;New York&quot;  &#125;&#125;\n\n6. 格式规范\nJSON 数据必须是有效的对象或数组。\n键必须用双引号括起来（单引号无效）。\n逗号不能出现在最后一个键值对或数组值之后（即不能有尾随逗号）。\n示例（错误）：&#123; &quot;name&quot;: &quot;Alice&quot;, &#125;  // 错误：尾随逗号\n\n7. JSON 的用途\n用于 Web 应用程序中的数据交换。\n用于配置文件（如 .json 文件）。\n用于 API 数据传输。\n\n8. JSON 与 JavaScript 的关系\nJSON 是 JavaScript 的一个子集，但独立于语言，可以被多种编程语言解析和生成。\n\n总结来说，JSON 是一种简单、灵活且广泛使用的数据格式，遵循上述规则可以确保数据的正确性和可读性。\n\n上面这部分是直接从网上找到的相关规范。仔细考虑以下，该怎们做？\n尝试解析我随便贴一段json,让我们来分析以下我们可能要处理的情况\n&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;traveling&quot;],  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;123 Main St&quot;,    &quot;city&quot;: &quot;New York&quot;  &#125;&#125;\n\n我们可能遇到的情况包括：\n\n遇到&#123;，表示一层解析的开始，如果在本层解析过程中遇到了新的&#123;，则进入新的解析层，换句话说，我们需要一个递归结构来处理问题\n遇到&#125;，表示当前层的解析结束\n遇到“，表示某个key或者value,可以考虑通过识别：来辨别这是一个key还是value,\n遇到[,表示数组的开始\n遇到,,表示键值对之间的分割\n遇到/，转义字符，后面的一个字符需要转义，\n\n仔细思考上面的信息，我们可以大概的写出一个可用的demo（建议先自己尝试一下，还是有一点难度的）\npackage Winter.Parser.JsonPaser;import java.util.*;public class JsonParser &#123;    String json;    int index;    private JsonParser(String json) &#123;        this.json = json;        this.index = 0;    &#125;    public void skipWhiteSpace() &#123;        while (Character.isWhitespace(json.charAt(index))) &#123;            index++;        &#125;    &#125;//跳过空格的方法    public void expectString(String target) &#123;        int start = index;        for (int i = 0; i &lt; target.length(); i++) &#123;if (target.charAt(i) != json.charAt(start)) &#123;                throw new RuntimeException(&quot;Expecting string at index &quot; + index + &quot; but found &quot; + target.charAt(i));            &#125;            start++;        &#125;//用于检测程序是否是按照我们期望的方式进行    &#125;    public Object parseValue() &#123;        skipWhiteSpace();        char ch = json.charAt(index);        return switch (ch) &#123;            case &#x27;&#123;&#x27; -&gt; parseObject();//通过首个字符类型判断解析方法            case &#x27;[&#x27; -&gt; parseArray();            case &#x27;&quot;&#x27; -&gt; parseString();            case &#x27;t&#x27; -&gt; parseTrue();            case &#x27;f&#x27; -&gt; parseFalse();            case &#x27;n&#x27; -&gt; parseNull();            default -&gt; &#123;                if (ch == &#x27;-&#x27; || Character.isDigit(ch)) &#123;                    yield parseNumber();                &#125;//处理判断数字的情况                throw new RuntimeException(&quot;Unexpected character at position &quot; + index + &quot;: &quot; + ch);            &#125;        &#125;;    &#125;    private Object parseObject() &#123;        Map&lt;String, Object&gt; jsonNodeMap = new LinkedHashMap&lt;&gt;();        expectString(&quot;&#123;&quot;);        index++;        skipWhiteSpace();        if(json.charAt(index)==&#x27;&#125;&#x27;)&#123;            index++;            return jsonNodeMap;        &#125;        while (true)&#123;            skipWhiteSpace();            String key = parseString();//由于key一定是字符串，直接用字符串的方式解析            skipWhiteSpace();            expectString(&quot;:&quot;);            index++;//跳过冒号            Object value = parseValue();//获取value            jsonNodeMap.put(key,value);            if(json.charAt(index)==&#x27;&#125;&#x27;)&#123;break;&#125;            if(json.charAt(index) !=&#x27;,&#x27;)&#123;                throw new RuntimeException(&quot;Unexpected character &#x27;&quot; + json.charAt(index) + &quot;&#x27; at index &quot; + index);            &#125;            index++;//用于跳过键值对之间的逗号        &#125;        return jsonNodeMap;    &#125;    private String parseString() &#123;        StringBuilder stringBuilder = new StringBuilder();        expectString(&quot;\\&quot;&quot;);        index++;//跳过引号        skipWhiteSpace();        while (json.charAt(index) != &#x27;&quot;&#x27;) &#123;//处理可能的转义字符            if (json.charAt(index) == &#x27;\\\\&#x27;) &#123;                index++;//跳过用于转义的\\                char c = json.charAt(index);                switch (c) &#123;                    case &#x27;t&#x27; -&gt; stringBuilder.append(&quot;\\t&quot;);                    case &#x27;f&#x27; -&gt; stringBuilder.append(&quot;\\f&quot;);                    case &#x27;n&#x27; -&gt; stringBuilder.append(&quot;\\n&quot;);                    case &#x27;b&#x27; -&gt; stringBuilder.append(&quot;\\b&quot;);                    case &#x27;r&#x27; -&gt; stringBuilder.append(&quot;\\r&quot;);                    case &#x27;&quot;&#x27; -&gt; stringBuilder.append(&quot;\\&quot;&quot;);                    case &#x27;/&#x27; -&gt; stringBuilder.append(&quot;/&quot;);                    case &#x27;\\\\&#x27; -&gt; stringBuilder.append(&quot;\\\\&quot;);                    case &#x27;u&#x27; -&gt; &#123;//处理特殊的unicode转义                        if (index + 4 &gt;= json.length()) &#123;                            throw new RuntimeException(&quot;Unexpected unicode sequence at index &quot; + index);                        &#125;                        stringBuilder.append((char) Integer.parseInt(json.substring(index+1, index + 4), 16));                        index += 4;                    &#125;                    default -&gt; throw new RuntimeException(&quot;Unexpected character &#x27;&quot; + c + &quot;&#x27; at index &quot; + index);                &#125;                index++;//跳过被转义的字符            &#125; else &#123;                stringBuilder.append(json.charAt(index));                index++;            &#125;        &#125;        index++;//跳过字符串末尾的引号        return stringBuilder.toString();    &#125;    private Number parseNumber() &#123;        skipWhiteSpace();        int start = index;        if(json.charAt(index)==&#x27;-&#x27;)&#123;            index++;        &#125;        while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index))) &#123;index++;&#125;        if(json.charAt(index)==&#x27;.&#x27;)&#123;//处理浮点数            do &#123;                index++;            &#125; while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index)));        &#125;        if(json.charAt(index)==&#x27;e&#x27; || json.charAt(index)==&#x27;E&#x27;)&#123;//处理科学计数法            do &#123;                index++;            &#125; while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index)));        &#125;        String number = json.substring(start,index);//返回解析得到的数字        if(number.contains(&quot;e&quot;) || number.contains(&quot;E&quot;) || number.contains(&quot;.&quot;))&#123;            return Double.parseDouble(number);        &#125;else &#123;            try &#123;            return Integer.parseInt(number);            &#125;catch (NumberFormatException e)&#123;                return Long.parseLong(number);            &#125;        &#125;    &#125;    public List&lt;Object&gt; parseArray() &#123;        skipWhiteSpace();        List&lt;Object&gt; list = new ArrayList&lt;&gt;();        expectString(&quot;[&quot;);        index++;        skipWhiteSpace();        while (json.charAt(index) != &#x27;]&#x27;) &#123;            skipWhiteSpace();            list.add(parseValue());            if(json.charAt(index)!=&#x27;]&#x27;)&#123;index++;&#125;//用于跳过数组元素之间的逗号        &#125;        index++;//跳过]        return list;    &#125;    private boolean parseFalse() &#123;        expectString(&quot;false&quot;);        index+=5;        return false;    &#125;    private boolean parseTrue()&#123;        expectString(&quot;true&quot;);        index+=4;        return true;    &#125;    private Object parseNull() &#123;        expectString(&quot;null&quot;);        index+=4;        return null;    &#125;    public static void main(String[] args) &#123;        String json = &quot;&#123;\\&quot;greeting\\&quot;:\\&quot;你好，世界！\\&quot;,\\&quot;farewell\\&quot;:\\&quot;再见，朋友！\\&quot;&#125;&quot;;        JsonParser parser = new JsonParser(json);        Object value = parser.parseValue();        System.out.println(value);    &#125;&#125;\n\n感觉如何？如果能够理清所有的逻辑，自己独立写一个还是比较简单的，毕竟也就不到200行的代码量。当然，这个解析器从效率上来将肯定没有办法和一些主流的库比，但不管怎么说，这玩意能用了。\n建议去找ai写几个测试用例试一试（要求不要进行格式化），这个解析器其实只考虑了一些基本情况，你可以试着补足\n查询支持在完成解析后，我们肯定要做一下查询的支持，这样才能方便我们下一步与框架的继承，其实有上面的基础，这一步非常简单，基本的思路如下\npublic class JSON &#123;    private final Map&lt;String,Object&gt; jsonMap;    public JSON(String json) &#123;        JsonParser jp = new JsonParser(json);        Object ret = jp.parseValue();        if(!(ret instanceof Map))&#123;            throw new RuntimeException(&quot;JSON parsing failed&quot;);        &#125;        this.jsonMap = (Map&lt;String, Object&gt;) ret;    &#125;    // 新增查询方法    public List&lt;Object&gt; query(String path) &#123;        List&lt;Object&gt; result = new ArrayList&lt;&gt;();        String[] keys = path.split(&quot;\\\\.&quot;);        queryRecursive(jsonMap, keys, 0, result);        return result;    &#125;//查询方法//用于递归查询    private void queryRecursive(Object value, String[] keys, int depth, List&lt;Object&gt; result) &#123;        if (depth &gt;= keys.length) &#123;//如果递归深度达到了数组长度，停止递归，将结果保存到list中            result.add(value);            return;        &#125;        String key = keys[depth];        if (value instanceof Map) &#123;//如果是一堆嵌套的map,反复的递归直到指定层数            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) value;            if (map.containsKey(key)) &#123;                queryRecursive(map.get(key), keys, depth + 1, result);            &#125;        &#125; else if (value instanceof List) &#123;            List&lt;Object&gt; list = (List&lt;Object&gt;) value;//如果发现数组类型，遍历数组类型的所有元素            for (Object item : list) &#123;//用于处理数组类型                queryRecursive(item, keys, depth, result);            &#125;        &#125;    &#125;   &#125;\n\n怎么样，写起来也不是非常困难，反正就是不断递归查找。\n当然，这个方法也存在问题，首先，返回的是一个list,使用的时候还要做各种类型转换与遍历。但不管怎么说，这玩意能用了，这就是好事。\n结语今天就到这里了，嘴上说简单，但还是写的头疼，是在写不动了，先就此打住吧，下一期实现一个线程池，再下一期写一个请求转发器，最后再补充一些事务方面的东西，支持一下数据库交互，这套框架就差不多将就这能用了\n\n","tags":["手写Spring"]},{"title":"Java的反射与代理","url":"/2025/04/04/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E4%B8%8E%E4%BB%A3%E7%90%86/","content":"最近比较闲，所以来整点活，让我们从0到1手写一个Spring框架吧（只使用Java SE部分的相关内容，不使用任何依赖），不过在正式开始之前，我们要去了解一些基础知识（如果你确信了解了这些知识，可以直接跳过）。\n我们今天来讲一讲反射与代理相关的知识。\n首先我们从Java的类加载机制讲起\nJava的类加载机制我们都知道对于Java来说万物皆对象，所以你猜猜类是什么？类当然是对象了，所有的类在JVM中都被视为一种特殊的对象：Class对象。我们先反编译出来看一看，下面是这个类的头部\npublic final class Class&lt;T&gt; implements Serializable, GenericDeclaration, Type, AnnotatedElement, TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;, Constable\n\n类的加载流程大致如下\n\nJVM读取.class文件并将字节码转化为二进制数据，依照二进制数据创建一个上面提到的java.lang.Class对象来表示某个特定的类\n进行验证，确保所有的Class对象符合规范，不会危害JVM安全\n开始为对应的静态属性分配内存并设置默认的初始值\n进行解析，为所有的属性，方法添加对应的引用映射，如将类名指向Class对象\n执行类加载操作，调用对应的类加载器进行类的加载\n\n我们可以在Class类中发现Class类的构造方法\nprivate Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) &#123;    this.classLoader = loader;    this.componentType = arrayComponentType;&#125;\n\n其中的ClassLoader就是我们所说的类加载器\nJava 的类加载器采用层次结构，主要包括以下几种：\n\n启动类加载器（Bootstrap ClassLoader）：\n负责加载 Java 核心类库（如 rt.jar 中的类）。\n它是虚拟机的一部分，通常由 C++ 实现，不是 Java 代码。\n没有父类加载器。\n\n\n扩展类加载器（Extension ClassLoader）：\n负责加载 Java 的扩展类库（如 jre/lib/ext 目录下的 JAR 文件）。\n它是 sun.misc.Launcher$ExtClassLoader 的实例，父类加载器是启动类加载器。\n\n\n应用程序类加载器（Application ClassLoader）：\n也称为系统类加载器，负责加载用户类路径（CLASSPATH）指定的类。\n它是 sun.misc.Launcher$AppClassLoader 的实例，父类加载器是扩展类加载器。\n\n\n自定义类加载器：\n用户可以通过继承 java.lang.ClassLoader 类来实现自定义类加载器。\n用于加载特定路径或来源的类。\n\n\n\n我们先来看一看这个默认的类加载器在干什么吧，由于私有方法太多，我这里只贴一些比较关键的内容，首先是一个最为重要的类加载方法\npublic Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    return this.loadClass(name, false);&#125;protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;    synchronized(this.getClassLoadingLock(name)) &#123;        Class&lt;?&gt; c = this.findLoadedClass(name);//这个方法会调用一个通过C++实现方法检测类是否已经被加载        if (c == null) &#123;//如果没有加载则开始加载            long t0 = System.nanoTime();//此处为获取JVM运行时间            try &#123;                if (this.parent != null) &#123;                    c = this.parent.loadClass(name, false);//如果该加载器存在父类则调用父加载器进行加载                &#125; else &#123;                    c = findBootstrapClassOrNull(name);//如果不存在则进行加载 ，这个方法同样是C++实现的                &#125;            &#125; catch (ClassNotFoundException var10) &#123;//如果父加载器加载失败则捕获异常并继续运行            &#125;            if (c == null) &#123;                long t1 = System.nanoTime();                c = this.findClass(name);//这个方法现在实际上是一个空方法，交给子类实现，默认运行到此处时会直接抛异常                PerfCounter.getParentDelegationTime().addTime(t1 - t0);//这些都是用于记录类加载时间的，用于性能优化                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            this.resolveClass(c);//这里是永远不会对外界开放的，不必关心        &#125;        return c;    &#125;&#125;\n\n你会发现这样一个逻辑：一般情况下，总是优先调用父加载器进行加载，这种加载机制被称之为双亲委派机制，原生的所有类加载器都会尽可能的将类加载任务委派给自己的父类的实例，这样做的根本目的是避免一个类被重复加载。\n还有一个比较关键的类加载器方法\nprotected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError     protectionDomain = this.preDefineClass(name, protectionDomain);    String source = this.defineClassSourceLocation(protectionDomain);    Class&lt;?&gt; c = defineClass1(this, name, b, off, len, protectionDomain, source);    this.postDefineClass(c, protectionDomain);    return c;&#125;\n\n这个方法用来将二进制数据转换为类对象，不过很遗憾，这个方法也是C++实现的\n那么这个类加载器在哪里被调用呢，可以简单的认为当某个类第一次被需要时，JVM会尝试调用类加载器来完成加载，这一部分我们在讲解反射部分时会具体的展示。\n我们最后再梳理以下JAVA的类加载机制：当某个类被需要时，JVM将通过类加载器直接加载这个类，这一过程遵循双亲委派机制，加载的结果是一个Class对象\n反射操作接下来我们解释什么是反射。这是我们一般情况下获取对象的方法\nTest test =new Test()\n\n不管怎么改，无论是什么建造者模式，工厂模式等等各种花活，都逃不出在某处new一个对象出来，但是你注意到这样一个问题了吗？Spring的依赖注入是如何实现的，框架的编写者是无法事先得知对象的名称的，又如何获取对象用来注入呢？正是通过反射\n举一个简单的例子，我可以通过这样的方式来构建一个字符串对象\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            String aString =(String) String.class.getConstructor().newInstance();            String bString = (String) Class.forName(&quot;java.lang.String&quot;).getConstructor().newInstance();        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n你看，我全程绝对没有new,哪怕你顺着源码查下去也绝对找不到任何new,这就是创建对象的另一种方式：反射。你或许想不到这有什么用，但是不要着急，我们先来了解以下关于反射的各种使用\n构建对象在知道对象名称时我们可以这样来实现\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Constructor&lt;?&gt; stringConstructor = stringClass.getConstructor();//获得类的构造器        Object string = stringConstructor.newInstance();//使用构造器来完成构造    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n上面的是JDK9之后的写法，如果你使用JDK8,甚至可以直接\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Object string = stringClass.newInstance();    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n我们上面还提到了\nClass&lt;?&gt; intClass =int.class;\n\n这样的方法来获取类对象， class属性是直接来自于Object对象的，所有对象都天然的拥有这个属性。\n当然，对于一个对象，你也可以通过\nString s=&quot;Hello World&quot;;Class&lt;?&gt; c =s.getClass();\n\n这样的方式来获取class对象，在获取类对象后你可以按照上面的流程来获取对象。\n请注意\n\n所有的基本数据类型，基本数据类型的数组类型，基本数据类型的包装类型都拥有独立且唯一的Class对象\n类本身和对应的数组类型是拥有独立的Class对象\n所有的类永远只拥有一个类对象（这一点在必要时是可以被手动打破的）\n\n值得一提的是在利用类对象获取构造器时我们可以主动的选择构造方法，例如对于这个类\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;&#125;\n\n我们可以做一个这样的测试\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);            Constructor&lt;?&gt; constructor1 = clazz.getConstructor();//获取无参构造            Constructor&lt;?&gt; constructor2 = clazz.getConstructor(String.class,int.class);//获取全参构造            Student student1 = (Student) constructor1.newInstance();            Student student2 = (Student) constructor2.newInstance(&quot;aaa&quot;,111);            System.out.println(student1.test());            System.out.println(student2.test());        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n获取对象信息我们可以通过反射来获取一些类的信息\nClass&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);System.out.println(clazz.getSuperclass().getName());//获取父类for(Class&lt;?&gt; c: clazz.getInterfaces())&#123;    System.out.println(clazz.getName());//获取接口&#125;for (Annotation annotation: clazz.getAnnotations())&#123;    System.out.println(annotation.annotationType().getName());&#125;//获取注解\n\n此外，反射还能允许我们做一些比较疯狂的事情，比如访问私有字段，还是上面的Student类，age字段显然是私有的，且不存在任何方法进行访问，真的吗\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Field field = student.getClass().getDeclaredField(&quot;age&quot;);//获取字段            field.setAccessible(true);//强制运行字段访问            System.out.println(field.get(student));//输出0            field.setInt(student, 11);//修改字段值            System.out.println(field.get(student));//输出11        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n实际上哪怕是final字段。只要愿意也是可以修改的(不过JDK9之后禁止了，但仍然可以通过一些方式开启)\n这也意味这个一个问题：Java的一个核心理念：封装被突破了。你不让我访问？这是你能挡得住的？我不但能访问，我还能修改。所以实际上所有的封装实际上来自于程序员之间的君子约定：我们互相约定好这部分只在规定范围内访问，当然如果你非要访问，也没什么办法。\n调用方法我们甚至都已经访问了属性了，怎么能做不到调用方法呢？为了方便解释我们先改一改Student方法\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;    public String test(String s)&#123;        return s+name;    &#125;&#125;\n\n然后直接上\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Method method = student.getClass().getMethod(&quot;test&quot;,String.class);//通过名称与参数类型来获取方法            System.out.println(method.invoke(student,&quot;1&quot;));        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n由于编译时形参无法被保留，我们无法直接通过名称获得\n特别的，如果参数类型为可变参数，可选择\nMethod method = clazz.getDeclaredMethod(&quot;test&quot;, String[].class);\n\n不过对于私有方法，就像final字段一样，默认情况下无法被直接使用，需要在启动时添加\n--add-opens java.base/java.lang=ALL-UNNAMED\n\n来允许所有反射\n实现一个简单的IoC容器有了上面的基础，我们已经可以实现一个简单的Bean管理器了。我们先回忆以下Spring中Bean管理器拥有哪些功能：\n\n扫面并创建所有的Bean\n完成依赖注入\n支持在任何地方提供Bean\n\n我们逐个来完成这些需求，为了方便，我们这里只提供注解形式的注册Bean的方法，先写一个注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Componenet &#123;&#125;\n\n还要写一个用于自动绑定的注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface AutoWired &#123;&#125;\n\n我们尝试搭建一个大概的框架\npublic class MyIocContainer &#123;    private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;();    private List&lt;String&gt; basePackageList =new ArrayList&lt;&gt;();    private final ClassPathLoader classPathLoader = new ClassPathLoader();    public void addBasePackage(String basePackage) &#123;        this.basePackageList.add(basePackage);    &#125;//用于规定扫描路径    public void scanPackage(Class&lt;?&gt; clazz) &#123;//此处模仿Spring,填入Main.class来确定运行位置        if(basePackageList.isEmpty()) &#123;            basePackageList.add(clazz.getPackage().getName());        &#125;        for (String basePackage : basePackageList) &#123;//遍历所有路径加载Bean            try &#123;                loadBean(beanMap, basePackage);            &#125; catch (Exception e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        autoWiring();    &#125;    public Object getBean(String className) &#123;        return beanMap.get(className);    &#125;    private void autoWiring()&#123;        for (Map.Entry&lt;String, Object&gt; entry : beanMap.entrySet()) &#123;            for (Field field : entry.getValue().getClass().getDeclaredFields()) &#123;//遍历所有的Bean完成依赖注入                field.setAccessible(true);                if(!field.isAnnotationPresent(AutoWired.class))&#123;                    continue;                &#125;                if(beanMap.containsKey(field.getType().getName()))&#123;                    try &#123;                        field.set(entry.getValue(),beanMap.get(field.getType().getName()));                    &#125; catch (IllegalAccessException e) &#123;                        throw new RuntimeException(e);                    &#125;                &#125;else &#123;                    throw new RuntimeException(&quot;只能自动绑定已注册的Bean&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n接下来完成加载Bean的方法\nprivate void loadBean(Map&lt;String,Object&gt; beanMap, String packageName) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    URL dir = classLoader.getResource(packageName);//这部分文件的获取实际上使用类路径，这个概念我们下一篇再来研究    packageName = packageName.replace(&#x27;/&#x27;, &#x27;.&#x27;);    if (dir == null) &#123;        return;    &#125;//如果投入的路径不存在，直接返回    File dirFile = new File(dir.getFile());    if (!dirFile.exists() || !dirFile.isDirectory()) &#123;        return;    &#125;//对应的类路径不存在或者不是目录，直接返回    File[] files = dirFile.listFiles();    if (files != null) &#123;        for (File file : files) &#123;            if (file.isDirectory()) &#123;                loadBean(beanMap, packageName.replace(&quot;.&quot;,&quot;/&quot;) + &quot;/&quot; + file.getName());                continue;            &#125;            String className = packageName + &quot;.&quot; + file.getName().replace(&quot;.class&quot;, &quot;&quot;);            Class&lt;?&gt; clazz = classLoader.loadClass(className);            if(clazz.isInterface() || clazz.isAnnotation() || clazz.isEnum() || Modifier.isAbstract(clazz.getModifiers())) &#123;                continue;            &#125;//接口，抽象类和注解都不能使用构造方法构造，直接跳过避免报错            if(clazz.isAnnotationPresent(Componenet.class)) &#123;                Constructor&lt;?&gt; constructor =clazz.getConstructor();                constructor.setAccessible(true);                beanMap.put(className,constructor.newInstance());            &#125;//加载类        &#125;    &#125;&#125;\n\n虽然非常的简陋，但是这个IoC容器在功能上已经和Spring的IoC容器一致了，我们的全部实现只有不到100行代码。不过，这个容器仍然存在很多问题，举个简单的例子，如果有些类中包含一些static属性，这些属性对应的类在加载当前类时并没有被正确的加载，那么报错是必然的，想一想该怎么处理这个问题。此外，如果类足够多，我们是不是需要添加对应的多线程支持，这个类显然没有考虑多线程的情况，该怎么解决？这些问题我先留在，我们将来再解决。\n动态代理是什么所谓的动态代理就是通过反射获取类的相关方法，在执行时代替这个类去执行对应的方法，在这一过程中可以对方法进行一定的修饰\n所以这有什么用？仔细想想，Mybatis是怎么实现的？不就是通过对接口方法的代理吗？Spring的AOP或者说面向切面怎么实现的，不也是通过对类的代理吗？\n如果你想的话可以直接自己手搓一个动态代理机制出来，不过Java毕竟原生提供了动态代理的实现，我们还是直接调用吧，其中的关键是两个类\n\njava.lang.reflect.Proxy：代理类，用于动态创建代理对象。\njava.lang.reflect.InvocationHandler：调用句柄接口，用于处理代理对象的方法调用。\n\n我们写一个简单的例子，这是一个接口\npublic interface Service &#123;    void doSomething();    String test();&#125;\n\n接着完成这个接口的实现\npublic class ServiceImpl implements Service &#123;    public void doSomething() &#123;        System.out.println(&quot;doSomething&quot;);    &#125;    public String test() &#123;        return &quot;test&quot;;    &#125;&#125;\n\n接下来我们完成一个代理类\npublic class MyProxy implements InvocationHandler &#123;    private final Object target;    public MyProxy(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;        System.out.println(&quot;执行前操作&quot;);        Object result = method.invoke(target, objects);        System.out.println(&quot;执行后操作&quot;);        return result;    &#125;    public static Object getProxyInstance(Object target) &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(),//获得类加载器                target.getClass().getInterfaces(),//获得所实现的接口                new MyProxy(target));//提供一个调用句柄    &#125;&#125;\n\n你会发现这个代理类是通用的，接下来我们尝试使用以下代理类\npublic class Main &#123;    public static void main(String[] args) &#123;        Service service1 = new ServiceImpl();        Service service2 = (Service) MyProxy.getProxyInstance(service1);        service1.doSomething();        service2.doSomething();        System.out.println(service1.test());        System.out.println(service2.test());        System.out.println(service1.hashCode());        System.out.println(service2.hashCode());        System.out.println(service1.getClass().getName());        System.out.println(service2.getClass().getName());    &#125;&#125;\n\n运行结果如下\n执行前操作doSomething执行后操作test执行前操作执行后操作test2084435065执行前操作执行后操作2084435065abc.proxy.ServiceImpljdk.proxy1.$Proxy0\n\n在我不解释的情况下你是否能理解为什么会出现这样的输出结果呢，我们分段来看\n首先是前四行输出，无代理的对象直接输出，有代理的对象按照我们所规定的操作顺序来处理\n接着看5到8行，执行顺序变了吗？并没有，只不过在受到代理的对象中，调用任何一个方法本质上都是通过我们重写的invoke方法来实现的，控制台输出在Invoke方法执行完毕后才得到了要输出的结果\n再来看一看这个8到11行，不是说会产生新的代理类吗，那么为什么哈希是相同的，有点诡异。\n再看一看12和13行，类名不一样，是符合我们预期的，不过还有一个问题，这次从结果上看居然没有被代理？这是什么情况？原因实际上非常简单，如果粗暴的将所有的方法代理，那么区分代理类与原来的类就成了一件麻烦的事情，所以这个方法并没有被代理。\n实现一个简单的AOP框架我们可以使用动态代理来实现一个简单的AOP框架，不过很遗憾我们现有的知识是不足以让我们完整的实现Spring的AOP能力的，JDK的动态代理只做到了类一级，不能精细的对方法进行控制，这种能力需要对特定的字节码进行操作，所以我们还是暂时不讲了。\n不过简单的类级别的AOP框架还是很容易实现的，我们试着写一个吧，为了方便，我们这里只考虑三种情况：执行前，执行后，抛出异常时。我们将这三种情况规范为对应的接口\npublic interface BeforeExecution &#123;    void before(Object[] objects) throws Throwable;&#125;public interface BeforeExecution &#123;    void before(Object[] objects) throws Throwable;&#125;public interface ThrowException &#123;    void throwException(Object[] objects，Throwable throwable) throws Throwable;&#125;//这里的objects实际上是方法的参数，使用者可以利用这些参数\n\n然后考虑创建对应的代理类，我随便写一个可能的例子\npublic class ProxyFactory  &#123;    private static final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    private static AfterExecution afterExecution = null;    private static ThrowException throwException = null;    private static BeforeExecution beforeExecution = null;    private static boolean isClean=true;    public static void setAfterExecution(AfterExecution afterExecution) &#123;        ProxyFactory.afterExecution = afterExecution;    &#125;    public static void setThrowException(ThrowException throwException) &#123;        ProxyFactory.throwException = throwException;    &#125;    public static void setBeforeExecution(BeforeExecution beforeExecution) &#123;        ProxyFactory.beforeExecution = beforeExecution;    &#125;    private static Object getProxy0(Object target,InvocationHandler invocationHandler) throws Throwable &#123;        return Proxy.newProxyInstance(classLoader, target.getClass().getInterfaces(), invocationHandler);    &#125;    public static Object getProxy(Object target) throws Throwable &#123;        if(!isClean) &#123;            throw new RuntimeException(&quot;使用后未复位&quot;);        &#125;else&#123;            isClean=false;        &#125;        //这里其实采用的是装饰模式的思想，不断的对原来的类进行装饰最终得到我们想要的对象        if (beforeExecution != null) &#123;            target = getProxy0(target, (o, method, objects) -&gt; &#123;                beforeExecution.before(objects);                return method.invoke(o, objects);            &#125;);        &#125;        if (afterExecution != null) &#123;            target =getProxy0(target,(o,method,objects)-&gt;&#123;                Object result = method.invoke(o, objects);                afterExecution.afterExecution(objects);                return result;            &#125;);        &#125;        if (throwException != null) &#123;            target =getProxy0(target,(o,method,objects)-&gt;&#123;                Object result = null;                try &#123;                    result = method.invoke(o, objects);                &#125;catch (Throwable throwable) &#123;                    throwException.throwException(objects ,throwable);                &#125;                return result;            &#125;);        &#125;        return target;    &#125;    public static void clean() &#123;//这是一个复位方法，避免产生不必要的代理        isClean=true;        afterExecution=null;        throwException=null;        beforeExecution=null;    &#125;&#125;\n\n结语这部分的知识就讲到这里，我们下一篇将会探讨关于文件处理相关的问题，顺路继续优化我们的IoC容器\n\n","tags":["手写Spring"]},{"title":"多线程与线程池","url":"/2025/04/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"今天我们来稍微了解一下线程与线程池的相关知识\n多线程的基本操作我们首先从最基本的Thread类讲起。我们知道多线程的基本使用方法大概如下\npublic class Main &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;Hello World&quot;);        &#125;);        thread.start();    &#125;&#125;\n\n每一个Thread对象都是一个单独的线程，当调用这个对象的start方法时这个线程就会被启动。我们可以看看Thread类的构造方法\npublic Thread(Runnable task) &#123;        this((ThreadGroup)null, (String)null, 0, task, 0L, (AccessControlContext)null);    &#125;\n\nemm具体的构造方法到底是怎么实现的暂时先不用管，我们这里只是用来明确我们刚才那个lambda表达式实际上是一个Runnable接口的实现，所以理所当然的，我们可以这样去实现多线程\npublic class Test implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;Hello World&quot;);    &#125;&#125;\n\n然后把这这个类的对象直接丢到线程类的构造方法中。或者你也可以选择继承Thread类，此时可以选择重写Thread类的run方法，然后直接调用子类的start方法。通过这样的方法可以给线程中运行的程序添加一些需要使用的参数\n但这种操作存在一个问题，run方法是void的，所以在某些情况下我们如果需要返回值，可以使用回调类Callable来实现\nimport java.util.concurrent.Callable;class MyCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        int sum = 0;        for (int i = 0; i &lt; 100; i++) &#123;            sum += i;        &#125;        return sum;    &#125;&#125;\n\n先随便定义一个回调类然后通过ExecutorService（实际上就是一个线程池）来运行\nimport java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class Test &#123;    public static void main(String[] args) &#123;        ExecutorService executor = Executors.newFixedThreadPool(2);//新建线程池        MyCallable callable = new MyCallable();        Future&lt;Integer&gt; future1 = executor.submit(callable);        Future&lt;Integer&gt; future2 = executor.submit(callable);        //这里稍微解释一下Future类，当我们使用Future去保存异步方法的返回值时及时运算还没有完成程序也会继续向下运行，直到调用get方法获取值时如果没有运算完成才会造成阻塞        try &#123;            System.out.println(&quot;线程 1 的结果：&quot; + future1.get());            System.out.println(&quot;线程 2 的结果：&quot; + future2.get());        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125; finally &#123;            executor.shutdown();        &#125;    &#125;&#125;\n\n如果你有一定的基础，上面的这些内容对你来说一定是非常简单的，下面我们来聊聊睡眠与锁的问题\n首先来看一个相当经典的例子\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        thread.start();        thread2.start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n此时a的值有很大的可能不是20000，为什么？两个线程分别加了10000次，为什么不是两千呢。非常简单，我们想象一下这个相加的过程：a被保存在内存中，线程1会首先从内存中读取这个值，然后放到累加器中进行累加，再将得到的值写回内存。但是这个过程存在一个问题：线程2也在做同样的事情，如果在线程1读取之后写回之前线程2进行读取，那么必然会导致最终的运算结果小于2000.所以这个问题该怎么解决？\n有一个相当愚蠢的做法是直接睡眠\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        thread.start();        thread2.start();        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n一个干完另一个继续干，这样就不会冲突了。但这样只能保证10000时不出问题，那么如果是一亿呢，睡1秒时间不够呢，如果是10呢，睡一秒又太过奢侈，所以我们这里又创造了更细致的控制方法，首先是interrupt方法\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            while (true)&#123;                if(Thread.currentThread().isInterrupted())&#123;                    break;                &#125;            &#125;//在没有收到中断信号之前始终处于死循环状态            Thread.interrupted();//将终端标记复位            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;            thread.interrupt();//向线程1发送中断信号        &#125;);        thread2.start();        thread.start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n我们可以看到通过这种方式可以灵活的控制一个线程的睡眠时间，确保结果正确\n当然，其实java在这方面的控制方法还是相当丰富的，我们随便写几个\nThread.currentThread().suspend();//在本线程内调度，直接暂停某个线程t.resume();//恢复t的运行\n\n你可以试着使用这两个方法对上面的代码进行修改，这两个方法相较interrrupt方法的优越性在与线程的暂停本质上是使当前线程处于阻塞状态，此时当前线程不会占用CPU资源，而上面的循环却会无意义的占用CPU资源。\n再看一看这个方法\npublic static void main(String[] args) &#123;    Thread t1 = new Thread(() -&gt; &#123;        System.out.println(&quot;线程1开始运行！&quot;);        for (int i = 0; i &lt; 50; i++) &#123;            System.out.println(&quot;1打印：&quot;+i);        &#125;        System.out.println(&quot;线程1结束！&quot;);    &#125;);    Thread t2 = new Thread(() -&gt; &#123;        System.out.println(&quot;线程2开始运行！&quot;);        for (int i = 0; i &lt; 50; i++) &#123;            System.out.println(&quot;2打印：&quot;+i);            if(i == 10)&#123;                try &#123;                    System.out.println(&quot;线程1加入到此线程！&quot;);                    t1.join();    //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;);    t1.start();    t2.start();&#125;\n\n这里使用到了join方法，join方法其实可以认为是刚才上面的三个方法的结合，首先将t2阻塞，然后等待t1运行完成后t2收到信号恢复运行。\n接下来继续想办法改进这一段代码，我们需要引入锁的概念，我们之前提到了之所以在多线程状态下会出现问题是因为不同哦ing线程在竞争同一个资源，所以我们之前的解决方法是优先使某个线程使用该资源，在一个线程使用完成后再让其他线程使用。但是一个线程中真正使用资源的时间只占一部分，那么我们能不能想办法把这部分资源节约出来呢？我们就需要使用synchronized关键字\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            synchronized (Test.class) &#123;                for (int i = 1; i &lt;= 10000; i++) &#123;                    a++;                &#125;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            synchronized (Test.class) &#123;                for (int i = 1; i &lt;= 10000; i++) &#123;                    a++;                &#125;            &#125;        &#125;);        thread2.start();        thread.start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n所有的synchronized内的代码只能有一个线程执行，其余线程处于阻塞状态（其实你可以试着不用这个关键字而使用上面提到的方法来实现差不多的效果）\nsynchronized 关键自后括号内的是被加锁的对象，我们称这种锁为对象锁，该对象的锁只能被一个线程持有，只有持有锁的线程才能执行被加锁的代码。（这里使用的是Test类的Class对象），但不同的对象锁之间相互无影响\n当然，我们也有更灵活的写法，\nprivate static synchronized void add()&#123;    value++;&#125;\n\n这种写法被成为方法锁，只能有一个线程调用该方法。当然，这种写法实质上和对象锁是同一种东西，如果是静态方法，加锁对象为类的Class对象，如果是动态方法，加锁对象为方法所在对象。\n使用锁可以极大的发挥多线程优势，当然，要注意下面这种情况\npublic static void main(String[] args) throws InterruptedException &#123;    Object o1 = new Object();    Object o2 = new Object();    Thread t1 = new Thread(() -&gt; &#123;        synchronized (o1)&#123;//t1先启动，开始持有o1锁            try &#123;                Thread.sleep(1000);                synchronized (o2)&#123;//在持有o1锁的同时需要使用o2锁，等待o2锁，当前线程阻塞                    System.out.println(&quot;线程1&quot;);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    Thread t2 = new Thread(() -&gt; &#123;        synchronized (o2)&#123;//线程2持有o2锁            try &#123;                Thread.sleep(1000);                synchronized (o1)&#123;//等待o1锁，线程阻塞                    System.out.println(&quot;线程2&quot;);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    t1.start();    t2.start();&#125;\n\n此时两个线程均开始等待对方持有的锁，同时陷入阻塞，那么这两个线程都永远不会被唤醒，这种状态我们称之为死锁。\n另外，考虑到某些需求，我们需要在满足某些条件时主动的释放锁，交给其他线程，此时可以这样写\npublic static void main(String[] args) throws InterruptedException &#123;    Object o1 = new Object();    Thread t1 = new Thread(() -&gt; &#123;        synchronized (o1)&#123;            try &#123;                System.out.println(&quot;开始等待&quot;);                o1.wait();     //进入等待状态并释放锁                System.out.println(&quot;等待结束！&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    Thread t2 = new Thread(() -&gt; &#123;        synchronized (o1)&#123;            System.out.println(&quot;开始唤醒！&quot;);            o1.notify();     //唤醒处于等待状态的线程          \tfor (int i = 0; i &lt; 50; i++) &#123;               \tSystem.out.println(i);               &#125;          \t//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续        &#125;    &#125;);    t1.start();    Thread.sleep(1000);    t2.start();&#125;\n\n这种方法可以很好的控制锁的获取与释放。此外还有一个notifyall方法，这个方法可以直接唤醒所有处于等待的线程，而上面提到的notify只能唤醒随机的一个\n一些简单的进阶知识synchronized的实现机制首先回答我一个问题：锁机制的底层实现是怎样的？你可以猜一猜。\n在比较久远的时代，Java中的synchronized被成为重量级锁，实质上将获取锁与释放锁的操作映射为CPU实际线程的阻塞与唤醒，这一过程由操作系统负责调度。但是有一点令人不爽：实际的阻塞与唤醒操作是一种开销很大的操作，过于频繁的阻塞与唤醒会消耗大量资源，后来人们针对性的做出了一定的改进。\n改进的成果被称为自旋锁，什么是自旋锁？当线程需要获取锁时不再被阻塞，而是进入一个循环反复试图获取锁。等等，这难道不是越改经越回去了吗？但是仔细想想，在一个锁的所有权被频繁切换的场景下，这种操作是不是就可理解多了，最多不过是浪费几次循环的算力，相比阻塞与唤醒的操作，其消耗的资源少得多。但是在另一个方面，如果锁的切换不是那么频繁呢？那样就会消耗大量资源，所以经过改进的synchronized 实际上在初始状态下是一个自旋锁，在自旋时间超过一定的界限后就自动转换为一个重量级锁。\n但改进并没有停止，既然有重量级锁，那么必然有轻量级锁。轻量级锁是一种乐观锁，上面提到的两种锁都总是认为有其他的线程想要和自己抢夺资源，所以总是要自己实质上拥有锁，但乐观锁不这么认为，乐观锁如轻量级锁总是认为没有人和自己争抢锁，所以在运行时直接读内存并进行计算，但同时保存内存中的初始值，在运算完成后先将保存的初始值与当前内存中的值做比较，如果内存中的值与刚刚保存的值一致，说明这期间没有其他线程修改，直接将运算结果写回，如果发生了变化则说明有其他线程进行了修改，放弃此次操作，重头开始，如果这种机制多次失败，那么向上转化为自旋锁\n但优化还没有停止，人们又创造出了偏向锁。人们注意到，在某些情况下，一个对象很多时候都只被一个线程使用,所以直接在这个锁内部添加添加一条信息用于记录线程的id,如果id匹配，那么当前线程直接将这个对象当作无锁对象使用，直到有别的线程来尝试获取这个锁，此时偏向锁向轻量级锁升级。\n可以看到synchronized的机制实质上是一个逐渐升级的过程，从偏向锁开始逐渐的随着竞争的程度向上升级直到使用重量级锁。这个流程被称为锁粗化。\n内存可见性问题我们来看一看下面这段代码\npublic class Test &#123;      private static int a = 0;      public static void main(String[] args) throws InterruptedException &#123;          new Thread(() -&gt; &#123;              while (a == 0);              System.out.println(&quot;线程结束！&quot;);          &#125;).start();            Thread.sleep(1000);          System.out.println(&quot;正在修改a的值...&quot;);          a = 1;         &#125;  &#125;\n\n表面上看这段代码似乎不存在任何问题，但实际上这玩意会变成一个死循环，为什么呢？这里我们可以简单的介绍以下java的内存模型\njava的内存分为主内存和工作内存两个部分，所有的线程在实际的操作中会先从主内存读取值并存储到自己的工作内存中，然后进行使用，在更新值之后再将值写回主内存，其余时间一直在使用工作内存中的值。在上面的例子中，主线程更新了主内存中的值，但另一个线程实际上一直在循环使用工作线程中的值，并不知道主内存中的值已经被更新，导致出现死循环。\n这个问题到底该如何解决？最直接的办法就是加锁，当一个对象被加锁后每次调用时都会从工作内存刷新这个值,可以参考下面的这段代码，此时受到锁机制的影响，代码的循环是有限的\npublic class Main &#123;    private static int a = 0;    public static void main(String[] args) throws InterruptedException &#123;       new Thread(() -&gt; &#123;            while (a == 0) &#123;                synchronized (Main.class)&#123;&#125;            &#125;            System.out.println(&quot;线程结束！&quot;);        &#125;).start();        Thread.sleep(1000);        System.out.println(&quot;正在修改a的值...&quot;);        synchronized (Main.class)&#123;            a = 1;        &#125;    &#125;&#125;\n这里稍微解释一下，加锁的对象的Main的Class对象，Main类的静态属性正是包含在Class对象中的，此时对Class对象加锁，那么每次获得锁时都会从主内存内获取属性的实际值\n但是除了这种方法以外再没有别的办法了吗，还是有的，这里我们再介绍一个关键字volitale，我们可以重新修改之前的代码\npublic class Main &#123;    //添加volatile关键字    private static volatile int a = 0;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            while (a == 0) ;            System.out.println(&quot;线程结束！&quot;);        &#125;).start();        Thread.sleep(1000);        System.out.println(&quot;正在修改a的值...&quot;);        a = 1;    &#125;&#125;\n\n此时的代码也不会出现问题，这个关键字的功能在于两点\n\n保证不同线程之间数据的可见性\n阻止编译器的重排序，编译器在编译时可能对部分代码进行优化，其中一个比较重要的过程就是进行重排序调整代码的执行顺序，但是在多线程环境下这种重排序是可能出现问题的，所以对于跨线程调用的变量即使不加锁也至少应该使用这个关键字\n\n当然，还有一个小知识点，既然我们可以要求某个变量在多个线程内可见，那么也自然可以创造出仅在线程的工作内存内使用的属性，代码如下\npackage Winter;public class Main &#123;    public static void main(String[] args) &#123;        ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();        threadLocal.set(0);        Thread thread = new Thread(() -&gt; &#123;            threadLocal.set(1);            System.out.println(threadLocal.get());        &#125;);        thread.start();        System.out.println(threadLocal.get());            &#125;&#125;\nThreadLocal类中的值存储在每个线程的工作内存中，各自独立，互不干涉。可以被用来实现一些比较奇怪的需求，不过我个人似乎没怎么用过。\n现代锁框架接下来我们聊一聊现代锁框架。从java5开始，java的锁机制发生了一次重大更新，诞生了除了synchronized之外的另一套锁机制，这套锁机制更加的灵活，这里简单的介绍一下。\n现代锁框架主要涉及Lock类，Condition类以及几个原子类，我们首先可以看一看Lock类的接口\npublic interface Lock &#123;      void lock();//获取锁,如果拿不到锁会造成阻塞        void lockInterruptibly() throws InterruptedException;//获取锁且响应中断      boolean tryLock();  //尝试获取锁，但不会造成阻塞      boolean tryLock(long var1, TimeUnit var3) throws InterruptedException;//尝试获取锁，其中两个参数用来设置最大等待时间      void unlock();  //释放锁      Condition newCondition();  //这个下面讲&#125;\n\n这里再对lockInterruptibly方法做一点解释，这个方法提供了对中断的支持，我们前面提到每个线程都会有一个interrupt方法,这个方法不会真的打断线程，只是对线程进行一个通知，Lock类中的lockInterruptibly方法可以监测这个通知，当收到通知时即使处在阻塞状态也会直接抛出InterruptedException异常\n此时的锁从一个依赖于具体对象的关键字变成了一个实际存在的锁对象，这在设计上显然符合Java的万物皆对象的思想，接下来我们可以来简单的了解一下Condition类，这个类可以被认为是Object类中wait方法的上位替代，可以简单的看一下\npublic interface Condition &#123;      void await() throws InterruptedException;  //相当与wait      void awaitUninterruptibly();  //相当于wait但不会被中断      long awaitNanos(long var1) throws InterruptedException;//  等待固定的时间，如果在时间内唤醒则返回剩余时间，如果超时则返回负数，注意单位是纳秒      boolean await(long var1, TimeUnit var3) throws InterruptedException;//同上但支持更细致的时间控制        boolean awaitUntil(Date var1) throws InterruptedException;  //等待到固定的时间点      void signal();  //唤醒随机的一个      void signalAll();  //唤醒全部&#125;\n\n一个Lock下可以包含多个Conditon,来实现更细致的控制。\n特别说明，上面两个类的方法中涉及类TimeUtil类，这是一个枚举类，指的是时间的单位\n可重入锁接下来介绍Lock接口的两个重要实现：可重入锁与读写锁，我们先来了解一下可重入锁。所谓的可重入锁指的是可以被多次加锁的锁对象，大概就像这样\npublic class Main &#123;    public static void main(String[] args) &#123;        Lock lock = new ReentrantLock();        lock.lock();//可以反复加锁        lock.lock();        ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();        threadLocal.set(0);        Thread thread = new Thread(() -&gt; &#123;        lock.lock();//尝试获得锁，进入阻塞            System.out.println(&quot;获得锁&quot;);        &#125;);        thread.start();        lock.unlock();        System.out.println(&quot;第一次释放锁&quot;);        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(&quot;第二次释放锁&quot;);        lock.unlock();    &#125;&#125;\n可以看到我们在第一次释放锁后thread并没有获得锁，而是等到两次释放锁之后才真正获得了锁。\n此处我们进一步引入公平锁与非公平锁的概念，两者的区别如下\n\n公平锁中维护了一个等待队列，所有尝试获取锁的线程都将进入这个队列，按照先进先出的顺序来获取锁\n非公平锁中同样拥有一个等待队列，但此时当一个线程需要获取锁时会尝试先获取锁，如果获取失败则进入等待队列\n\n我们上面展示的可重入锁就是非公平锁，不过我们也可以选择公平锁模式，就像这样\nLock lock = new ReentrantLock(true);\n此时的锁就是一个公平锁\n读写锁接下来我们介绍读写锁，这种锁的创造时考虑到了这样一个事实：对同一个变量，部分线程只需要读取，部分线程需要修改，而对于只有读取需求的线程来说，可以不占用锁。在这种情况下，读写锁将锁分成了两部分：\n\n读锁：在没有任何线程占用写锁的情况下可以被多个线程获取\n写锁：在没有任何线程占用读锁的情况下可以被唯一一个线程获取\n\n大致的使用方式如下\npublic class Main &#123;    public static void main(String[] args) &#123;        ReentrantReadWriteLock lock = new ReentrantReadWriteLock();        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;加写锁&quot;);            lock.writeLock().lock();            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(&quot;释放写锁&quot;);            lock.writeLock().unlock();            System.out.println(&quot;加读锁&quot;);            lock.readLock().lock();        &#125;);        thread.start();        lock.writeLock().lock();        System.out.println(&quot;获得写锁&quot;);        lock.writeLock().unlock();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        lock.readLock().lock();        System.out.println(&quot;获取写锁&quot;);    &#125;&#125;\n\n这种锁在部分线程需要读取部分线程需要写入时很好的满足了需求\n原子类有些时候我们只需要一些简单的操作，此时为了简化操作，人们又创造了原子类，类中所有的方法都是线程安全的。原子类包含三种\n\nAtomicInteger：原子更新int\nAtomicLong：原子更新long\nAtomicBoolean：原子更新boolean由于在使用上比较简单，我这里只放一个例子，就不做具体的解释了\n\npublic class Main &#123;    private static AtomicInteger i = new AtomicInteger(0);    public static void main(String[] args) throws InterruptedException &#123;        Runnable r = () -&gt; &#123;            for (int j = 0; j &lt; 100000; j++)                i.getAndIncrement();            System.out.println(&quot;自增完成！&quot;);        &#125;;        new Thread(r).start();        new Thread(r).start();        TimeUnit.SECONDS.sleep(1);        System.out.println(i.get());    &#125;&#125;\n\n并发容器最后再介绍一下jdk提供的并发容器，我们之前习惯的ArrayList，HashMap等容器实际上是线程不安全的，我们这里可以使用线程安全的并发容器，比较常用的包括\n\nCopyOnWriteArrayList\nConcurrentHashMap\nBlockingQueue由于在使用时与普通容器没什么大的区别，这里就不做介绍了\n\n线程池接下来我们来了解一下java的线程池相关内容，线程的创建与销毁是一个开销很大的工作，所以我们倾向于在有长期使用需要时创建一个线程池，一次性创建足够的线程病保存在池中，之后只使用池中线程java提供了一个原生的线程池实现，大概使用方式如下\npublic class Main &#123;    public static void main(String[] args) &#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 0L,                TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(200));        for (int i = 0; i &lt; 10; i++) &#123;            executor.execute(() -&gt; &#123;                System.out.println(Thread.currentThread().getName());            &#125;);        &#125;        System.exit(0);    &#125;&#125;\n\n接下来我们去底层看一看到底是做了什么，下面是全参的构造方法\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;        this.ctl = new AtomicInteger(ctlOf(-536870912, 0));        this.mainLock = new ReentrantLock();        this.workers = new HashSet();        this.termination = this.mainLock.newCondition();        if (corePoolSize &gt;= 0 &amp;&amp; maximumPoolSize &gt; 0 &amp;&amp; maximumPoolSize &gt;= corePoolSize &amp;&amp; keepAliveTime &gt;= 0L) &#123;            if (workQueue != null &amp;&amp; threadFactory != null &amp;&amp; handler != null) &#123;                this.corePoolSize = corePoolSize;                this.maximumPoolSize = maximumPoolSize;                this.workQueue = workQueue;                this.keepAliveTime = unit.toNanos(keepAliveTime);                this.threadFactory = threadFactory;                this.handler = handler;                String name = Objects.toIdentityString(this);                this.container = SharedThreadContainer.create(name);            &#125; else &#123;                throw new NullPointerException();            &#125;        &#125; else &#123;            throw new IllegalArgumentException();        &#125;    &#125;\n我们先简单的看一下各个参数\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;\n下面是名词解释：\n\ncorePoolSize：核心线程数量\nmaximumPoolSize：最大线程数量\nkeepAliveTime：非核心线程等待时间\nunit：等待时间的单位\nworkQueue：任务队列\nthreadFactory：线程工厂\nhandaler：拒绝策略线程池中的线程被分为核心线程与非核心线程，所有的任务都被放入任务队列中，线程从任务队列中获取任务进行执行，如果所有核心线程都有任务，就注册新的非核心线程进行处理，如果达到最大线程数量就将任务保留在任务队列中，如果任务队列已满，则按照拒绝策略进行处理\n\n我们再来看一看exucute方法具体的实现\npublic void execute(Runnable command) &#123;       if (command == null) &#123;           throw new NullPointerException();       &#125; else &#123;           int c = this.ctl.get();//此处稍微解释一下，ctl这个变量同时存储了线程池中工作线程的数量和线程池的状态，需要通过位运算分离           //如果正在工作的线程数小于核心线程数，直接将任务给核心线程中           if (workerCountOf(c) &lt; this.corePoolSize) &#123;               if (this.addWorker(command, true)) &#123;                   return;               &#125;               c = this.ctl.get();//此时没有成功的插入任务，说明发生了某种异常，重新获取ctl           &#125;           //isRunning方法检查线程池是否正在运行，尝试将任务放到任务队列           if (isRunning(c) &amp;&amp; this.workQueue.offer(command)) &#123;               int recheck = this.ctl.get();//再次检查线程池的工作状态               if (!isRunning(recheck) &amp;&amp; this.remove(command)) &#123;                   this.reject(command);//此分支说明线程池被设置为拒绝加入，使用拒绝策略               &#125; else if (workerCountOf(recheck) == 0) &#123;                   this.addWorker((Runnable)null, false);//此分支说明线程池中无线程               &#125;           &#125; else if (!this.addWorker(command, false)) &#123;//尝试将线程放到非核心线程中               this.reject(command);           &#125;       &#125;   &#125;\n\n这里有一个额外需要解释的点事ctl,这个原子整数中保存了一个32位的int,其中部分位用来保存线程池的状态,部分位用来保存线程池中线程的数量,通过位运算获得具体位的数字得到信息\n我们可以继续深入,看看addWorker方法干了些什么\nprivate boolean addWorker(Runnable firstTask, boolean core) &#123;        for(int c = this.ctl.get(); !runStateAtLeast(c, 0) || !runStateAtLeast(c, 536870912) &amp;&amp; firstTask == null &amp;&amp; !this.workQueue.isEmpty(); c = this.ctl.get()) &#123;            while(workerCountOf(c) &lt; ((core ? this.corePoolSize : this.maximumPoolSize) &amp; 536870911)) &#123;//这个奇奇怪怪的长整数转换为二进制为 `00011111111111111111111111111111`，是用来和ctl做位运算获得线程池的不同信息的                if (this.compareAndIncrementWorkerCount(c)) &#123;//此处利用CAS操作增加c的值                    c = 0;                    boolean workerAdded = false;                    Worker w = null;                    try &#123;                        w = new Worker(firstTask);//创建一个Worker,其实就是Thread套皮                        Thread t = w.thread;                        if (t != null) &#123;                            ReentrantLock mainLock = this.mainLock;                            mainLock.lock();                            try &#123;                                int c = this.ctl.get();                                if (isRunning(c) || runStateLessThan(c, 536870912) &amp;&amp; firstTask == null) &#123;                                    if (t.getState() != State.NEW) &#123;                                        throw new IllegalThreadStateException();                                    &#125;                                    this.workers.add(w);                                    workerAdded = true;                                    int s = this.workers.size();                                    if (s &gt; this.largestPoolSize) &#123;                                        this.largestPoolSize = s;                                    &#125;                                &#125;                            &#125; finally &#123;                                mainLock.unlock();                            &#125;                            if (workerAdded) &#123;                                this.container.start(t);                                c = 1;                            &#125;                        &#125;                    &#125; finally &#123;                        if (!c) &#123;                            this.addWorkerFailed(w);                        &#125;                    &#125;                    return (boolean)c;                &#125;            &#125;            return false;        &#125;        return false;    &#125;\n看不懂没关系,我们来直接自己实现一个线程池,只实现最基本的功能，一切追求简单\npublic class ThreadPool &#123;    private AtomicInteger coreThreadCount;    private AtomicInteger maxThreadCount;    private ArrayBlockingQueue&lt;Runnable&gt; workQueue;    private AtomicInteger activeThreadCount;    private long activeTime;    public ThreadPool(int coreThreadCount, int maxThreadCount,int workQueueSize, int activeThreadCount) &#123;      this.coreThreadCount = new AtomicInteger(coreThreadCount);      this.maxThreadCount = new AtomicInteger(maxThreadCount);      this.workQueue = new ArrayBlockingQueue&lt;&gt;(workQueueSize);      this.activeThreadCount = new AtomicInteger(0);      this.activeTime = activeThreadCount;  &#125;//简单的构造方法，全都是直接赋值        public void excute(Runnable task) &#123;        if(activeThreadCount.get()&lt;coreThreadCount.get())&#123;            Thread thread = new Thread(()-&gt;&#123;                task.run();                while(true)&#123;                    Runnable r = workQueue.poll();//这里直接利用阻塞队列的特性，如果队列中没有任务会陷入阻塞                    if(r!=null)&#123;                        r.run();                    &#125;                &#125;            &#125;);//核心线程反复尝试获取任务，注册后用不销毁            thread.start();            activeThreadCount.incrementAndGet();            coreThreadCount.incrementAndGet();        &#125; else if (activeThreadCount.get()&lt;maxThreadCount.get()) &#123;            Thread thread = new Thread(()-&gt;&#123;                task.run();                while(true)&#123;                    try &#123;                    Runnable r = workQueue.poll(activeTime,TimeUnit.MILLISECONDS);                    //此处设置非核心线程的等待时间，如果时间超过了设置的时间还没有任务则退出                    if(r!=null)&#123;                        r.run();                    &#125;                    &#125;catch (InterruptedException e)&#123;                        activeThreadCount.decrementAndGet();//记得在销毁线程时活动线程数减1                        break;                    &#125;                &#125;            &#125;);            thread.start();            activeThreadCount.incrementAndGet();        &#125;else &#123;            throw new RuntimeException(&quot;超出最大线程数量&quot;);        &#125;    &#125;    &#125;\n我们总计使用了56行就实现了一个最为简单的线程池，当然，你也可以试着自己优化这个线程池，加点什么状态控制，拒绝策略等等，但后面都是一些很好实现的东西了。\n工具类最后的最后我们还需要了解一下几个简单的工具类\nCountDownLatch计数器锁假设我们存在一个多线程任务，我们需要所有线程都完成后再在主线程执行下一步，各个线程执行时间未知，该怎么实现？我们可以使用计数器锁，大概如下\npublic class Main &#123;    public static void main(String[] args) &#123;        CountDownLatch countDownLatch = new CountDownLatch(10);//计数器中有10个数        Runnable runnable = new Runnable() &#123;            public void run() &#123;                try&#123;                    Thread.sleep(1000);                    countDownLatch.countDown();//每次调用这个方法都将初始的值减1                &#125;catch (InterruptedException e)&#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(runnable).start();        &#125;        countDownLatch.await();//等待减到0才会执行下一步        System.out.println(&quot;All done&quot;);            &#125;&#125;\n\nCyclicBarrier循环屏障上面我们使用for循环来启动了10个线程，但在某些需求下我们可能会要求线程同步启动，此时可以使用循环屏障\npublic static void main(String[] args) &#123;    CyclicBarrier barrier = new CyclicBarrier(10,   //创建一个初始值为10的循环屏障                () -&gt; System.out.println(&quot;飞机马上就要起飞了，各位特种兵请准备！&quot;));   //人等够之后执行的任务    for (int i = 0; i &lt; 10; i++) &#123;        int finalI = i;        new Thread(() -&gt; &#123;            try &#123;                Thread.sleep((long) (2000 * new Random().nextDouble()));                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入房间进行等待... (&quot;+barrier.getNumberWaiting()+&quot;/10)&quot;);                barrier.await();    //调用await方法进行等待，直到等待的线程足够多为止                //开始游戏，所有玩家一起进入游戏                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入游戏！&quot;);            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n直到达到要求的线程数量所有线程才能进入下一步\n此外，循环屏障可以被重复使用，每次达到约定的线程后都会重置；\nExchanger数据交换类借助这个类我们可以实现不同线程之间的数据交换，大概如下\npublic static void main(String[] args) throws InterruptedException &#123;    Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();    new Thread(() -&gt; &#123;        try &#123;            System.out.println(&quot;收到主线程传递的交换数据：&quot;+exchanger.exchange(&quot;AAAA&quot;));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;).start();    System.out.println(&quot;收到子线程传递的交换数据：&quot;+exchanger.exchange(&quot;BBBB&quot;));&#125;\n\n我个人感觉有那么点鸡肋；\n结语好的，到这里多线程的部分就算结束了，下一期我们来研究一下HTTP解析，实现简单的网络通讯。\n\n","tags":["手写Spring"]}]