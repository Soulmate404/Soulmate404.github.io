[{"title":"Docker入门","url":"/2025/04/01/Docker%E5%85%A5%E9%97%A8/","content":"最近忙着写项目，好久没更新内容了。而且就在昨天，重装系统的时候我居然忘了把博客的本地文件保存一份！！！现在我已经失去了前面博客的所有内容，不得不花费大量时间重新把前面的内容整理一次，孩子心里苦啊。\n闲话就聊到这里,今天我们来了解一下Docker技术.Docker可以帮助我们快速的实现项目依赖环境的完整打包.方便我们将项目快速的部署到不同的设备上去.\n由于Windows上没有原生的Docker,想要运行需要套几层壳,所以这次我们使用Ubuntu.具体版本为Ubuntu24.04.(当然现在有了WSL2，其实在windows上也不是很麻烦，直接去官网https://www.docker.com/下载即可)\nDocker的安装我们首先来完场Docker的安装.这部分比较简单,先安装一些依赖\nsudo apt-get install ca-certificates curl gnupg lsb-release\n\n然后安装官方的GPG Key\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n然后将Docker的下载地址放到apt的搜索列表中\necho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n接着更新一下列表\nsudo apt update\n\n接着下载Docker的社区版本（Docker分为社区版和商业版）\nsudo apt install docker-ce\n\n可以通过\ndocker --version\n\n来判断是否下载成功\n\nDocker的配置到此完成，我们接下来详细的了解一下Docker的结构\n容器与镜像容器与虚拟机的区别在开始这一板块之前，我们先来思考一个问题：假设我现在使用的是Ubuntu22.04,然后下载一个Ubuntu24.04的Docker，那么我是否能使用Ubuntu24.04的全部功能呢？这个问题在虚拟机上是显然的，但是在Docker中却不那么肯定。\n我们可以看一下这张图：\n\n这张图体现了虚拟机和Docker的重要区别：虚拟机的虚拟是内核级别的，所有的虚拟机相互独立，互不干扰。但是，所有的Docker共用设备的内核空间，只拥有独立的用户空间。也就是说，如果ubuntu22.04的内核支持相关功能，我们是可以顺利使用的，但如果内核不知相关功能，我们就无能为力了。\n此外，还有一点值得注意：容器与镜像的区别。\n直接构建了解了这些，我们开始尝试自己构建一个镜像，每一个应用都运行在操作系统上，所以构建自己的镜像也必须基于最基本的系统镜像，我们一般称这些镜像为Base镜像（当然，在很多时候我们也不一定真的从最基本的镜像开始构建，而是使用一些已经安装了一些必要的环境的镜像开始构建）。我们这里尝试去构建一个包含了jdk的ubuntu镜像\n首先我们拉取一个ubuntu的Base镜像(最近由于DockerHub的限制，很多镜像源都不能用了，如果下载不下来，请自行寻找合适的镜像源或者科学上网)\ndocker pull ubuntu:22.04\n\n这里注意，一个镜像的标准名称通常为name:tag的格式，name用来说明名称，tag用来说明版本\n下载完成后可以通过\ndocker images\n\n来查看当前的所有镜像\n\n可以看到，刚刚下载的Ubuntu镜像小的惊人，只有77.9MB,这是因为作为Base镜像，只保留了最基本的用户空间运行能力，我们平时很多常用的命令都是无法在这个镜像中执行的。\n接下来在容器中运行这个镜像\ndocker run -it ubuntu:22.04\n\n其中i参数指创建一个标准的输入输出接口，t参数指创建一个虚拟的tty设备来作为终端供我们使用，这两个参数一般同时使用，效果如下：\n我们已经进入了基于ubuntu镜像创建的容器的内部\n我们的目的是构建一个包含jdk的ubuntu镜像，所以现在执行下列命令\napt update &amp;&amp; apt install -y openjdk-21-jdk\n\n下载完成后可以使用exit直接退出\n现在查看以下我们的容器\ndocker ps -a\n\n如果不使用a参数则只显示处于运行状态下的容器\n\n接下来执行\ndocker commit 容器ID/名称 新的镜像名\n\nDocker中所有可以使用id的地方都可以使用ID的一部部分，只要能保证具有唯一性就好，例如我们可以在此处使用\ndocker commit fd jdk:21\n\n看一看结果\n\n注意到经过我们的一番操作后镜像的体积发生了巨大的膨胀，这是因为我们在下载jdk时不但下载了jdk,还下载了jdk运行时必要的操作系统依赖。\n对于已经存在的镜像，我们可以\ndocker start name/id #启动现有的镜像docker stop name/id #停止正在运行的镜像\n\n我们可以使用这种方法去构建任何镜像，但这种镜像的构建存在一个问题：不够透明。除你之外没有人知道这个镜像是如何被构建的，对个人使用来说，这种构建方式显然是无所谓的，但是如果这个镜像是面向其他人的，我们就不应该这么做，我们需要使用Dockerfile来完成构建\n通过Dockerfile构建在开始之前我们先删除之前创造的镜像与容器\ndocker rmi 镜像ID #删除镜像docker rm 容器ID #删除容器\n\n同样的，只要输入ID的开头，确保唯一性即可\n接下来我们创建一个名为Dockerfile的文件，并写入如下的内容\nFROM ubuntu:22.04RUN apt update &amp;&amp; apt install -y openjdk-21-jdk\n\n在该文件目录下执行\ndocker build -t jdk:21 .\n\n就能得到和我们之前所构建的jdk镜像完全相同的镜像了\n下面我展示一些在Dockerfile中常使用的命令\nFROM &lt;基础镜像&gt; #从对应的基础镜像开始构建LABEL xxx=xx #给镜像添加元数据，一般用来标识作者，版本等信息ARG xxx=xx #创建一个名为xxx的参数，其值为xx,为此后调用这个值提供方便RUN xxx #在基础镜像内执行xxxCOPY /xx /xxx #将/xx目录下的内容复制到镜像的/xxx目录下ADD https://example.com/file.tar.gz /app/ #与COPY类似，但支持远程下载WORKDIR /xx #设置容器启动时将自动跳转到容器内的/xx目录下ENV xxx=xx #为镜像添加一个名称为xxx的环境变量，其值为xxEXPOSEE xxx #对外暴露容器的xxx端口VOLUME /xx #在容器的/xx目录下创建一个挂载点用于数据持久化，这点我们后面再解释ENTRYPOINT xxx #在容器启动时自动执行xxx,优先级高于CMDCMD xxx #在容器启动时自动执行xxx\n\n当然，这并不是全部的命令，但大多数时候对我们来说已经够用了\n在这部分的最后，让我们了解一下如何将我们所创建的镜像推送到DockerHub，首先自行到Dockerhub创建一个仓库\n\n接下来我们将我们之前的镜像重新命名后推送\ndocker tag jdk:21 myjdk:21docker push 你的用户名/myjdk:21\n\n根据规范，我们必须在推送时添加自己的用户名来保证推送到属于我们自己的仓库，在拉取时同样采用\ndocker pull 你的用户名/myjdk:21\n\n的格式来确保获得正确的镜像\n这一步操作如果网络环境好可以试一试，毕竟一次性要上传800MB,在当前网络环境下有时候会比较困难\nDocker网络管理接下来我们来了解一下Docker的网络管理，我们执行如下的命令\ndocker network ls\n\n\n我们可以看到当前总共有三个网路，这三个网络是Docker在下载时就帮我们创建的，分别对应Docker支持的三种网络类型bridge null host\n我们首先来看看null网络，这个网络中只有一个本地环路，与宿主机的网络环境相互隔离，无法通过网络访问，用于部分有特殊安全需求的环境。如果想使用null网络，可以使用\ndocker run --network=none jdk:21\n\n然后是host网络，如果容器使用的是这种网络，相当于直接使用宿主机的网络环境，在这种网络下，我们，容器中的网络配置与宿主保持一致，不需要镜像额外的开放端口等操作。在这种模式下，网络通信的损失是最小的.如果想使用我们\n最后是bridge网络，或者说是桥接网络，你可以简单的理解为在宿主机上创建了一个虚拟的局域网，宿主机与容器都是这个虚拟局域网的一台设备，不同设备之间通过这个局域网进行信息交互。这也是所有容器的默认网络模式。在这种模式下，我们前面的在Dockerfile中主动暴露端口的行为就有了意义，举个简单的例子\ndocker run -p 1234:80 -n test jdk:21\n\n这里我使用了两个参数，p参数用来指定端口映射，将宿主机的1234端口映射到容器的80端口，此时对宿主机1234端口的访问就会通过桥接网络转发到容器的80端口。n参数是给容器命名的，我们之前所创建的容器起名称都是docker随即生产的，我们可以通过这个参数手动指定。\n在这里你可能会问，那我们之前在Dockerfile中提到的EXPOSE指令又有什么作用呢？这个指令更多的起到提醒作用，用于提醒用户需要将这个端口映射到宿主机中\n我们也可以创建自己的网络，例如这样\ndocker network creat --driver bridge test\n\n这样我们就创建了一个名为test的桥接网络，我们在启动时可以手动指定使用的网络\ndocker run --network=test image\n\n注意，虽然都是使用桥接网络，但是test网络与bridge网络两个网络是互相隔离的，无法互相进行通信，当然，我们也可以主动进行连接\ndocker network connect test containerID/name\n\n此时容器就被主动的连接到了test网络\n容器数据持久化还记得我们上面提到的volume指令吗？对于一个一般的容器，在停止运行时所有运行时产生的数据都将被删除，这无疑是我们所不想看到的，所以我们可以使用VOLUME指令创建挂载点，此时docker会产生一个匿名卷来存储doker对应目录下的数据，这个匿名卷在宿主机上的路径一般为/var/lib/docker/volumes，不过我们可以选择进一步的定制化一些，我们可以将容器的数据挂载到宿主机的指定路径下，使用\ndocker run -v /host/path:/container/path image\n\n此时会将容器的&#x2F;container&#x2F;path与宿主机的&#x2F;host&#x2F;path相互绑定，宿主机与容器任何一方对数据的修改都会在另一方体现\n如果我们使用v参数但不指定宿主机路径，则会在宿主机上自动创建对应路径\n如果我们想要在多个容器之间共享数据呢，聪明的你一定想到创建一个公共目录，经所有容器都挂载到对应的目录。但是我们还有别的办法：直接将一个容器的路径挂载到另一个容器\ndocker run -p 80:80 --volumes-from=data_test test\n\n此时test继承了data_test的挂载信息，在总体容器数量比较多时我们通常会创建一个专门的容器用来管理数据（被称为数据卷容器），例如上面的data_test,所有的容器再继承其挂载方式\nDocker容器管理接下来我们来聊一聊对运行状态下的容器的管理，有以下常用的命令\ndocker log 容器名/ID\n\n可以用来输出容器中的控制台信息（f参数可用来保持持续输出）\ndocker attach 容器ID/名称\n\n直接进入某个运行的容器的内部，注意在完成操作后先按Ctrl+P再按Ctrl+Q退出，千万不要按Ctrl+C这会导致容器停止运行\ndocker exec -it 容器ID/名称\n\n为容器创建一个新的bash终端，如果容器中运行的项目会不断的对控制台输出信息，那么可以通过这个指令开启一个新的终端来对容器进行操作\ndocker stats\n\n用于查看所有容器的状态\ndocker top 容器ID/名称\n\n查看某个容器的所有进程信息\n接下来是几个比较不推荐的\ndocker kill 容器ID/名称 #强制终止容器docker pause 容器ID/名称 #暂停容器docker unpause 容器ID/名称 #与上一条相反\n\n其实还有很多操作，但是这些操作都是偏运维向的，这里就不做介绍了\n常用参数介绍注意，docker非常重视灵活性，所有在dockefile中规定的东西都可以被在启动时覆盖，实际的覆盖操作使用以下这些参数\n\n\n\n参数\n描述\n示例\n\n\n\n-d\n后台运行容器\ndocker run -d IMAGE\n\n\n-it\n交互式终端，-i 保持标准输入打开，-t 分配一个伪终端\ndocker run -it IMAGE\n\n\n--name\n为容器指定一个名称\ndocker run --name mycontainer -d IMAGE\n\n\n-p\n端口映射，格式为 主机端口:容器端口\ndocker run -p 8080:80 -d IMAGE\n\n\n-v\n数据卷映射，格式为 主机路径:容器路径[:权限]\ndocker run -v /host/path:/container/path -d IMAGE\n\n\n--env 或 -e\n设置环境变量\ndocker run --env MY_VAR=value -d IMAGE\n\n\n--network\n将容器连接到指定的 Docker 网络\ndocker run --network mynetwork -d IMAGE\n\n\n--restart\n设置容器的重启策略，可选值为 no、on-failure、always、unless-stopped\ndocker run --restart always -d IMAGE\n\n\n--link\n将容器连接到另一个容器\ndocker run --link other-container:alias -d IMAGE\n\n\n--cpus\n限制容器使用的 CPU 资源\ndocker run --cpus=&quot;1.5&quot; -d IMAGE\n\n\n--memory\n限制容器使用的内存\ndocker run --memory=&quot;256m&quot; -d IMAGE\n\n\n--gpus\n指定容器可以访问的 GPU 设备\ndocker run --gpus all -d IMAGE\n\n\n--log-driver\n指定日志驱动\ndocker run --log-driver=syslog -d IMAGE\n\n\n--health-cmd\n配置容器的健康检查命令\n&#96;docker run –health-cmd&#x3D;”curl -f http://localhost/\n\n\n--user\n指定容器内进程的用户\ndocker run --user username -d IMAGE\n\n\n--security-opt\n设置 SELinux 或 AppArmor 配置\ndocker run --security-opt seccomp=unconfined -d IMAGE\n\n\n--cap-add\n添加容器的 Linux 能力\ndocker run --cap-add=SYS_ADMIN -d IMAGE\n\n\n--cap-drop\n删除容器的 Linux 能力\ndocker run --cap-drop=SYS_ADMIN -d IMAGE\n\n\n--privileged\n给容器赋予特权，可以访问主机的设备\ndocker run --privileged -d IMAGE\n\n\n--tmpfs\n在容器内创建临时文件系统\ndocker run --tmpfs /tmp -d IMAGE\n\n\n--ulimit\n设置容器的资源限制，如最大打开文件数、最大进程数等\ndocker run --ulimit nofile=1024:1024 -d IMAGE\n\n\n--hostname\n设置容器的主机名\ndocker run --hostname my_container -d IMAGE\n\n\n--dns\n指定容器使用的自定义 DNS 服务器\ndocker run --dns 8.8.8.8 -d IMAGE\n\n\n--dns-search\n指定容器的 DNS 域\ndocker run --dns-search example.com -d IMAGE\n\n\n--entrypoint\n覆盖镜像的默认入口点\ndocker run --entrypoint /custom_entrypoint -d IMAGE\n\n\n--rm\n容器退出时自动删除容器\ndocker run --rm -d IMAGE\n\n\n--mount\n更详细的挂载配置，支持类型 bind、volume、tmpfs\ndocker run --mount type=bind,source=/data,target=/app/data -d IMAGE\n\n\n--shm-size\n设置容器的共享内存大小\ndocker run --shm-size 2g -d IMAGE\n\n\n--volume-driver\n指定容器使用的卷驱动程序\ndocker run --volume-driver my_driver -d IMAGE\n\n\n--env-file\n从文件读取环境变量\ndocker run --env-file=env.list -d IMAGE\n\n\n--label\n为容器添加元数据标签\ndocker run --label &quot;env=prod&quot; -d IMAGE\n\n\n需要特别说明的是ENTRYPOINT可以通过--entrypoint  覆盖，而CMD指令可以通过类似\ndocker run my_image echo &quot;Hello, World!&quot;\n\n这样原来的CMD命令将会被覆盖，如果需要的命令过于复杂，你还可以这样\ndocker run my_image &lt; cmd.sh\n\n直接编写一份完整的脚本然后导入\n结语如果你之前来过我的站，你可能会发现所有的之前的文章都已经消失了，由于某次出人意料的事故，所有之前写下的文章都美丽，悲～～～。所以只好从零开始了，有很多东西确实比较有用，有空的话我会尽力再尝试写一份的\n\n","tags":["杂谈"]},{"title":"IDEA中VIM插件的使用","url":"/2025/04/17/IDEA%E4%B8%ADvim%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"  今天我们讲一讲关于idea中vim插件的使用。其实网上一直有这样两波人，一批人在疯狂的吹嘘vim到底有多好用，甚至看不起平时使用IDE的人；另一批人却将vim的使用者称之为装。 从我个人的使用感受上来说，vim确实是个好东西，唯一的问题就是不怎么好上手，在习惯以后确实能够大大提高编码效率。但是真的完全用vim写代码，需要做各种繁琐的配置，给vim安装各种各样的插件，还不一定能百分百达到完整的IDE的效果，所以我的选择是IDEEA加vim插件，使用起来感觉要好很多\nvim插件下载几乎所有的主流IDE都有对应的vim插件，而且大部分还做的不错。在IDEA中打开自带的插件市场搜索vim并下载下面的三个插件\n\n下载完成后你可以看到类似的状态，右下角出现了一个绿色的normal,光标变成了按过Insert键后的样式就说明下载成功了\n\n基本的使用接下来讲一下vim的基本使用，这些操作和vim保持一致，可以在任何一个vim环境中使用。\n我实在懒得把这些东西重写一次，所以直接使用来自于菜鸟教程的表格，这里是原网页https://www.runoob.com/linux/linux-vim.html\n\n\n\n移动光标的方法\n\n\n\n\nh 或 向左箭头键(←)\n光标向左移动一个字符\n\n\nj 或 向下箭头键(↓)\n光标向下移动一个字符\n\n\nk 或 向上箭头键(↑)\n光标向上移动一个字符\n\n\nl 或 向右箭头键(→)\n光标向右移动一个字符\n\n\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！\n\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n[Ctrl] + [d]\n屏幕『向下』移动半页\n\n\n[Ctrl] + [u]\n屏幕『向上』移动半页\n\n\n+\n光标移动到非空格符的下一行\n\n\n-\n光标移动到非空格符的上一行\n\n\nn\n那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\nH\n光标移动到这个屏幕的最上方那一行的第一个字符\n\n\nM\n光标移动到这个屏幕的中央那一行的第一个字符\n\n\nL\n光标移动到这个屏幕的最下方那一行的第一个字符\n\n\nG\n移动到这个档案的最后一行(常用)\n\n\nnG\nn 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！ (常用)\n\n\nn\nn 为数字。光标向下移动 n 行(常用)\n\n\n搜索替换\n\n\n\n&#x2F;word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\n使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！\n\n\n\n:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g\nn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)\n\n\n删除、复制与贴上\n\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\nnx\nn 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\n\n\ndd\n剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nndd\nn 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nd1G\n删除光标所在到第一行的所有数据\n\n\ndG\n删除光标所在到最后一行的所有数据\n\n\nd$\n删除游标所在处，到该行的最后一个字符\n\n\nd0\n那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nnyy\nn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\n\n\ny1G\n复制游标所在行到第一行的所有数据\n\n\nyG\n复制游标所在行到最后一行的所有数据\n\n\ny0\n复制光标所在的那个字符到该行行首的所有数据\n\n\ny$\n复制光标所在的那个字符到该行行尾的所有数据\n\n\np, P\np 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)\n\n\nJ\n将光标所在行与下一行的数据结合成同一行\n\n\nc\n重复删除多个数据，例如向下删除 10 行，[ 10cj ]\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n\n\n\n.\n不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)\n\n\n第二部分：一般模式切换到编辑模式的可用的按钮说明\n\n\n进入输入或取代的编辑模式\n\n\n\n\ni, I\n进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\n\n\na, A\n进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n第三部分：一般模式切换到指令行模式的可用的按钮说明\n\n\n指令行的储存、离开等指令\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)\n\n\nZQ\n不保存，强制退出。效果等同于 :q!。\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！\n\n\nvim 环境的变更\n\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n大家可以自行查看这些操作。你会发现这些操作保证了我们在双手不离开键盘中心区的前提下可以完成几乎所有的编辑操作，用习惯后还是非常爽的\n简单的配置但是从我个人的使用体验上来说，还是要对插件进行一些简单的配置，这样才能用起来更爽。点击normal左侧的彩色v图标\n\n然后选择settings\n\n接下来进入这个页面\n\n可以避免vim插件覆盖一些我们常用的快捷键的功能，比如我将Ctrl+A,Ctrl+C等常用的按键功能保留了下来\n接下来点击应用后关掉这个页面，再次点击v图标，选择Creat ～&#x2F;.ideavimrc 进入vim插件的配置文件\n我在下面贴一下我自己的配置并提供比较详细的注释，又需要的可以自己改写\nbasicPlug &#x27;machakann/vim-highlightedyank&#x27;&quot; Commentary pluginPlug &#x27;tpope/vim-commentary&#x27;&quot; 1. 基础 Vim 行为&quot; ----------------------------set number&quot; 在编辑器左侧显示绝对行号，有助于快速跳转到指定行（如输入 50G）并与同事共享行号定位。vim原生选项。set relativenumber&quot; 将当前行显示为绝对行号，其它行显示相对行号（与当前行的距离）。在进行跳转（例如 5j、3k）或上下文操作时非常直观。set cursorline&quot; 在当前行绘制高亮背景，增强光标位置的视觉识别，减少长文件中定位迷失的可能。set showmode&quot; 在命令行区域显示当前模式（-- INSERT --、-- VISUAL -- 等），方便快速确认当前是普通模式还是插入模式。set showcmd&quot; 当你输入多键命令（例如 d5w）时，实时在底部显示已输入的部分，帮助跟踪复杂映射或宏输入。set incsearch&quot; 在输入搜索模式（/pattern）时，边输入边高亮匹配，实时预览匹配结果，无需回车确认即可判断效果。set hlsearch&quot; 持续高亮所有与搜索模式匹配的项，便于一次性观察整个文件中的分布位置。set scrolloff=5&quot; 光标上下留有 5 行空白，以保持视野中心；在滚动时不至于光标贴近屏幕边缘。set sidescrolloff=5&quot; 同理，左右侧留 5 列空白，适用于超长行的水平滚动。set clipboard+=unnamed&quot; 将 Vim 的剪贴板与系统剪贴板合并，复制/粘贴可直接与 IDEA 与其他应用共享，免去额外切换。set wildmenu&quot; 启用命令行自动补全菜单，按 Tab 循环选择补全项，比原生补全反馈更友好。set wildmode=longest:full,full&quot; 补全方式：先补全公共前缀，再列出所有匹配项。提升多候选补全的效率与准确性。&quot; 2. Leader 键与快捷键映射&quot; ----------------------------let mapleader=&quot; &quot;&quot; 将“Leader 键”设为空格键；避免与常见 Vim 默认映射冲突，空格易按且手感舒适。&quot; 文件与项目操作nnoremap &lt;leader&gt;w :w&lt;CR&gt;&quot; 在普通模式下，按 空格+w 保存当前文件，等效于 :w。nnoremap &lt;leader&gt;q :q&lt;CR&gt;&quot; 按 空格+q 关闭当前编辑窗口。可按需改为 :bd 以保留分屏布局。nnoremap &lt;leader&gt;ff :action FindInPath&lt;CR&gt;&quot; 空格+ff 调用 IDEA 的“全局查找文件/符号”功能（Find in Path），跨项目搜索。nnoremap &lt;leader&gt;fr :action ReplaceInPath&lt;CR&gt;&quot; 空格+fr 调用“全局替换”功能（Replace in Path），在整个项目中批量替换。&quot; 窗口与标签管理nnoremap &lt;leader&gt;tn :tabnew&lt;CR&gt;&quot; 空格+tn 新建一个标签页，便于并行打开多个文件。nnoremap &lt;leader&gt;to :tabonly&lt;CR&gt;&quot; 空格+to 关闭除当前标签外的所有标签，只保留当前视图。imap a; &lt;Esc&gt;&quot; 将&lt;Esc&gt;映射为a;避免误触的同时方便使用，有些人也比较喜欢jj等映射方式&quot; 3. IntelliJ IDEA Action 映射&quot; ----------------------------&quot; IdeaVim 特有命令格式：:action + IDEA 内部 Action ID&quot; 可在 IDEA 中开启 “IdeaVim: Track Action Ids” 来得知鼠标点击或快捷键触发的 Action ID。nnoremap &lt;leader&gt;cf :action ReformatCode&lt;CR&gt;&quot; 空格+cf 触发 IDEA 的“代码格式化”功能，自动应用项目中的代码风格规则。nnoremap &lt;leader&gt;oi :action OptimizeImports&lt;CR&gt;&quot; 空格+oi 调用“优化导入”，自动移除无用 import 并按配置排序。nnoremap gd :action GotoDeclaration&lt;CR&gt;&quot; 在普通模式下按 gd，跳转到光标所在符号的声明位置，便于快速阅读实现细节。nnoremap gr :action FindUsages&lt;CR&gt;&quot; 按 gr 查找符号所有用法，在底部面板中展示所有引用，方便代码审计与重构。nnoremap &lt;leader&gt;r :action Run&lt;CR&gt;&quot; 空格+r 运行当前上下文（文件、测试或应用），等同于点击工具栏 Run 按钮。nnoremap &lt;leader&gt;d :action Debug&lt;CR&gt;&quot; 空格+d 启动调试，自动进入 Debug 模式，便于单步排查逻辑。&quot; 4. 可选：引入本地 Vim 配置&quot; ----------------------------&quot; 如果你同时在终端使用 Vim，可将常用 Vim 配置放在 ~/.vimrc，&quot; 在 IdeaVim 中通过以下命令复用：&quot; source ~/.vimrc\n\n这里反复提到了leader键，所谓的leader键可以理解为一个前缀键，类似于一个自定义的Ctrl键，默认为反斜杠，长按时进入特殊模式，此时可与继续搭配其他案件实现各种各样的功能\n结语刚刚接触时由于记不清各个案件所以会有比较明显的滞涩感，不过只要时间长了用的熟悉了，以后就难以离开这种感觉了\n\n","tags":["杂谈"]},{"title":"JSON解析","url":"/2025/04/07/JSON%E8%A7%A3%E6%9E%90/","content":"  既然要手写一个可用的spring框架，那么网络通信部分是必不可少的，既然涉及到了网络通信，那么显然json解析能力是必须具备的，所以我们今天来试着手写一个json解析器吧\nJSON的规则首先我们研究以下JSON解析的问题，开始之前我们可以先看看JSON的标准\n\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和编写，也易于机器解析和生成。以下是 JSON 的主要规则和特点：\n1. 基本结构\nJSON 数据由两种结构组成：\n对象（Object）：无序的键值对集合，用花括号 &#123;&#125; 表示。\n数组（Array）：有序的值的集合，用方括号 [] 表示。\n\n\n\n2. 数据类型   JSON 支持以下数据类型：\n\n字符串：用双引号 &quot; 括起来的文本，例如 &quot;Hello, World!&quot;\n数字：整数或浮点数，例如 42 或 3.14\n布尔值：true 或 false\n空值：null\n对象：键值对的集合，例如 &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30 &#125;\n数组：值的有序列表，例如 [1, 2, 3, &quot;apple&quot;]\n\n3. 键值对规则\n键（Key）必须是字符串，并且用双引号 &quot; 括起来。\n键和值之间用冒号 : 分隔。\n键值对之间用逗号 , 分隔。\n示例：&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;isStudent&quot;: false&#125;\n\n4. 数组规则\n数组中的值可以是任何 JSON 支持的数据类型。\n数组中的值用逗号 , 分隔。\n示例：[  &quot;apple&quot;,  &quot;banana&quot;,  42,  true,  &#123; &quot;name&quot;: &quot;Alice&quot; &#125;]\n\n5. 嵌套结构\nJSON 支持嵌套的对象和数组。\n示例：&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;traveling&quot;],  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;123 Main St&quot;,    &quot;city&quot;: &quot;New York&quot;  &#125;&#125;\n\n6. 格式规范\nJSON 数据必须是有效的对象或数组。\n键必须用双引号括起来（单引号无效）。\n逗号不能出现在最后一个键值对或数组值之后（即不能有尾随逗号）。\n示例（错误）：&#123; &quot;name&quot;: &quot;Alice&quot;, &#125;  // 错误：尾随逗号\n\n7. JSON 的用途\n用于 Web 应用程序中的数据交换。\n用于配置文件（如 .json 文件）。\n用于 API 数据传输。\n\n8. JSON 与 JavaScript 的关系\nJSON 是 JavaScript 的一个子集，但独立于语言，可以被多种编程语言解析和生成。\n\n总结来说，JSON 是一种简单、灵活且广泛使用的数据格式，遵循上述规则可以确保数据的正确性和可读性。\n\n上面这部分是直接从网上找到的相关规范。仔细考虑以下，该怎们做？\n尝试解析我随便贴一段json,让我们来分析以下我们可能要处理的情况\n&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;traveling&quot;],  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;123 Main St&quot;,    &quot;city&quot;: &quot;New York&quot;  &#125;&#125;\n\n我们可能遇到的情况包括：\n\n遇到&#123;，表示一层解析的开始，如果在本层解析过程中遇到了新的&#123;，则进入新的解析层，换句话说，我们需要一个递归结构来处理问题\n遇到&#125;，表示当前层的解析结束\n遇到“，表示某个key或者value,可以考虑通过识别：来辨别这是一个key还是value,\n遇到[,表示数组的开始\n遇到,,表示键值对之间的分割\n遇到/，转义字符，后面的一个字符需要转义，\n\n仔细思考上面的信息，我们可以大概的写出一个可用的demo（建议先自己尝试一下，还是有一点难度的）\npackage Winter.Parser.JsonPaser;import java.util.*;public class JsonParser &#123;    String json;    int index;    private JsonParser(String json) &#123;        this.json = json;        this.index = 0;    &#125;    public void skipWhiteSpace() &#123;        while (Character.isWhitespace(json.charAt(index))) &#123;            index++;        &#125;    &#125;//跳过空格的方法    public void expectString(String target) &#123;        int start = index;        for (int i = 0; i &lt; target.length(); i++) &#123;if (target.charAt(i) != json.charAt(start)) &#123;                throw new RuntimeException(&quot;Expecting string at index &quot; + index + &quot; but found &quot; + target.charAt(i));            &#125;            start++;        &#125;//用于检测程序是否是按照我们期望的方式进行    &#125;    public Object parseValue() &#123;        skipWhiteSpace();        char ch = json.charAt(index);        return switch (ch) &#123;            case &#x27;&#123;&#x27; -&gt; parseObject();//通过首个字符类型判断解析方法            case &#x27;[&#x27; -&gt; parseArray();            case &#x27;&quot;&#x27; -&gt; parseString();            case &#x27;t&#x27; -&gt; parseTrue();            case &#x27;f&#x27; -&gt; parseFalse();            case &#x27;n&#x27; -&gt; parseNull();            default -&gt; &#123;                if (ch == &#x27;-&#x27; || Character.isDigit(ch)) &#123;                    yield parseNumber();                &#125;//处理判断数字的情况                throw new RuntimeException(&quot;Unexpected character at position &quot; + index + &quot;: &quot; + ch);            &#125;        &#125;;    &#125;    private Object parseObject() &#123;        Map&lt;String, Object&gt; jsonNodeMap = new LinkedHashMap&lt;&gt;();        expectString(&quot;&#123;&quot;);        index++;        skipWhiteSpace();        if(json.charAt(index)==&#x27;&#125;&#x27;)&#123;            index++;            return jsonNodeMap;        &#125;        while (true)&#123;            skipWhiteSpace();            String key = parseString();//由于key一定是字符串，直接用字符串的方式解析            skipWhiteSpace();            expectString(&quot;:&quot;);            index++;//跳过冒号            Object value = parseValue();//获取value            jsonNodeMap.put(key,value);            if(json.charAt(index)==&#x27;&#125;&#x27;)&#123;break;&#125;            if(json.charAt(index) !=&#x27;,&#x27;)&#123;                throw new RuntimeException(&quot;Unexpected character &#x27;&quot; + json.charAt(index) + &quot;&#x27; at index &quot; + index);            &#125;            index++;//用于跳过键值对之间的逗号        &#125;        return jsonNodeMap;    &#125;    private String parseString() &#123;        StringBuilder stringBuilder = new StringBuilder();        expectString(&quot;\\&quot;&quot;);        index++;//跳过引号        skipWhiteSpace();        while (json.charAt(index) != &#x27;&quot;&#x27;) &#123;//处理可能的转义字符            if (json.charAt(index) == &#x27;\\\\&#x27;) &#123;                index++;//跳过用于转义的\\                char c = json.charAt(index);                switch (c) &#123;                    case &#x27;t&#x27; -&gt; stringBuilder.append(&quot;\\t&quot;);                    case &#x27;f&#x27; -&gt; stringBuilder.append(&quot;\\f&quot;);                    case &#x27;n&#x27; -&gt; stringBuilder.append(&quot;\\n&quot;);                    case &#x27;b&#x27; -&gt; stringBuilder.append(&quot;\\b&quot;);                    case &#x27;r&#x27; -&gt; stringBuilder.append(&quot;\\r&quot;);                    case &#x27;&quot;&#x27; -&gt; stringBuilder.append(&quot;\\&quot;&quot;);                    case &#x27;/&#x27; -&gt; stringBuilder.append(&quot;/&quot;);                    case &#x27;\\\\&#x27; -&gt; stringBuilder.append(&quot;\\\\&quot;);                    case &#x27;u&#x27; -&gt; &#123;//处理特殊的unicode转义                        if (index + 4 &gt;= json.length()) &#123;                            throw new RuntimeException(&quot;Unexpected unicode sequence at index &quot; + index);                        &#125;                        stringBuilder.append((char) Integer.parseInt(json.substring(index+1, index + 4), 16));                        index += 4;                    &#125;                    default -&gt; throw new RuntimeException(&quot;Unexpected character &#x27;&quot; + c + &quot;&#x27; at index &quot; + index);                &#125;                index++;//跳过被转义的字符            &#125; else &#123;                stringBuilder.append(json.charAt(index));                index++;            &#125;        &#125;        index++;//跳过字符串末尾的引号        return stringBuilder.toString();    &#125;    private Number parseNumber() &#123;        skipWhiteSpace();        int start = index;        if(json.charAt(index)==&#x27;-&#x27;)&#123;            index++;        &#125;        while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index))) &#123;index++;&#125;        if(json.charAt(index)==&#x27;.&#x27;)&#123;//处理浮点数            do &#123;                index++;            &#125; while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index)));        &#125;        if(json.charAt(index)==&#x27;e&#x27; || json.charAt(index)==&#x27;E&#x27;)&#123;//处理科学计数法            do &#123;                index++;            &#125; while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index)));        &#125;        String number = json.substring(start,index);//返回解析得到的数字        if(number.contains(&quot;e&quot;) || number.contains(&quot;E&quot;) || number.contains(&quot;.&quot;))&#123;            return Double.parseDouble(number);        &#125;else &#123;            try &#123;            return Integer.parseInt(number);            &#125;catch (NumberFormatException e)&#123;                return Long.parseLong(number);            &#125;        &#125;    &#125;    public List&lt;Object&gt; parseArray() &#123;        skipWhiteSpace();        List&lt;Object&gt; list = new ArrayList&lt;&gt;();        expectString(&quot;[&quot;);        index++;        skipWhiteSpace();        while (json.charAt(index) != &#x27;]&#x27;) &#123;            skipWhiteSpace();            list.add(parseValue());            if(json.charAt(index)!=&#x27;]&#x27;)&#123;index++;&#125;//用于跳过数组元素之间的逗号        &#125;        index++;//跳过]        return list;    &#125;    private boolean parseFalse() &#123;        expectString(&quot;false&quot;);        index+=5;        return false;    &#125;    private boolean parseTrue()&#123;        expectString(&quot;true&quot;);        index+=4;        return true;    &#125;    private Object parseNull() &#123;        expectString(&quot;null&quot;);        index+=4;        return null;    &#125;    public static void main(String[] args) &#123;        String json = &quot;&#123;\\&quot;greeting\\&quot;:\\&quot;你好，世界！\\&quot;,\\&quot;farewell\\&quot;:\\&quot;再见，朋友！\\&quot;&#125;&quot;;        JsonParser parser = new JsonParser(json);        Object value = parser.parseValue();        System.out.println(value);    &#125;&#125;\n\n感觉如何？如果能够理清所有的逻辑，自己独立写一个还是比较简单的，毕竟也就不到200行的代码量。当然，这个解析器从效率上来将肯定没有办法和一些主流的库比，但不管怎么说，这玩意能用了。\n建议去找ai写几个测试用例试一试（要求不要进行格式化），这个解析器其实只考虑了一些基本情况，你可以试着补足\n查询支持在完成解析后，我们肯定要做一下查询的支持，这样才能方便我们下一步与框架的继承，其实有上面的基础，这一步非常简单，基本的思路如下\npublic class JSON &#123;    private final Map&lt;String,Object&gt; jsonMap;    public JSON(String json) &#123;        JsonParser jp = new JsonParser(json);        Object ret = jp.parseValue();        if(!(ret instanceof Map))&#123;            throw new RuntimeException(&quot;JSON parsing failed&quot;);        &#125;        this.jsonMap = (Map&lt;String, Object&gt;) ret;    &#125;    // 新增查询方法    public List&lt;Object&gt; query(String path) &#123;        List&lt;Object&gt; result = new ArrayList&lt;&gt;();        String[] keys = path.split(&quot;\\\\.&quot;);        queryRecursive(jsonMap, keys, 0, result);        return result;    &#125;//查询方法//用于递归查询    private void queryRecursive(Object value, String[] keys, int depth, List&lt;Object&gt; result) &#123;        if (depth &gt;= keys.length) &#123;//如果递归深度达到了数组长度，停止递归，将结果保存到list中            result.add(value);            return;        &#125;        String key = keys[depth];        if (value instanceof Map) &#123;//如果是一堆嵌套的map,反复的递归直到指定层数            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) value;            if (map.containsKey(key)) &#123;                queryRecursive(map.get(key), keys, depth + 1, result);            &#125;        &#125; else if (value instanceof List) &#123;            List&lt;Object&gt; list = (List&lt;Object&gt;) value;//如果发现数组类型，遍历数组类型的所有元素            for (Object item : list) &#123;//用于处理数组类型                queryRecursive(item, keys, depth, result);            &#125;        &#125;    &#125;   &#125;\n\n怎么样，写起来也不是非常困难，反正就是不断递归查找。\n当然，这个方法也存在问题，首先，返回的是一个list,使用的时候还要做各种类型转换与遍历。但不管怎么说，这玩意能用了，这就是好事。\n结语今天就到这里了，嘴上说简单，但还是写的头疼，是在写不动了，先就此打住吧，下一期实现一个线程池，再下一期写一个请求转发器，最后再补充一些事务方面的东西，支持一下数据库交互，这套框架就差不多将就这能用了\n\n","tags":["手写Spring"]},{"title":"Java的反射与代理","url":"/2025/04/04/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E4%B8%8E%E4%BB%A3%E7%90%86/","content":"最近比较闲，所以来整点活，让我们从0到1手写一个Spring框架吧（只使用Java SE部分的相关内容，不使用任何依赖），不过在正式开始之前，我们要去了解一些基础知识（如果你确信了解了这些知识，可以直接跳过）。\n我们今天来讲一讲反射与代理相关的知识。\n首先我们从Java的类加载机制讲起\nJava的类加载机制我们都知道对于Java来说万物皆对象，所以你猜猜类是什么？类当然是对象了，所有的类在JVM中都被视为一种特殊的对象：Class对象。我们先反编译出来看一看，下面是这个类的头部\npublic final class Class&lt;T&gt; implements Serializable, GenericDeclaration, Type, AnnotatedElement, TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;, Constable\n\n类的加载流程大致如下\n\nJVM读取.class文件并将字节码转化为二进制数据，依照二进制数据创建一个上面提到的java.lang.Class对象来表示某个特定的类\n进行验证，确保所有的Class对象符合规范，不会危害JVM安全\n开始为对应的静态属性分配内存并设置默认的初始值\n进行解析，为所有的属性，方法添加对应的引用映射，如将类名指向Class对象\n执行类加载操作，调用对应的类加载器进行类的加载\n\n我们可以在Class类中发现Class类的构造方法\nprivate Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) &#123;    this.classLoader = loader;    this.componentType = arrayComponentType;&#125;\n\n其中的ClassLoader就是我们所说的类加载器\nJava 的类加载器采用层次结构，主要包括以下几种：\n\n启动类加载器（Bootstrap ClassLoader）：\n负责加载 Java 核心类库（如 rt.jar 中的类）。\n它是虚拟机的一部分，通常由 C++ 实现，不是 Java 代码。\n没有父类加载器。\n\n\n扩展类加载器（Extension ClassLoader）：\n负责加载 Java 的扩展类库（如 jre/lib/ext 目录下的 JAR 文件）。\n它是 sun.misc.Launcher$ExtClassLoader 的实例，父类加载器是启动类加载器。\n\n\n应用程序类加载器（Application ClassLoader）：\n也称为系统类加载器，负责加载用户类路径（CLASSPATH）指定的类。\n它是 sun.misc.Launcher$AppClassLoader 的实例，父类加载器是扩展类加载器。\n\n\n自定义类加载器：\n用户可以通过继承 java.lang.ClassLoader 类来实现自定义类加载器。\n用于加载特定路径或来源的类。\n\n\n\n我们先来看一看这个默认的类加载器在干什么吧，由于私有方法太多，我这里只贴一些比较关键的内容，首先是一个最为重要的类加载方法\npublic Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    return this.loadClass(name, false);&#125;protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;    synchronized(this.getClassLoadingLock(name)) &#123;        Class&lt;?&gt; c = this.findLoadedClass(name);//这个方法会调用一个通过C++实现方法检测类是否已经被加载        if (c == null) &#123;//如果没有加载则开始加载            long t0 = System.nanoTime();//此处为获取JVM运行时间            try &#123;                if (this.parent != null) &#123;                    c = this.parent.loadClass(name, false);//如果该加载器存在父类则调用父加载器进行加载                &#125; else &#123;                    c = findBootstrapClassOrNull(name);//如果不存在则进行加载 ，这个方法同样是C++实现的                &#125;            &#125; catch (ClassNotFoundException var10) &#123;//如果父加载器加载失败则捕获异常并继续运行            &#125;            if (c == null) &#123;                long t1 = System.nanoTime();                c = this.findClass(name);//这个方法现在实际上是一个空方法，交给子类实现，默认运行到此处时会直接抛异常                PerfCounter.getParentDelegationTime().addTime(t1 - t0);//这些都是用于记录类加载时间的，用于性能优化                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            this.resolveClass(c);//这里是永远不会对外界开放的，不必关心        &#125;        return c;    &#125;&#125;\n\n你会发现这样一个逻辑：一般情况下，总是优先调用父加载器进行加载，这种加载机制被称之为双亲委派机制，原生的所有类加载器都会尽可能的将类加载任务委派给自己的父类的实例，这样做的根本目的是避免一个类被重复加载。\n还有一个比较关键的类加载器方法\nprotected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError     protectionDomain = this.preDefineClass(name, protectionDomain);    String source = this.defineClassSourceLocation(protectionDomain);    Class&lt;?&gt; c = defineClass1(this, name, b, off, len, protectionDomain, source);    this.postDefineClass(c, protectionDomain);    return c;&#125;\n\n这个方法用来将二进制数据转换为类对象，不过很遗憾，这个方法也是C++实现的\n那么这个类加载器在哪里被调用呢，可以简单的认为当某个类第一次被需要时，JVM会尝试调用类加载器来完成加载，这一部分我们在讲解反射部分时会具体的展示。\n我们最后再梳理以下JAVA的类加载机制：当某个类被需要时，JVM将通过类加载器直接加载这个类，这一过程遵循双亲委派机制，加载的结果是一个Class对象\n反射操作接下来我们解释什么是反射。这是我们一般情况下获取对象的方法\nTest test =new Test()\n\n不管怎么改，无论是什么建造者模式，工厂模式等等各种花活，都逃不出在某处new一个对象出来，但是你注意到这样一个问题了吗？Spring的依赖注入是如何实现的，框架的编写者是无法事先得知对象的名称的，又如何获取对象用来注入呢？正是通过反射\n举一个简单的例子，我可以通过这样的方式来构建一个字符串对象\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            String aString =(String) String.class.getConstructor().newInstance();            String bString = (String) Class.forName(&quot;java.lang.String&quot;).getConstructor().newInstance();        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n你看，我全程绝对没有new,哪怕你顺着源码查下去也绝对找不到任何new,这就是创建对象的另一种方式：反射。你或许想不到这有什么用，但是不要着急，我们先来了解以下关于反射的各种使用\n构建对象在知道对象名称时我们可以这样来实现\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Constructor&lt;?&gt; stringConstructor = stringClass.getConstructor();//获得类的构造器        Object string = stringConstructor.newInstance();//使用构造器来完成构造    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n上面的是JDK9之后的写法，如果你使用JDK8,甚至可以直接\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Object string = stringClass.newInstance();    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n我们上面还提到了\nClass&lt;?&gt; intClass =int.class;\n\n这样的方法来获取类对象， class属性是直接来自于Object对象的，所有对象都天然的拥有这个属性。\n当然，对于一个对象，你也可以通过\nString s=&quot;Hello World&quot;;Class&lt;?&gt; c =s.getClass();\n\n这样的方式来获取class对象，在获取类对象后你可以按照上面的流程来获取对象。\n请注意\n\n所有的基本数据类型，基本数据类型的数组类型，基本数据类型的包装类型都拥有独立且唯一的Class对象\n类本身和对应的数组类型是拥有独立的Class对象\n所有的类永远只拥有一个类对象（这一点在必要时是可以被手动打破的）\n\n值得一提的是在利用类对象获取构造器时我们可以主动的选择构造方法，例如对于这个类\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;&#125;\n\n我们可以做一个这样的测试\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);            Constructor&lt;?&gt; constructor1 = clazz.getConstructor();//获取无参构造            Constructor&lt;?&gt; constructor2 = clazz.getConstructor(String.class,int.class);//获取全参构造            Student student1 = (Student) constructor1.newInstance();            Student student2 = (Student) constructor2.newInstance(&quot;aaa&quot;,111);            System.out.println(student1.test());            System.out.println(student2.test());        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n获取对象信息我们可以通过反射来获取一些类的信息\nClass&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);System.out.println(clazz.getSuperclass().getName());//获取父类for(Class&lt;?&gt; c: clazz.getInterfaces())&#123;    System.out.println(clazz.getName());//获取接口&#125;for (Annotation annotation: clazz.getAnnotations())&#123;    System.out.println(annotation.annotationType().getName());&#125;//获取注解\n\n此外，反射还能允许我们做一些比较疯狂的事情，比如访问私有字段，还是上面的Student类，age字段显然是私有的，且不存在任何方法进行访问，真的吗\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Field field = student.getClass().getDeclaredField(&quot;age&quot;);//获取字段            field.setAccessible(true);//强制运行字段访问            System.out.println(field.get(student));//输出0            field.setInt(student, 11);//修改字段值            System.out.println(field.get(student));//输出11        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n实际上哪怕是final字段。只要愿意也是可以修改的(不过JDK9之后禁止了，但仍然可以通过一些方式开启)\n这也意味这个一个问题：Java的一个核心理念：封装被突破了。你不让我访问？这是你能挡得住的？我不但能访问，我还能修改。所以实际上所有的封装实际上来自于程序员之间的君子约定：我们互相约定好这部分只在规定范围内访问，当然如果你非要访问，也没什么办法。\n调用方法我们甚至都已经访问了属性了，怎么能做不到调用方法呢？为了方便解释我们先改一改Student方法\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;    public String test(String s)&#123;        return s+name;    &#125;&#125;\n\n然后直接上\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Method method = student.getClass().getMethod(&quot;test&quot;,String.class);//通过名称与参数类型来获取方法            System.out.println(method.invoke(student,&quot;1&quot;));        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n由于编译时形参无法被保留，我们无法直接通过名称获得\n特别的，如果参数类型为可变参数，可选择\nMethod method = clazz.getDeclaredMethod(&quot;test&quot;, String[].class);\n\n不过对于私有方法，就像final字段一样，默认情况下无法被直接使用，需要在启动时添加\n--add-opens java.base/java.lang=ALL-UNNAMED\n\n来允许所有反射\n实现一个简单的IoC容器有了上面的基础，我们已经可以实现一个简单的Bean管理器了。我们先回忆以下Spring中Bean管理器拥有哪些功能：\n\n扫面并创建所有的Bean\n完成依赖注入\n支持在任何地方提供Bean\n\n我们逐个来完成这些需求，为了方便，我们这里只提供注解形式的注册Bean的方法，先写一个注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Componenet &#123;&#125;\n\n还要写一个用于自动绑定的注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface AutoWired &#123;&#125;\n\n我们尝试搭建一个大概的框架\npublic class MyIocContainer &#123;    private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;();    private List&lt;String&gt; basePackageList =new ArrayList&lt;&gt;();    private final ClassPathLoader classPathLoader = new ClassPathLoader();    public void addBasePackage(String basePackage) &#123;        this.basePackageList.add(basePackage);    &#125;//用于规定扫描路径    public void scanPackage(Class&lt;?&gt; clazz) &#123;//此处模仿Spring,填入Main.class来确定运行位置        if(basePackageList.isEmpty()) &#123;            basePackageList.add(clazz.getPackage().getName());        &#125;        for (String basePackage : basePackageList) &#123;//遍历所有路径加载Bean            try &#123;                loadBean(beanMap, basePackage);            &#125; catch (Exception e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        autoWiring();    &#125;    public Object getBean(String className) &#123;        return beanMap.get(className);    &#125;    private void autoWiring()&#123;        for (Map.Entry&lt;String, Object&gt; entry : beanMap.entrySet()) &#123;            for (Field field : entry.getValue().getClass().getDeclaredFields()) &#123;//遍历所有的Bean完成依赖注入                field.setAccessible(true);                if(!field.isAnnotationPresent(AutoWired.class))&#123;                    continue;                &#125;                if(beanMap.containsKey(field.getType().getName()))&#123;                    try &#123;                        field.set(entry.getValue(),beanMap.get(field.getType().getName()));                    &#125; catch (IllegalAccessException e) &#123;                        throw new RuntimeException(e);                    &#125;                &#125;else &#123;                    throw new RuntimeException(&quot;只能自动绑定已注册的Bean&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n接下来完成加载Bean的方法\nprivate void loadBean(Map&lt;String,Object&gt; beanMap, String packageName) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    URL dir = classLoader.getResource(packageName);//这部分文件的获取实际上使用类路径，这个概念我们下一篇再来研究    packageName = packageName.replace(&#x27;/&#x27;, &#x27;.&#x27;);    if (dir == null) &#123;        return;    &#125;//如果投入的路径不存在，直接返回    File dirFile = new File(dir.getFile());    if (!dirFile.exists() || !dirFile.isDirectory()) &#123;        return;    &#125;//对应的类路径不存在或者不是目录，直接返回    File[] files = dirFile.listFiles();    if (files != null) &#123;        for (File file : files) &#123;            if (file.isDirectory()) &#123;                loadBean(beanMap, packageName.replace(&quot;.&quot;,&quot;/&quot;) + &quot;/&quot; + file.getName());                continue;            &#125;            String className = packageName + &quot;.&quot; + file.getName().replace(&quot;.class&quot;, &quot;&quot;);            Class&lt;?&gt; clazz = classLoader.loadClass(className);            if(clazz.isInterface() || clazz.isAnnotation() || clazz.isEnum() || Modifier.isAbstract(clazz.getModifiers())) &#123;                continue;            &#125;//接口，抽象类和注解都不能使用构造方法构造，直接跳过避免报错            if(clazz.isAnnotationPresent(Componenet.class)) &#123;                Constructor&lt;?&gt; constructor =clazz.getConstructor();                constructor.setAccessible(true);                beanMap.put(className,constructor.newInstance());            &#125;//加载类        &#125;    &#125;&#125;\n\n虽然非常的简陋，但是这个IoC容器在功能上已经和Spring的IoC容器一致了，我们的全部实现只有不到100行代码。不过，这个容器仍然存在很多问题，举个简单的例子，如果有些类中包含一些static属性，这些属性对应的类在加载当前类时并没有被正确的加载，那么报错是必然的，想一想该怎么处理这个问题。此外，如果类足够多，我们是不是需要添加对应的多线程支持，这个类显然没有考虑多线程的情况，该怎么解决？这些问题我先留在，我们将来再解决。\n动态代理是什么所谓的动态代理就是通过反射获取类的相关方法，在执行时代替这个类去执行对应的方法，在这一过程中可以对方法进行一定的修饰\n所以这有什么用？仔细想想，Mybatis是怎么实现的？不就是通过对接口方法的代理吗？Spring的AOP或者说面向切面怎么实现的，不也是通过对类的代理吗？\n如果你想的话可以直接自己手搓一个动态代理机制出来，不过Java毕竟原生提供了动态代理的实现，我们还是直接调用吧，其中的关键是两个类\n\njava.lang.reflect.Proxy：代理类，用于动态创建代理对象。\njava.lang.reflect.InvocationHandler：调用句柄接口，用于处理代理对象的方法调用。\n\n我们写一个简单的例子，这是一个接口\npublic interface Service &#123;    void doSomething();    String test();&#125;\n\n接着完成这个接口的实现\npublic class ServiceImpl implements Service &#123;    public void doSomething() &#123;        System.out.println(&quot;doSomething&quot;);    &#125;    public String test() &#123;        return &quot;test&quot;;    &#125;&#125;\n\n接下来我们完成一个代理类\npublic class MyProxy implements InvocationHandler &#123;    private final Object target;    public MyProxy(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;        System.out.println(&quot;执行前操作&quot;);        Object result = method.invoke(target, objects);        System.out.println(&quot;执行后操作&quot;);        return result;    &#125;    public static Object getProxyInstance(Object target) &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(),//获得类加载器                target.getClass().getInterfaces(),//获得所实现的接口                new MyProxy(target));//提供一个调用句柄    &#125;&#125;\n\n你会发现这个代理类是通用的，接下来我们尝试使用以下代理类\npublic class Main &#123;    public static void main(String[] args) &#123;        Service service1 = new ServiceImpl();        Service service2 = (Service) MyProxy.getProxyInstance(service1);        service1.doSomething();        service2.doSomething();        System.out.println(service1.test());        System.out.println(service2.test());        System.out.println(service1.hashCode());        System.out.println(service2.hashCode());        System.out.println(service1.getClass().getName());        System.out.println(service2.getClass().getName());    &#125;&#125;\n\n运行结果如下\n执行前操作doSomething执行后操作test执行前操作执行后操作test2084435065执行前操作执行后操作2084435065abc.proxy.ServiceImpljdk.proxy1.$Proxy0\n\n在我不解释的情况下你是否能理解为什么会出现这样的输出结果呢，我们分段来看\n首先是前四行输出，无代理的对象直接输出，有代理的对象按照我们所规定的操作顺序来处理\n接着看5到8行，执行顺序变了吗？并没有，只不过在受到代理的对象中，调用任何一个方法本质上都是通过我们重写的invoke方法来实现的，控制台输出在Invoke方法执行完毕后才得到了要输出的结果\n再来看一看这个8到11行，不是说会产生新的代理类吗，那么为什么哈希是相同的，有点诡异。\n再看一看12和13行，类名不一样，是符合我们预期的，不过还有一个问题，这次从结果上看居然没有被代理？这是什么情况？原因实际上非常简单，如果粗暴的将所有的方法代理，那么区分代理类与原来的类就成了一件麻烦的事情，所以这个方法并没有被代理。\n实现一个简单的AOP框架我们可以使用动态代理来实现一个简单的AOP框架，不过很遗憾我们现有的知识是不足以让我们完整的实现Spring的AOP能力的，JDK的动态代理只做到了类一级，不能精细的对方法进行控制，这种能力需要对特定的字节码进行操作，所以我们还是暂时不讲了。\n不过简单的类级别的AOP框架还是很容易实现的，我们试着写一个吧，为了方便，我们这里只考虑三种情况：执行前，执行后，抛出异常时。我们将这三种情况规范为对应的接口\npublic interface BeforeExecution &#123;    void before(Object[] objects) throws Throwable;&#125;public interface BeforeExecution &#123;    void before(Object[] objects) throws Throwable;&#125;public interface ThrowException &#123;    void throwException(Object[] objects，Throwable throwable) throws Throwable;&#125;//这里的objects实际上是方法的参数，使用者可以利用这些参数\n\n然后考虑创建对应的代理类，我随便写一个可能的例子\npublic class ProxyFactory  &#123;    private static final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    private static AfterExecution afterExecution = null;    private static ThrowException throwException = null;    private static BeforeExecution beforeExecution = null;    private static boolean isClean=true;    public static void setAfterExecution(AfterExecution afterExecution) &#123;        ProxyFactory.afterExecution = afterExecution;    &#125;    public static void setThrowException(ThrowException throwException) &#123;        ProxyFactory.throwException = throwException;    &#125;    public static void setBeforeExecution(BeforeExecution beforeExecution) &#123;        ProxyFactory.beforeExecution = beforeExecution;    &#125;    private static Object getProxy0(Object target,InvocationHandler invocationHandler) throws Throwable &#123;        return Proxy.newProxyInstance(classLoader, target.getClass().getInterfaces(), invocationHandler);    &#125;    public static Object getProxy(Object target) throws Throwable &#123;        if(!isClean) &#123;            throw new RuntimeException(&quot;使用后未复位&quot;);        &#125;else&#123;            isClean=false;        &#125;        //这里其实采用的是装饰模式的思想，不断的对原来的类进行装饰最终得到我们想要的对象        if (beforeExecution != null) &#123;            target = getProxy0(target, (o, method, objects) -&gt; &#123;                beforeExecution.before(objects);                return method.invoke(o, objects);            &#125;);        &#125;        if (afterExecution != null) &#123;            target =getProxy0(target,(o,method,objects)-&gt;&#123;                Object result = method.invoke(o, objects);                afterExecution.afterExecution(objects);                return result;            &#125;);        &#125;        if (throwException != null) &#123;            target =getProxy0(target,(o,method,objects)-&gt;&#123;                Object result = null;                try &#123;                    result = method.invoke(o, objects);                &#125;catch (Throwable throwable) &#123;                    throwException.throwException(objects ,throwable);                &#125;                return result;            &#125;);        &#125;        return target;    &#125;    public static void clean() &#123;//这是一个复位方法，避免产生不必要的代理        isClean=true;        afterExecution=null;        throwException=null;        beforeExecution=null;    &#125;&#125;\n\n结语这部分的知识就讲到这里，我们下一篇将会探讨关于文件处理相关的问题，顺路继续优化我们的IoC容器\n\n","tags":["手写Spring"]}]