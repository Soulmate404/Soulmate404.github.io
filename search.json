[{"title":"Docker入门","url":"/2025/04/01/Docker%E5%85%A5%E9%97%A8/","content":"最近忙着写项目，好久没更新内容了。而且就在昨天，重装系统的时候我居然忘了把博客的本地文件保存一份！！！现在我已经失去了前面博客的所有内容，不得不花费大量时间重新把前面的内容整理一次，孩子心里苦啊。\n闲话就聊到这里,今天我们来了解一下Docker技术.Docker可以帮助我们快速的实现项目依赖环境的完整打包.方便我们将项目快速的部署到不同的设备上去.\n由于Windows上没有原生的Docker,想要运行需要套几层壳,所以这次我们使用Ubuntu.具体版本为Ubuntu24.04.(当然现在有了WSL2，其实在windows上也不是很麻烦，直接去官网https://www.docker.com/下载即可)\nDocker的安装我们首先来完场Docker的安装.这部分比较简单,先安装一些依赖\nsudo apt-get install ca-certificates curl gnupg lsb-release\n\n然后安装官方的GPG Key\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n然后将Docker的下载地址放到apt的搜索列表中\necho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n接着更新一下列表\nsudo apt update\n\n接着下载Docker的社区版本（Docker分为社区版和商业版）\nsudo apt install docker-ce\n\n可以通过\ndocker --version\n\n来判断是否下载成功\n\nDocker的配置到此完成，我们接下来详细的了解一下Docker的结构\n容器与镜像容器与虚拟机的区别在开始这一板块之前，我们先来思考一个问题：假设我现在使用的是Ubuntu22.04,然后下载一个Ubuntu24.04的Docker，那么我是否能使用Ubuntu24.04的全部功能呢？这个问题在虚拟机上是显然的，但是在Docker中却不那么肯定。\n我们可以看一下这张图：\n\n这张图体现了虚拟机和Docker的重要区别：虚拟机的虚拟是内核级别的，所有的虚拟机相互独立，互不干扰。但是，所有的Docker共用设备的内核空间，只拥有独立的用户空间。也就是说，如果ubuntu22.04的内核支持相关功能，我们是可以顺利使用的，但如果内核不知相关功能，我们就无能为力了。\n此外，还有一点值得注意：容器与镜像的区别。\n直接构建了解了这些，我们开始尝试自己构建一个镜像，每一个应用都运行在操作系统上，所以构建自己的镜像也必须基于最基本的系统镜像，我们一般称这些镜像为Base镜像（当然，在很多时候我们也不一定真的从最基本的镜像开始构建，而是使用一些已经安装了一些必要的环境的镜像开始构建）。我们这里尝试去构建一个包含了jdk的ubuntu镜像\n首先我们拉取一个ubuntu的Base镜像(最近由于DockerHub的限制，很多镜像源都不能用了，如果下载不下来，请自行寻找合适的镜像源或者科学上网)\ndocker pull ubuntu:22.04\n\n这里注意，一个镜像的标准名称通常为name:tag的格式，name用来说明名称，tag用来说明版本\n下载完成后可以通过\ndocker images\n\n来查看当前的所有镜像\n\n可以看到，刚刚下载的Ubuntu镜像小的惊人，只有77.9MB,这是因为作为Base镜像，只保留了最基本的用户空间运行能力，我们平时很多常用的命令都是无法在这个镜像中执行的。\n接下来在容器中运行这个镜像\ndocker run -it ubuntu:22.04\n\n其中i参数指创建一个标准的输入输出接口，t参数指创建一个虚拟的tty设备来作为终端供我们使用，这两个参数一般同时使用，效果如下：\n我们已经进入了基于ubuntu镜像创建的容器的内部\n我们的目的是构建一个包含jdk的ubuntu镜像，所以现在执行下列命令\napt update &amp;&amp; apt install -y openjdk-21-jdk\n\n下载完成后可以使用exit直接退出\n现在查看以下我们的容器\ndocker ps -a\n\n如果不使用a参数则只显示处于运行状态下的容器\n\n接下来执行\ndocker commit 容器ID/名称 新的镜像名\n\nDocker中所有可以使用id的地方都可以使用ID的一部部分，只要能保证具有唯一性就好，例如我们可以在此处使用\ndocker commit fd jdk:21\n\n看一看结果\n\n注意到经过我们的一番操作后镜像的体积发生了巨大的膨胀，这是因为我们在下载jdk时不但下载了jdk,还下载了jdk运行时必要的操作系统依赖。\n对于已经存在的镜像，我们可以\ndocker start name/id #启动现有的镜像docker stop name/id #停止正在运行的镜像\n\n我们可以使用这种方法去构建任何镜像，但这种镜像的构建存在一个问题：不够透明。除你之外没有人知道这个镜像是如何被构建的，对个人使用来说，这种构建方式显然是无所谓的，但是如果这个镜像是面向其他人的，我们就不应该这么做，我们需要使用Dockerfile来完成构建\n通过Dockerfile构建在开始之前我们先删除之前创造的镜像与容器\ndocker rmi 镜像ID #删除镜像docker rm 容器ID #删除容器\n\n同样的，只要输入ID的开头，确保唯一性即可\n接下来我们创建一个名为Dockerfile的文件，并写入如下的内容\nFROM ubuntu:22.04RUN apt update &amp;&amp; apt install -y openjdk-21-jdk\n\n在该文件目录下执行\ndocker build -t jdk:21 .\n\n就能得到和我们之前所构建的jdk镜像完全相同的镜像了\n下面我展示一些在Dockerfile中常使用的命令\nFROM &lt;基础镜像&gt; #从对应的基础镜像开始构建LABEL xxx=xx #给镜像添加元数据，一般用来标识作者，版本等信息ARG xxx=xx #创建一个名为xxx的参数，其值为xx,为此后调用这个值提供方便RUN xxx #在基础镜像内执行xxxCOPY /xx /xxx #将/xx目录下的内容复制到镜像的/xxx目录下ADD https://example.com/file.tar.gz /app/ #与COPY类似，但支持远程下载WORKDIR /xx #设置容器启动时将自动跳转到容器内的/xx目录下ENV xxx=xx #为镜像添加一个名称为xxx的环境变量，其值为xxEXPOSEE xxx #对外暴露容器的xxx端口VOLUME /xx #在容器的/xx目录下创建一个挂载点用于数据持久化，这点我们后面再解释ENTRYPOINT xxx #在容器启动时自动执行xxx,优先级高于CMDCMD xxx #在容器启动时自动执行xxx\n\n当然，这并不是全部的命令，但大多数时候对我们来说已经够用了\n在这部分的最后，让我们了解一下如何将我们所创建的镜像推送到DockerHub，首先自行到Dockerhub创建一个仓库\n\n接下来我们将我们之前的镜像重新命名后推送\ndocker tag jdk:21 myjdk:21docker push 你的用户名/myjdk:21\n\n根据规范，我们必须在推送时添加自己的用户名来保证推送到属于我们自己的仓库，在拉取时同样采用\ndocker pull 你的用户名/myjdk:21\n\n的格式来确保获得正确的镜像\n这一步操作如果网络环境好可以试一试，毕竟一次性要上传800MB,在当前网络环境下有时候会比较困难\nDocker网络管理接下来我们来了解一下Docker的网络管理，我们执行如下的命令\ndocker network ls\n\n\n我们可以看到当前总共有三个网路，这三个网络是Docker在下载时就帮我们创建的，分别对应Docker支持的三种网络类型bridge null host\n我们首先来看看null网络，这个网络中只有一个本地环路，与宿主机的网络环境相互隔离，无法通过网络访问，用于部分有特殊安全需求的环境。如果想使用null网络，可以使用\ndocker run --network=none jdk:21\n\n然后是host网络，如果容器使用的是这种网络，相当于直接使用宿主机的网络环境，在这种网络下，我们，容器中的网络配置与宿主保持一致，不需要镜像额外的开放端口等操作。在这种模式下，网络通信的损失是最小的.如果想使用我们\n最后是bridge网络，或者说是桥接网络，你可以简单的理解为在宿主机上创建了一个虚拟的局域网，宿主机与容器都是这个虚拟局域网的一台设备，不同设备之间通过这个局域网进行信息交互。这也是所有容器的默认网络模式。在这种模式下，我们前面的在Dockerfile中主动暴露端口的行为就有了意义，举个简单的例子\ndocker run -p 1234:80 -n test jdk:21\n\n这里我使用了两个参数，p参数用来指定端口映射，将宿主机的1234端口映射到容器的80端口，此时对宿主机1234端口的访问就会通过桥接网络转发到容器的80端口。n参数是给容器命名的，我们之前所创建的容器起名称都是docker随即生产的，我们可以通过这个参数手动指定。\n在这里你可能会问，那我们之前在Dockerfile中提到的EXPOSE指令又有什么作用呢？这个指令更多的起到提醒作用，用于提醒用户需要将这个端口映射到宿主机中\n我们也可以创建自己的网络，例如这样\ndocker network creat --driver bridge test\n\n这样我们就创建了一个名为test的桥接网络，我们在启动时可以手动指定使用的网络\ndocker run --network=test image\n\n注意，虽然都是使用桥接网络，但是test网络与bridge网络两个网络是互相隔离的，无法互相进行通信，当然，我们也可以主动进行连接\ndocker network connect test containerID/name\n\n此时容器就被主动的连接到了test网络\n容器数据持久化还记得我们上面提到的volume指令吗？对于一个一般的容器，在停止运行时所有运行时产生的数据都将被删除，这无疑是我们所不想看到的，所以我们可以使用VOLUME指令创建挂载点，此时docker会产生一个匿名卷来存储doker对应目录下的数据，这个匿名卷在宿主机上的路径一般为/var/lib/docker/volumes，不过我们可以选择进一步的定制化一些，我们可以将容器的数据挂载到宿主机的指定路径下，使用\ndocker run -v /host/path:/container/path image\n\n此时会将容器的&#x2F;container&#x2F;path与宿主机的&#x2F;host&#x2F;path相互绑定，宿主机与容器任何一方对数据的修改都会在另一方体现\n如果我们使用v参数但不指定宿主机路径，则会在宿主机上自动创建对应路径\n如果我们想要在多个容器之间共享数据呢，聪明的你一定想到创建一个公共目录，经所有容器都挂载到对应的目录。但是我们还有别的办法：直接将一个容器的路径挂载到另一个容器\ndocker run -p 80:80 --volumes-from=data_test test\n\n此时test继承了data_test的挂载信息，在总体容器数量比较多时我们通常会创建一个专门的容器用来管理数据（被称为数据卷容器），例如上面的data_test,所有的容器再继承其挂载方式\nDocker容器管理接下来我们来聊一聊对运行状态下的容器的管理，有以下常用的命令\ndocker log 容器名/ID\n\n可以用来输出容器中的控制台信息（f参数可用来保持持续输出）\ndocker attach 容器ID/名称\n\n直接进入某个运行的容器的内部，注意在完成操作后先按Ctrl+P再按Ctrl+Q退出，千万不要按Ctrl+C这会导致容器停止运行\ndocker exec -it 容器ID/名称\n\n为容器创建一个新的bash终端，如果容器中运行的项目会不断的对控制台输出信息，那么可以通过这个指令开启一个新的终端来对容器进行操作\ndocker stats\n\n用于查看所有容器的状态\ndocker top 容器ID/名称\n\n查看某个容器的所有进程信息\n接下来是几个比较不推荐的\ndocker kill 容器ID/名称 #强制终止容器docker pause 容器ID/名称 #暂停容器docker unpause 容器ID/名称 #与上一条相反\n\n其实还有很多操作，但是这些操作都是偏运维向的，这里就不做介绍了\n常用参数介绍注意，docker非常重视灵活性，所有在dockefile中规定的东西都可以被在启动时覆盖，实际的覆盖操作使用以下这些参数\n\n\n\n参数\n描述\n示例\n\n\n\n-d\n后台运行容器\ndocker run -d IMAGE\n\n\n-it\n交互式终端，-i 保持标准输入打开，-t 分配一个伪终端\ndocker run -it IMAGE\n\n\n--name\n为容器指定一个名称\ndocker run --name mycontainer -d IMAGE\n\n\n-p\n端口映射，格式为 主机端口:容器端口\ndocker run -p 8080:80 -d IMAGE\n\n\n-v\n数据卷映射，格式为 主机路径:容器路径[:权限]\ndocker run -v /host/path:/container/path -d IMAGE\n\n\n--env 或 -e\n设置环境变量\ndocker run --env MY_VAR=value -d IMAGE\n\n\n--network\n将容器连接到指定的 Docker 网络\ndocker run --network mynetwork -d IMAGE\n\n\n--restart\n设置容器的重启策略，可选值为 no、on-failure、always、unless-stopped\ndocker run --restart always -d IMAGE\n\n\n--link\n将容器连接到另一个容器\ndocker run --link other-container:alias -d IMAGE\n\n\n--cpus\n限制容器使用的 CPU 资源\ndocker run --cpus=&quot;1.5&quot; -d IMAGE\n\n\n--memory\n限制容器使用的内存\ndocker run --memory=&quot;256m&quot; -d IMAGE\n\n\n--gpus\n指定容器可以访问的 GPU 设备\ndocker run --gpus all -d IMAGE\n\n\n--log-driver\n指定日志驱动\ndocker run --log-driver=syslog -d IMAGE\n\n\n--health-cmd\n配置容器的健康检查命令\n&#96;docker run –health-cmd&#x3D;”curl -f http://localhost/\n\n\n--user\n指定容器内进程的用户\ndocker run --user username -d IMAGE\n\n\n--security-opt\n设置 SELinux 或 AppArmor 配置\ndocker run --security-opt seccomp=unconfined -d IMAGE\n\n\n--cap-add\n添加容器的 Linux 能力\ndocker run --cap-add=SYS_ADMIN -d IMAGE\n\n\n--cap-drop\n删除容器的 Linux 能力\ndocker run --cap-drop=SYS_ADMIN -d IMAGE\n\n\n--privileged\n给容器赋予特权，可以访问主机的设备\ndocker run --privileged -d IMAGE\n\n\n--tmpfs\n在容器内创建临时文件系统\ndocker run --tmpfs /tmp -d IMAGE\n\n\n--ulimit\n设置容器的资源限制，如最大打开文件数、最大进程数等\ndocker run --ulimit nofile=1024:1024 -d IMAGE\n\n\n--hostname\n设置容器的主机名\ndocker run --hostname my_container -d IMAGE\n\n\n--dns\n指定容器使用的自定义 DNS 服务器\ndocker run --dns 8.8.8.8 -d IMAGE\n\n\n--dns-search\n指定容器的 DNS 域\ndocker run --dns-search example.com -d IMAGE\n\n\n--entrypoint\n覆盖镜像的默认入口点\ndocker run --entrypoint /custom_entrypoint -d IMAGE\n\n\n--rm\n容器退出时自动删除容器\ndocker run --rm -d IMAGE\n\n\n--mount\n更详细的挂载配置，支持类型 bind、volume、tmpfs\ndocker run --mount type=bind,source=/data,target=/app/data -d IMAGE\n\n\n--shm-size\n设置容器的共享内存大小\ndocker run --shm-size 2g -d IMAGE\n\n\n--volume-driver\n指定容器使用的卷驱动程序\ndocker run --volume-driver my_driver -d IMAGE\n\n\n--env-file\n从文件读取环境变量\ndocker run --env-file=env.list -d IMAGE\n\n\n--label\n为容器添加元数据标签\ndocker run --label &quot;env=prod&quot; -d IMAGE\n\n\n需要特别说明的是ENTRYPOINT可以通过--entrypoint  覆盖，而CMD指令可以通过类似\ndocker run my_image echo &quot;Hello, World!&quot;\n\n这样原来的CMD命令将会被覆盖，如果需要的命令过于复杂，你还可以这样\ndocker run my_image &lt; cmd.sh\n\n直接编写一份完整的脚本然后导入\n结语如果你之前来过我的站，你可能会发现所有的之前的文章都已经消失了，由于某次出人意料的事故，所有之前写下的文章都美丽，悲～～～。所以只好从零开始了，有很多东西确实比较有用，有空的话我会尽力再尝试写一份的\n\n","tags":["杂谈"]},{"title":"Java的反射与代理","url":"/2025/04/04/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E4%B8%8E%E4%BB%A3%E7%90%86/","content":"最近比较闲，所以来整点活，让我们从0到1手写一个Spring框架吧（只使用Java SE部分的相关内容，不使用任何依赖），不过在正式开始之前，我们要去了解一些基础知识（如果你确信了解了这些知识，可以直接跳过）。\n我们今天来讲一讲反射与代理相关的知识。\n首先我们从Java的类加载机制讲起\nJava的类加载机制我们都知道对于Java来说万物皆对象，所以你猜猜类是什么？类当然是对象了，所有的类在JVM中都被视为一种特殊的对象：Class对象。我们先反编译出来看一看，下面是这个类的头部\npublic final class Class&lt;T&gt; implements Serializable, GenericDeclaration, Type, AnnotatedElement, TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;, Constable\n\n类的加载流程大致如下\n\nJVM读取.class文件并将字节码转化为二进制数据，依照二进制数据创建一个上面提到的java.lang.Class对象来表示某个特定的类\n进行验证，确保所有的Class对象符合规范，不会危害JVM安全\n开始为对应的静态属性分配内存并设置默认的初始值\n进行解析，为所有的属性，方法添加对应的引用映射，如将类名指向Class对象\n执行类加载操作，调用对应的类加载器进行类的加载\n\n我们可以在Class类中发现Class类的构造方法\nprivate Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) &#123;    this.classLoader = loader;    this.componentType = arrayComponentType;&#125;\n\n其中的ClassLoader就是我们所说的类加载器\nJava 的类加载器采用层次结构，主要包括以下几种：\n\n启动类加载器（Bootstrap ClassLoader）：\n负责加载 Java 核心类库（如 rt.jar 中的类）。\n它是虚拟机的一部分，通常由 C++ 实现，不是 Java 代码。\n没有父类加载器。\n\n\n扩展类加载器（Extension ClassLoader）：\n负责加载 Java 的扩展类库（如 jre/lib/ext 目录下的 JAR 文件）。\n它是 sun.misc.Launcher$ExtClassLoader 的实例，父类加载器是启动类加载器。\n\n\n应用程序类加载器（Application ClassLoader）：\n也称为系统类加载器，负责加载用户类路径（CLASSPATH）指定的类。\n它是 sun.misc.Launcher$AppClassLoader 的实例，父类加载器是扩展类加载器。\n\n\n自定义类加载器：\n用户可以通过继承 java.lang.ClassLoader 类来实现自定义类加载器。\n用于加载特定路径或来源的类。\n\n\n\n我们先来看一看这个默认的类加载器在干什么吧，由于私有方法太多，我这里只贴一些比较关键的内容，首先是一个最为重要的类加载方法\npublic Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    return this.loadClass(name, false);&#125;protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;    synchronized(this.getClassLoadingLock(name)) &#123;        Class&lt;?&gt; c = this.findLoadedClass(name);//这个方法会调用一个通过C++实现方法检测类是否已经被加载        if (c == null) &#123;//如果没有加载则开始加载            long t0 = System.nanoTime();//此处为获取JVM运行时间            try &#123;                if (this.parent != null) &#123;                    c = this.parent.loadClass(name, false);//如果该加载器存在父类则调用父加载器进行加载                &#125; else &#123;                    c = findBootstrapClassOrNull(name);//如果不存在则进行加载 ，这个方法同样是C++实现的                &#125;            &#125; catch (ClassNotFoundException var10) &#123;//如果父加载器加载失败则捕获异常并继续运行            &#125;            if (c == null) &#123;                long t1 = System.nanoTime();                c = this.findClass(name);//这个方法现在实际上是一个空方法，交给子类实现，默认运行到此处时会直接抛异常                PerfCounter.getParentDelegationTime().addTime(t1 - t0);//这些都是用于记录类加载时间的，用于性能优化                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            this.resolveClass(c);//这里是永远不会对外界开放的，不必关心        &#125;        return c;    &#125;&#125;\n\n你会发现这样一个逻辑：一般情况下，总是优先调用父加载器进行加载，这种加载机制被称之为双亲委派机制，原生的所有类加载器都会尽可能的将类加载任务委派给自己的父类的实例，这样做的根本目的是避免一个类被重复加载。\n还有一个比较关键的类加载器方法\nprotected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError     protectionDomain = this.preDefineClass(name, protectionDomain);    String source = this.defineClassSourceLocation(protectionDomain);    Class&lt;?&gt; c = defineClass1(this, name, b, off, len, protectionDomain, source);    this.postDefineClass(c, protectionDomain);    return c;&#125;\n\n这个方法用来将二进制数据转换为类对象，不过很遗憾，这个方法也是C++实现的\n那么这个类加载器在哪里被调用呢，可以简单的认为当某个类第一次被需要时，JVM会尝试调用类加载器来完成加载，这一部分我们在讲解反射部分时会具体的展示。\n我们最后再梳理以下JAVA的类加载机制：当某个类被需要时，JVM将通过类加载器直接加载这个类，这一过程遵循双亲委派机制，加载的结果是一个Class对象\n反射操作接下来我们解释什么是反射。这是我们一般情况下获取对象的方法\nTest test =new Test()\n\n不管怎么改，无论是什么建造者模式，工厂模式等等各种花活，都逃不出在某处new一个对象出来，但是你注意到这样一个问题了吗？Spring的依赖注入是如何实现的，框架的编写者是无法事先得知对象的名称的，又如何获取对象用来注入呢？正是通过反射\n举一个简单的例子，我可以通过这样的方式来构建一个字符串对象\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            String aString =(String) String.class.getConstructor().newInstance();            String bString = (String) Class.forName(&quot;java.lang.String&quot;).getConstructor().newInstance();        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n你看，我全程绝对没有new,哪怕你顺着源码查下去也绝对找不到任何new,这就是创建对象的另一种方式：反射。你或许想不到这有什么用，但是不要着急，我们先来了解以下关于反射的各种使用\n构建对象在知道对象名称时我们可以这样来实现\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Constructor&lt;?&gt; stringConstructor = stringClass.getConstructor();//获得类的构造器        Object string = stringConstructor.newInstance();//使用构造器来完成构造    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n上面的是JDK9之后的写法，如果你使用JDK8,甚至可以直接\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Object string = stringClass.newInstance();    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n我们上面还提到了\nClass&lt;?&gt; intClass =int.class;\n\n这样的方法来获取类对象， class属性是直接来自于Object对象的，所有对象都天然的拥有这个属性。\n当然，对于一个对象，你也可以通过\nString s=&quot;Hello World&quot;;Class&lt;?&gt; c =s.getClass();\n\n这样的方式来获取class对象，在获取类对象后你可以按照上面的流程来获取对象。\n请注意\n\n所有的基本数据类型，基本数据类型的数组类型，基本数据类型的包装类型都拥有独立且唯一的Class对象\n类本身和对应的数组类型是拥有独立的Class对象\n所有的类永远只拥有一个类对象（这一点在必要时是可以被手动打破的）\n\n值得一提的是在利用类对象获取构造器时我们可以主动的选择构造方法，例如对于这个类\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;&#125;\n\n我们可以做一个这样的测试\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);            Constructor&lt;?&gt; constructor1 = clazz.getConstructor();//获取无参构造            Constructor&lt;?&gt; constructor2 = clazz.getConstructor(String.class,int.class);//获取全参构造            Student student1 = (Student) constructor1.newInstance();            Student student2 = (Student) constructor2.newInstance(&quot;aaa&quot;,111);            System.out.println(student1.test());            System.out.println(student2.test());        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n获取对象信息我们可以通过反射来获取一些类的信息\nClass&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);System.out.println(clazz.getSuperclass().getName());//获取父类for(Class&lt;?&gt; c: clazz.getInterfaces())&#123;    System.out.println(clazz.getName());//获取接口&#125;for (Annotation annotation: clazz.getAnnotations())&#123;    System.out.println(annotation.annotationType().getName());&#125;//获取注解\n\n此外，反射还能允许我们做一些比较疯狂的事情，比如访问私有字段，还是上面的Student类，age字段显然是私有的，且不存在任何方法进行访问，真的吗\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Field field = student.getClass().getDeclaredField(&quot;age&quot;);//获取字段            field.setAccessible(true);//强制运行字段访问            System.out.println(field.get(student));//输出0            field.setInt(student, 11);//修改字段值            System.out.println(field.get(student));//输出11        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n实际上哪怕是final字段。只要愿意也是可以修改的(不过JDK9之后禁止了，但仍然可以通过一些方式开启)\n这也意味这个一个问题：Java的一个核心理念：封装被突破了。你不让我访问？这是你能挡得住的？我不但能访问，我还能修改。所以实际上所有的封装实际上来自于程序员之间的君子约定：我们互相约定好这部分只在规定范围内访问，当然如果你非要访问，也没什么办法。\n调用方法我们甚至都已经访问了属性了，怎么能做不到调用方法呢？为了方便解释我们先改一改Student方法\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;    public String test(String s)&#123;        return s+name;    &#125;&#125;\n\n然后直接上\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Method method = student.getClass().getMethod(&quot;test&quot;,String.class);//通过名称与参数类型来获取方法            System.out.println(method.invoke(student,&quot;1&quot;));        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n由于编译时形参无法被保留，我们无法直接通过名称获得\n特别的，如果参数类型为可变参数，可选择\nMethod method = clazz.getDeclaredMethod(&quot;test&quot;, String[].class);\n\n不过对于私有方法，就像final字段一样，默认情况下无法被直接使用，需要在启动时添加\n--add-opens java.base/java.lang=ALL-UNNAMED\n\n来允许所有反射\n实现一个简单的Bean管理器有了上面的基础，我们已经可以实现一个简单的Bean管理器了。我们先回忆以下Spring中Bean管理器拥有哪些功能：\n\n扫面并创建所有的Bean\n完成依赖注入\n支持在任何地方提供Bean\n\n我们逐个来完成这些需求，为了方便，我们这里只提供注解形式的注册Bean的方法，先写一个注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Componenet &#123;&#125;\n\n凡是存在这个注解的类都需要被注册为Bean，接下来完成扫描的方法\npublic class MyIocContainer &#123;    private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;();//用来存储注册的Bean    private List&lt;String&gt; basePackageList;//要扫描的包路径    private final ClassLoader classLoader = MyIocContainer.class.getClassLoader();//随便弄一个类加载器    public void addBasePackage(String basePackage) &#123;        this.basePackageList.add(basePackage);    &#125;//添加要扫描的包    public void scanPackage(Class&lt;?&gt; clazz) &#123;//参考Spring框架，此处实际上需要填入主类        String packageName = clazz.getPackage().getName();//获取主类的包，默认状态下选择扫描主类的包        if(this.basePackageList.isEmpty())&#123;//如果没有主动修改，对主类所在的包扫描            basePackageList.add(packageName);        &#125;        for (String basePackage : basePackageList) &#123;            String classPath = basePackage.replace(&quot;.&quot;,&quot;/&quot;);//将包名称替换为实际的路径名            Path path = Paths.get(classPath);            File files = path.toFile();            loadBean(basePackage,files);//开始加载Bean        &#125;    &#125;    private void loadBean(String basePackage,File file) &#123;        if (!file.isDirectory()) &#123;return;&#125;//如果传入的不是一个文件夹，显然出现了错误，直接返回        File[] files = file.listFiles();        if (files == null) &#123;return;&#125;//如果是一个空目录，那么同样直接返回        for (File file2 : files) &#123;            if (file2.isDirectory()) &#123;loadBean(basePackage+&quot;.&quot;+file2.getName(),file2);&#125;//如果存在多级目录，递归扫描            if (file2.getName().endsWith(&quot;.class&quot;)) &#123;//确认是类文件                String className = basePackage + &quot;.&quot; + file2.getName().replace(&quot;.class&quot;, &quot;&quot;);                //得到正确的完整类名                try &#123;                    Class&lt;?&gt; c = classLoader.loadClass(className);//先加载类                    if(c.isAnnotationPresent(Componenet.class))&#123;//如果包含我们提前约定的注解，进行注册                        Constructor&lt;?&gt; constructor = c.getConstructor();                        constructor.setAccessible(true);                        Object instance = constructor.newInstance();                        beanMap.put(className, instance);                    &#125;                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;    &#125;&#125;\n\n接下来我们再添加一个用于依赖注入的方法，不过我们首先要约定一个用于声明依赖注入的注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface AutoWired &#123;&#125;\n\n然后完成自动绑定方法\nprivate void autoWiring()&#123;    for (Map.Entry&lt;String, Object&gt; entry : beanMap.entrySet()) &#123;        for (Field field : entry.getValue().getClass().getDeclaredFields()) &#123;            field.setAccessible(true);            if(!field.isAnnotationPresent(AutoWired.class))&#123;                continue;            &#125;            if(beanMap.containsKey(field.getType().getName()))&#123;                try &#123;                    field.set(entry.getValue(),beanMap.get(field.getType().getName()));                &#125; catch (IllegalAccessException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;else &#123;                throw new RuntimeException(&quot;只能自动绑定已注册的Bean&quot;);            &#125;究以下。        &#125;    &#125;&#125;\n\n怎么样，是不是非常简单？我们的实现都没到100行。但是我可以向你保证这个玩意无法正常运行。由于用户的工作目录是任意的，而我们的这中写法只有工作目录恰好是编译的输出目录时才能正确运行。想要正确的处理这些东西，我们还必须去学习一些知识，不过这部分我们下一篇再讲，现在先回到主题\n动态代理是什么所谓的动态代理就是通过反射获取类的相关方法，在执行时代替这个类去执行对应的方法，在这一过程中可以对方法进行一定的修饰\n所以这有什么用？仔细想想，Mybatis是怎么实现的？不就是通过对接口方法的代理吗？Spring的AOP或者说面向切面怎么实现的，不也是通过对类的代理吗？\n如果你想的话可以直接自己手搓一个动态代理机制出来，不过Java毕竟原生提供了动态代理的实现，我们还是直接调用吧，其中的关键是两个类\n\njava.lang.reflect.Proxy：代理类，用于动态创建代理对象。\njava.lang.reflect.InvocationHandler：调用句柄接口，用于处理代理对象的方法调用。\n\n我们写一个简单的例子，这是一个接口\npublic interface Service &#123;    void doSomething();    String test();&#125;\n\n接着完成这个接口的实现\npublic class ServiceImpl implements Service &#123;    public void doSomething() &#123;        System.out.println(&quot;doSomething&quot;);    &#125;    public String test() &#123;        return &quot;test&quot;;    &#125;&#125;\n\n接下来我们完成一个代理类\npublic class MyProxy implements InvocationHandler &#123;    private final Object target;    public MyProxy(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;        System.out.println(&quot;执行前操作&quot;);        Object result = method.invoke(target, objects);        System.out.println(&quot;执行后操作&quot;);        return result;    &#125;    public static Object getProxyInstance(Object target) &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(),//获得类加载器                target.getClass().getInterfaces(),//获得所实现的接口                new MyProxy(target));//提供一个调用句柄    &#125;&#125;\n\n你会发现这个代理类是通用的，接下来我们尝试使用以下代理类\npublic class Main &#123;    public static void main(String[] args) &#123;        Service service1 = new ServiceImpl();        Service service2 = (Service) MyProxy.getProxyInstance(service1);        service1.doSomething();        service2.doSomething();        System.out.println(service1.test());        System.out.println(service2.test());        System.out.println(service1.hashCode());        System.out.println(service2.hashCode());        System.out.println(service1.getClass().getName());        System.out.println(service2.getClass().getName());    &#125;&#125;\n\n运行结果如下\n执行前操作doSomething执行后操作test执行前操作执行后操作test2084435065执行前操作执行后操作2084435065abc.proxy.ServiceImpljdk.proxy1.$Proxy0\n\n在我不解释的情况下你是否能理解为什么会出现这样的输出结果呢，我们分段来看\n首先是前四行输出，无代理的对象直接输出，有代理的对象按照我们所规定的操作顺序来处理\n接着看5到8行，执行顺序变了吗？并没有，只不过在受到代理的对象中，调用任何一个方法本质上都是通过我们重写的invoke方法来实现的，控制台输出在Invoke方法执行完毕后才得到了要输出的结果\n再来看一看这个8到11行，不是说会产生新的代理类吗，那么为什么哈希是相同的，有点诡异。\n再看一看12和13行，类名不一样，是符合我们预期的，不过还有一个问题，这次从结果上看居然没有被代理？这是什么情况？原因实际上非常简单，如果粗暴的将所有的方法代理，那么区分代理类与原来的类就成了一件麻烦的事情，所以这个方法并没有被代理。\n结语这部分的知识就讲到这里，我们下一篇将会探讨关于文件处理相关的问题，顺路继续优化我们的IoC容器\n\n","tags":["手写Spring"]}]