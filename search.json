[{"title":"Docker入门","url":"/2025/04/01/Docker%E5%85%A5%E9%97%A8/","content":"最近忙着写项目，好久没更新内容了。而且就在昨天，重装系统的时候我居然忘了把博客的本地文件保存一份！！！现在我已经失去了前面博客的所有内容，不得不花费大量时间重新把前面的内容整理一次，孩子心里苦啊。\n闲话就聊到这里,今天我们来了解一下Docker技术.Docker可以帮助我们快速的实现项目依赖环境的完整打包.方便我们将项目快速的部署到不同的设备上去.\n由于Windows上没有原生的Docker,想要运行需要套几层壳,所以这次我们使用Ubuntu.具体版本为Ubuntu24.04.(当然现在有了WSL2，其实在windows上也不是很麻烦，直接去官网https://www.docker.com/下载即可)\nDocker的安装我们首先来完场Docker的安装.这部分比较简单,先安装一些依赖\nsudo apt-get install ca-certificates curl gnupg lsb-release\n\n然后安装官方的GPG Key\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n然后将Docker的下载地址放到apt的搜索列表中\necho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n接着更新一下列表\nsudo apt update\n\n接着下载Docker的社区版本（Docker分为社区版和商业版）\nsudo apt install docker-ce\n\n可以通过\ndocker --version\n\n来判断是否下载成功\n\nDocker的配置到此完成，我们接下来详细的了解一下Docker的结构\n容器与镜像容器与虚拟机的区别在开始这一板块之前，我们先来思考一个问题：假设我现在使用的是Ubuntu22.04,然后下载一个Ubuntu24.04的Docker，那么我是否能使用Ubuntu24.04的全部功能呢？这个问题在虚拟机上是显然的，但是在Docker中却不那么肯定。\n我们可以看一下这张图：\n\n这张图体现了虚拟机和Docker的重要区别：虚拟机的虚拟是内核级别的，所有的虚拟机相互独立，互不干扰。但是，所有的Docker共用设备的内核空间，只拥有独立的用户空间。也就是说，如果ubuntu22.04的内核支持相关功能，我们是可以顺利使用的，但如果内核不知相关功能，我们就无能为力了。\n此外，还有一点值得注意：容器与镜像的区别。\n直接构建了解了这些，我们开始尝试自己构建一个镜像，每一个应用都运行在操作系统上，所以构建自己的镜像也必须基于最基本的系统镜像，我们一般称这些镜像为Base镜像（当然，在很多时候我们也不一定真的从最基本的镜像开始构建，而是使用一些已经安装了一些必要的环境的镜像开始构建）。我们这里尝试去构建一个包含了jdk的ubuntu镜像\n首先我们拉取一个ubuntu的Base镜像(最近由于DockerHub的限制，很多镜像源都不能用了，如果下载不下来，请自行寻找合适的镜像源或者科学上网)\ndocker pull ubuntu:22.04\n\n这里注意，一个镜像的标准名称通常为name:tag的格式，name用来说明名称，tag用来说明版本\n下载完成后可以通过\ndocker images\n\n来查看当前的所有镜像\n\n可以看到，刚刚下载的Ubuntu镜像小的惊人，只有77.9MB,这是因为作为Base镜像，只保留了最基本的用户空间运行能力，我们平时很多常用的命令都是无法在这个镜像中执行的。\n接下来在容器中运行这个镜像\ndocker run -it ubuntu:22.04\n\n其中i参数指创建一个标准的输入输出接口，t参数指创建一个虚拟的tty设备来作为终端供我们使用，这两个参数一般同时使用，效果如下：\n我们已经进入了基于ubuntu镜像创建的容器的内部\n我们的目的是构建一个包含jdk的ubuntu镜像，所以现在执行下列命令\napt update &amp;&amp; apt install -y openjdk-21-jdk\n\n下载完成后可以使用exit直接退出\n现在查看以下我们的容器\ndocker ps -a\n\n如果不使用a参数则只显示处于运行状态下的容器\n\n接下来执行\ndocker commit 容器ID/名称 新的镜像名\n\nDocker中所有可以使用id的地方都可以使用ID的一部部分，只要能保证具有唯一性就好，例如我们可以在此处使用\ndocker commit fd jdk:21\n\n看一看结果\n\n注意到经过我们的一番操作后镜像的体积发生了巨大的膨胀，这是因为我们在下载jdk时不但下载了jdk,还下载了jdk运行时必要的操作系统依赖。\n对于已经存在的镜像，我们可以\ndocker start name/id #启动现有的镜像docker stop name/id #停止正在运行的镜像\n\n我们可以使用这种方法去构建任何镜像，但这种镜像的构建存在一个问题：不够透明。除你之外没有人知道这个镜像是如何被构建的，对个人使用来说，这种构建方式显然是无所谓的，但是如果这个镜像是面向其他人的，我们就不应该这么做，我们需要使用Dockerfile来完成构建\n通过Dockerfile构建在开始之前我们先删除之前创造的镜像与容器\ndocker rmi 镜像ID #删除镜像docker rm 容器ID #删除容器\n\n同样的，只要输入ID的开头，确保唯一性即可\n接下来我们创建一个名为Dockerfile的文件，并写入如下的内容\nFROM ubuntu:22.04RUN apt update &amp;&amp; apt install -y openjdk-21-jdk\n\n在该文件目录下执行\ndocker build -t jdk:21 .\n\n就能得到和我们之前所构建的jdk镜像完全相同的镜像了\n下面我展示一些在Dockerfile中常使用的命令\nFROM &lt;基础镜像&gt; #从对应的基础镜像开始构建LABEL xxx=xx #给镜像添加元数据，一般用来标识作者，版本等信息ARG xxx=xx #创建一个名为xxx的参数，其值为xx,为此后调用这个值提供方便RUN xxx #在基础镜像内执行xxxCOPY /xx /xxx #将/xx目录下的内容复制到镜像的/xxx目录下ADD https://example.com/file.tar.gz /app/ #与COPY类似，但支持远程下载WORKDIR /xx #设置容器启动时将自动跳转到容器内的/xx目录下ENV xxx=xx #为镜像添加一个名称为xxx的环境变量，其值为xxEXPOSEE xxx #对外暴露容器的xxx端口VOLUME /xx #在容器的/xx目录下创建一个挂载点用于数据持久化，这点我们后面再解释ENTRYPOINT xxx #在容器启动时自动执行xxx,优先级高于CMDCMD xxx #在容器启动时自动执行xxx\n\n当然，这并不是全部的命令，但大多数时候对我们来说已经够用了\n在这部分的最后，让我们了解一下如何将我们所创建的镜像推送到DockerHub，首先自行到Dockerhub创建一个仓库\n\n接下来我们将我们之前的镜像重新命名后推送\ndocker tag jdk:21 myjdk:21docker push 你的用户名/myjdk:21\n\n根据规范，我们必须在推送时添加自己的用户名来保证推送到属于我们自己的仓库，在拉取时同样采用\ndocker pull 你的用户名/myjdk:21\n\n的格式来确保获得正确的镜像\n这一步操作如果网络环境好可以试一试，毕竟一次性要上传800MB,在当前网络环境下有时候会比较困难\nDocker网络管理接下来我们来了解一下Docker的网络管理，我们执行如下的命令\ndocker network ls\n\n\n我们可以看到当前总共有三个网路，这三个网络是Docker在下载时就帮我们创建的，分别对应Docker支持的三种网络类型bridge null host\n我们首先来看看null网络，这个网络中只有一个本地环路，与宿主机的网络环境相互隔离，无法通过网络访问，用于部分有特殊安全需求的环境。如果想使用null网络，可以使用\ndocker run --network=none jdk:21\n\n然后是host网络，如果容器使用的是这种网络，相当于直接使用宿主机的网络环境，在这种网络下，我们，容器中的网络配置与宿主保持一致，不需要镜像额外的开放端口等操作。在这种模式下，网络通信的损失是最小的.如果想使用我们\n最后是bridge网络，或者说是桥接网络，你可以简单的理解为在宿主机上创建了一个虚拟的局域网，宿主机与容器都是这个虚拟局域网的一台设备，不同设备之间通过这个局域网进行信息交互。这也是所有容器的默认网络模式。在这种模式下，我们前面的在Dockerfile中主动暴露端口的行为就有了意义，举个简单的例子\ndocker run -p 1234:80 -n test jdk:21\n\n这里我使用了两个参数，p参数用来指定端口映射，将宿主机的1234端口映射到容器的80端口，此时对宿主机1234端口的访问就会通过桥接网络转发到容器的80端口。n参数是给容器命名的，我们之前所创建的容器起名称都是docker随即生产的，我们可以通过这个参数手动指定。\n在这里你可能会问，那我们之前在Dockerfile中提到的EXPOSE指令又有什么作用呢？这个指令更多的起到提醒作用，用于提醒用户需要将这个端口映射到宿主机中\n我们也可以创建自己的网络，例如这样\ndocker network creat --driver bridge test\n\n这样我们就创建了一个名为test的桥接网络，我们在启动时可以手动指定使用的网络\ndocker run --network=test image\n\n注意，虽然都是使用桥接网络，但是test网络与bridge网络两个网络是互相隔离的，无法互相进行通信，当然，我们也可以主动进行连接\ndocker network connect test containerID/name\n\n此时容器就被主动的连接到了test网络\n容器数据持久化还记得我们上面提到的volume指令吗？对于一个一般的容器，在停止运行时所有运行时产生的数据都将被删除，这无疑是我们所不想看到的，所以我们可以使用VOLUME指令创建挂载点，此时docker会产生一个匿名卷来存储doker对应目录下的数据，这个匿名卷在宿主机上的路径一般为/var/lib/docker/volumes，不过我们可以选择进一步的定制化一些，我们可以将容器的数据挂载到宿主机的指定路径下，使用\ndocker run -v /host/path:/container/path image\n\n此时会将容器的&#x2F;container&#x2F;path与宿主机的&#x2F;host&#x2F;path相互绑定，宿主机与容器任何一方对数据的修改都会在另一方体现\n如果我们使用v参数但不指定宿主机路径，则会在宿主机上自动创建对应路径\n如果我们想要在多个容器之间共享数据呢，聪明的你一定想到创建一个公共目录，经所有容器都挂载到对应的目录。但是我们还有别的办法：直接将一个容器的路径挂载到另一个容器\ndocker run -p 80:80 --volumes-from=data_test test\n\n此时test继承了data_test的挂载信息，在总体容器数量比较多时我们通常会创建一个专门的容器用来管理数据（被称为数据卷容器），例如上面的data_test,所有的容器再继承其挂载方式\nDocker容器管理接下来我们来聊一聊对运行状态下的容器的管理，有以下常用的命令\ndocker log 容器名/ID\n\n可以用来输出容器中的控制台信息（f参数可用来保持持续输出）\ndocker attach 容器ID/名称\n\n直接进入某个运行的容器的内部，注意在完成操作后先按Ctrl+P再按Ctrl+Q退出，千万不要按Ctrl+C这会导致容器停止运行\ndocker exec -it 容器ID/名称\n\n为容器创建一个新的bash终端，如果容器中运行的项目会不断的对控制台输出信息，那么可以通过这个指令开启一个新的终端来对容器进行操作\ndocker stats\n\n用于查看所有容器的状态\ndocker top 容器ID/名称\n\n查看某个容器的所有进程信息\n接下来是几个比较不推荐的\ndocker kill 容器ID/名称 #强制终止容器docker pause 容器ID/名称 #暂停容器docker unpause 容器ID/名称 #与上一条相反\n\n其实还有很多操作，但是这些操作都是偏运维向的，这里就不做介绍了\n常用参数介绍注意，docker非常重视灵活性，所有在dockefile中规定的东西都可以被在启动时覆盖，实际的覆盖操作使用以下这些参数\n\n\n\n参数\n描述\n示例\n\n\n\n\n\n-d\n后台运行容器\ndocker run -d IMAGE\n\n\n\n\n-it\n交互式终端，-i 保持标准输入打开，-t 分配一个伪终端\ndocker run -it IMAGE\n\n\n\n\n--name\n为容器指定一个名称\ndocker run --name mycontainer -d IMAGE\n\n\n\n\n-p\n端口映射，格式为 主机端口:容器端口\ndocker run -p 8080:80 -d IMAGE\n\n\n\n\n-v\n数据卷映射，格式为 主机路径:容器路径[:权限]\ndocker run -v /host/path:/container/path -d IMAGE\n\n\n\n\n--env 或 -e\n设置环境变量\ndocker run --env MY_VAR=value -d IMAGE\n\n\n\n\n--network\n将容器连接到指定的 Docker 网络\ndocker run --network mynetwork -d IMAGE\n\n\n\n\n--restart\n设置容器的重启策略，可选值为 no、on-failure、always、unless-stopped\ndocker run --restart always -d IMAGE\n\n\n\n\n--link\n将容器连接到另一个容器\ndocker run --link other-container:alias -d IMAGE\n\n\n\n\n--cpus\n限制容器使用的 CPU 资源\ndocker run --cpus=&quot;1.5&quot; -d IMAGE\n\n\n\n\n--memory\n限制容器使用的内存\ndocker run --memory=&quot;256m&quot; -d IMAGE\n\n\n\n\n--gpus\n指定容器可以访问的 GPU 设备\ndocker run --gpus all -d IMAGE\n\n\n\n\n--log-driver\n指定日志驱动\ndocker run --log-driver=syslog -d IMAGE\n\n\n\n\n--health-cmd\n配置容器的健康检查命令\n&#96;docker run –health-cmd&#x3D;”curl -f http://localhost/\n\nexit 1” -d IMAGE&#96;\n\n\n--user\n指定容器内进程的用户\ndocker run --user username -d IMAGE\n\n\n\n\n--security-opt\n设置 SELinux 或 AppArmor 配置\ndocker run --security-opt seccomp=unconfined -d IMAGE\n\n\n\n\n--cap-add\n添加容器的 Linux 能力\ndocker run --cap-add=SYS_ADMIN -d IMAGE\n\n\n\n\n--cap-drop\n删除容器的 Linux 能力\ndocker run --cap-drop=SYS_ADMIN -d IMAGE\n\n\n\n\n--privileged\n给容器赋予特权，可以访问主机的设备\ndocker run --privileged -d IMAGE\n\n\n\n\n--tmpfs\n在容器内创建临时文件系统\ndocker run --tmpfs /tmp -d IMAGE\n\n\n\n\n--ulimit\n设置容器的资源限制，如最大打开文件数、最大进程数等\ndocker run --ulimit nofile=1024:1024 -d IMAGE\n\n\n\n\n--hostname\n设置容器的主机名\ndocker run --hostname my_container -d IMAGE\n\n\n\n\n--dns\n指定容器使用的自定义 DNS 服务器\ndocker run --dns 8.8.8.8 -d IMAGE\n\n\n\n\n--dns-search\n指定容器的 DNS 域\ndocker run --dns-search example.com -d IMAGE\n\n\n\n\n--entrypoint\n覆盖镜像的默认入口点\ndocker run --entrypoint /custom_entrypoint -d IMAGE\n\n\n\n\n--rm\n容器退出时自动删除容器\ndocker run --rm -d IMAGE\n\n\n\n\n--mount\n更详细的挂载配置，支持类型 bind、volume、tmpfs\ndocker run --mount type=bind,source=/data,target=/app/data -d IMAGE\n\n\n\n\n--shm-size\n设置容器的共享内存大小\ndocker run --shm-size 2g -d IMAGE\n\n\n\n\n--volume-driver\n指定容器使用的卷驱动程序\ndocker run --volume-driver my_driver -d IMAGE\n\n\n\n\n--env-file\n从文件读取环境变量\ndocker run --env-file=env.list -d IMAGE\n\n\n\n\n--label\n为容器添加元数据标签\ndocker run --label &quot;env=prod&quot; -d IMAGE\n\n\n\n\n需要特别说明的是ENTRYPOINT可以通过--entrypoint  覆盖，而CMD指令可以通过类似\ndocker run my_image echo &quot;Hello, World!&quot;\n\n这样原来的CMD命令将会被覆盖，如果需要的命令过于复杂，你还可以这样\ndocker run my_image &lt; cmd.sh\n\n直接编写一份完整的脚本然后导入\n结语如果你之前来过我的站，你可能会发现所有的之前的文章都已经消失了，由于某次出人意料的事故，所有之前写下的文章都美丽，悲～～～。所以只好从零开始了，有很多东西确实比较有用，有空的话我会尽力再尝试写一份的\n\n","tags":["杂谈"]},{"title":"IDEA中VIM插件的使用","url":"/2025/04/17/IDEA%E4%B8%ADvim%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"  今天我们讲一讲关于idea中vim插件的使用。其实网上一直有这样两波人，一批人在疯狂的吹嘘vim到底有多好用，甚至看不起平时使用IDE的人；另一批人却将vim的使用者称之为装。 从我个人的使用感受上来说，vim确实是个好东西，唯一的问题就是不怎么好上手，在习惯以后确实能够大大提高编码效率。但是真的完全用vim写代码，需要做各种繁琐的配置，给vim安装各种各样的插件，还不一定能百分百达到完整的IDE的效果，所以我的选择是IDEEA加vim插件，使用起来感觉要好很多\nvim插件下载几乎所有的主流IDE都有对应的vim插件，而且大部分还做的不错。在IDEA中打开自带的插件市场搜索vim并下载下面的三个插件\n\n下载完成后你可以看到类似的状态，右下角出现了一个绿色的normal,光标变成了按过Insert键后的样式就说明下载成功了\n\n基本的使用接下来讲一下vim的基本使用，这些操作和vim保持一致，可以在任何一个vim环境中使用。\n我实在懒得把这些东西重写一次，所以直接使用来自于菜鸟教程的表格，这里是原网页https://www.runoob.com/linux/linux-vim.html\n\n\n\n移动光标的方法\n\n\n\n\nh 或 向左箭头键(←)\n光标向左移动一个字符\n\n\nj 或 向下箭头键(↓)\n光标向下移动一个字符\n\n\nk 或 向上箭头键(↑)\n光标向上移动一个字符\n\n\nl 或 向右箭头键(→)\n光标向右移动一个字符\n\n\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！\n\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n[Ctrl] + [d]\n屏幕『向下』移动半页\n\n\n[Ctrl] + [u]\n屏幕『向上』移动半页\n\n\n+\n光标移动到非空格符的下一行\n\n\n-\n光标移动到非空格符的上一行\n\n\nn\n那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\nH\n光标移动到这个屏幕的最上方那一行的第一个字符\n\n\nM\n光标移动到这个屏幕的中央那一行的第一个字符\n\n\nL\n光标移动到这个屏幕的最下方那一行的第一个字符\n\n\nG\n移动到这个档案的最后一行(常用)\n\n\nnG\nn 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！ (常用)\n\n\nn\nn 为数字。光标向下移动 n 行(常用)\n\n\n搜索替换\n\n\n\n&#x2F;word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\n使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！\n\n\n\n:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g\nn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)\n\n\n删除、复制与贴上\n\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\nnx\nn 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\n\n\ndd\n剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nndd\nn 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nd1G\n删除光标所在到第一行的所有数据\n\n\ndG\n删除光标所在到最后一行的所有数据\n\n\nd$\n删除游标所在处，到该行的最后一个字符\n\n\nd0\n那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nnyy\nn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\n\n\ny1G\n复制游标所在行到第一行的所有数据\n\n\nyG\n复制游标所在行到最后一行的所有数据\n\n\ny0\n复制光标所在的那个字符到该行行首的所有数据\n\n\ny$\n复制光标所在的那个字符到该行行尾的所有数据\n\n\np, P\np 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)\n\n\nJ\n将光标所在行与下一行的数据结合成同一行\n\n\nc\n重复删除多个数据，例如向下删除 10 行，[ 10cj ]\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n\n\n\n.\n不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)\n\n\n第二部分：一般模式切换到编辑模式的可用的按钮说明\n\n\n进入输入或取代的编辑模式\n\n\n\n\ni, I\n进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\n\n\na, A\n进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n第三部分：一般模式切换到指令行模式的可用的按钮说明\n\n\n指令行的储存、离开等指令\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)\n\n\nZQ\n不保存，强制退出。效果等同于 :q!。\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！\n\n\nvim 环境的变更\n\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n大家可以自行查看这些操作。你会发现这些操作保证了我们在双手不离开键盘中心区的前提下可以完成几乎所有的编辑操作，用习惯后还是非常爽的\n简单的配置但是从我个人的使用体验上来说，还是要对插件进行一些简单的配置，这样才能用起来更爽。点击normal左侧的彩色v图标\n\n然后选择settings\n\n接下来进入这个页面\n\n可以避免vim插件覆盖一些我们常用的快捷键的功能，比如我将Ctrl+A,Ctrl+C等常用的按键功能保留了下来\n接下来点击应用后关掉这个页面，再次点击v图标，选择Creat ～&#x2F;.ideavimrc 进入vim插件的配置文件\n我在下面贴一下我自己的配置并提供比较详细的注释，又需要的可以自己改写\nbasicPlug &#x27;machakann/vim-highlightedyank&#x27;&quot; Commentary pluginPlug &#x27;tpope/vim-commentary&#x27;&quot; 1. 基础 Vim 行为&quot; ----------------------------set number&quot; 在编辑器左侧显示绝对行号，有助于快速跳转到指定行（如输入 50G）并与同事共享行号定位。vim原生选项。set relativenumber&quot; 将当前行显示为绝对行号，其它行显示相对行号（与当前行的距离）。在进行跳转（例如 5j、3k）或上下文操作时非常直观。set cursorline&quot; 在当前行绘制高亮背景，增强光标位置的视觉识别，减少长文件中定位迷失的可能。set showmode&quot; 在命令行区域显示当前模式（-- INSERT --、-- VISUAL -- 等），方便快速确认当前是普通模式还是插入模式。set showcmd&quot; 当你输入多键命令（例如 d5w）时，实时在底部显示已输入的部分，帮助跟踪复杂映射或宏输入。set incsearch&quot; 在输入搜索模式（/pattern）时，边输入边高亮匹配，实时预览匹配结果，无需回车确认即可判断效果。set hlsearch&quot; 持续高亮所有与搜索模式匹配的项，便于一次性观察整个文件中的分布位置。set scrolloff=5&quot; 光标上下留有 5 行空白，以保持视野中心；在滚动时不至于光标贴近屏幕边缘。set sidescrolloff=5&quot; 同理，左右侧留 5 列空白，适用于超长行的水平滚动。set clipboard+=unnamed&quot; 将 Vim 的剪贴板与系统剪贴板合并，复制/粘贴可直接与 IDEA 与其他应用共享，免去额外切换。set wildmenu&quot; 启用命令行自动补全菜单，按 Tab 循环选择补全项，比原生补全反馈更友好。set wildmode=longest:full,full&quot; 补全方式：先补全公共前缀，再列出所有匹配项。提升多候选补全的效率与准确性。&quot; 2. Leader 键与快捷键映射&quot; ----------------------------let mapleader=&quot; &quot;&quot; 将“Leader 键”设为空格键；避免与常见 Vim 默认映射冲突，空格易按且手感舒适。&quot; 文件与项目操作nnoremap &lt;leader&gt;w :w&lt;CR&gt;&quot; 在普通模式下，按 空格+w 保存当前文件，等效于 :w。nnoremap &lt;leader&gt;q :q&lt;CR&gt;&quot; 按 空格+q 关闭当前编辑窗口。可按需改为 :bd 以保留分屏布局。nnoremap &lt;leader&gt;ff :action FindInPath&lt;CR&gt;&quot; 空格+ff 调用 IDEA 的“全局查找文件/符号”功能（Find in Path），跨项目搜索。nnoremap &lt;leader&gt;fr :action ReplaceInPath&lt;CR&gt;&quot; 空格+fr 调用“全局替换”功能（Replace in Path），在整个项目中批量替换。&quot; 窗口与标签管理nnoremap &lt;leader&gt;tn :tabnew&lt;CR&gt;&quot; 空格+tn 新建一个标签页，便于并行打开多个文件。nnoremap &lt;leader&gt;to :tabonly&lt;CR&gt;&quot; 空格+to 关闭除当前标签外的所有标签，只保留当前视图。imap a; &lt;Esc&gt;&quot; 将&lt;Esc&gt;映射为a;避免误触的同时方便使用，有些人也比较喜欢jj等映射方式&quot; 3. IntelliJ IDEA Action 映射&quot; ----------------------------&quot; IdeaVim 特有命令格式：:action + IDEA 内部 Action ID&quot; 可在 IDEA 中开启 “IdeaVim: Track Action Ids” 来得知鼠标点击或快捷键触发的 Action ID。nnoremap &lt;leader&gt;cf :action ReformatCode&lt;CR&gt;&quot; 空格+cf 触发 IDEA 的“代码格式化”功能，自动应用项目中的代码风格规则。nnoremap &lt;leader&gt;oi :action OptimizeImports&lt;CR&gt;&quot; 空格+oi 调用“优化导入”，自动移除无用 import 并按配置排序。nnoremap gd :action GotoDeclaration&lt;CR&gt;&quot; 在普通模式下按 gd，跳转到光标所在符号的声明位置，便于快速阅读实现细节。nnoremap gr :action FindUsages&lt;CR&gt;&quot; 按 gr 查找符号所有用法，在底部面板中展示所有引用，方便代码审计与重构。nnoremap &lt;leader&gt;r :action Run&lt;CR&gt;&quot; 空格+r 运行当前上下文（文件、测试或应用），等同于点击工具栏 Run 按钮。nnoremap &lt;leader&gt;d :action Debug&lt;CR&gt;&quot; 空格+d 启动调试，自动进入 Debug 模式，便于单步排查逻辑。&quot; 4. 可选：引入本地 Vim 配置&quot; ----------------------------&quot; 如果你同时在终端使用 Vim，可将常用 Vim 配置放在 ~/.vimrc，&quot; 在 IdeaVim 中通过以下命令复用：&quot; source ~/.vimrc\n\n这里反复提到了leader键，所谓的leader键可以理解为一个前缀键，类似于一个自定义的Ctrl键，默认为反斜杠，长按时进入特殊模式，此时可与继续搭配其他案件实现各种各样的功能\n结语刚刚接触时由于记不清各个案件所以会有比较明显的滞涩感，不过只要时间长了用的熟悉了，以后就难以离开这种感觉了\n\n","tags":["杂谈"]},{"title":"JSON解析","url":"/2025/04/07/JSON%E8%A7%A3%E6%9E%90/","content":"  既然要手写一个可用的spring框架，那么网络通信部分是必不可少的，既然涉及到了网络通信，那么显然json解析能力是必须具备的，所以我们今天来试着手写一个json解析器吧\nJSON的规则首先我们研究以下JSON解析的问题，开始之前我们可以先看看JSON的标准\n\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和编写，也易于机器解析和生成。以下是 JSON 的主要规则和特点：\n1. 基本结构\nJSON 数据由两种结构组成：\n对象（Object）：无序的键值对集合，用花括号 &#123;&#125; 表示。\n数组（Array）：有序的值的集合，用方括号 [] 表示。\n\n\n\n2. 数据类型   JSON 支持以下数据类型：\n\n字符串：用双引号 &quot; 括起来的文本，例如 &quot;Hello, World!&quot;\n数字：整数或浮点数，例如 42 或 3.14\n布尔值：true 或 false\n空值：null\n对象：键值对的集合，例如 &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30 &#125;\n数组：值的有序列表，例如 [1, 2, 3, &quot;apple&quot;]\n\n3. 键值对规则\n键（Key）必须是字符串，并且用双引号 &quot; 括起来。\n键和值之间用冒号 : 分隔。\n键值对之间用逗号 , 分隔。\n示例：&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;isStudent&quot;: false&#125;\n\n4. 数组规则\n数组中的值可以是任何 JSON 支持的数据类型。\n数组中的值用逗号 , 分隔。\n示例：[  &quot;apple&quot;,  &quot;banana&quot;,  42,  true,  &#123; &quot;name&quot;: &quot;Alice&quot; &#125;]\n\n5. 嵌套结构\nJSON 支持嵌套的对象和数组。\n示例：&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;traveling&quot;],  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;123 Main St&quot;,    &quot;city&quot;: &quot;New York&quot;  &#125;&#125;\n\n6. 格式规范\nJSON 数据必须是有效的对象或数组。\n键必须用双引号括起来（单引号无效）。\n逗号不能出现在最后一个键值对或数组值之后（即不能有尾随逗号）。\n示例（错误）：&#123; &quot;name&quot;: &quot;Alice&quot;, &#125;  // 错误：尾随逗号\n\n7. JSON 的用途\n用于 Web 应用程序中的数据交换。\n用于配置文件（如 .json 文件）。\n用于 API 数据传输。\n\n8. JSON 与 JavaScript 的关系\nJSON 是 JavaScript 的一个子集，但独立于语言，可以被多种编程语言解析和生成。\n\n总结来说，JSON 是一种简单、灵活且广泛使用的数据格式，遵循上述规则可以确保数据的正确性和可读性。\n\n上面这部分是直接从网上找到的相关规范。仔细考虑以下，该怎们做？\n尝试解析我随便贴一段json,让我们来分析以下我们可能要处理的情况\n&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;traveling&quot;],  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;123 Main St&quot;,    &quot;city&quot;: &quot;New York&quot;  &#125;&#125;\n\n我们可能遇到的情况包括：\n\n遇到&#123;，表示一层解析的开始，如果在本层解析过程中遇到了新的&#123;，则进入新的解析层，换句话说，我们需要一个递归结构来处理问题\n遇到&#125;，表示当前层的解析结束\n遇到“，表示某个key或者value,可以考虑通过识别：来辨别这是一个key还是value,\n遇到[,表示数组的开始\n遇到,,表示键值对之间的分割\n遇到/，转义字符，后面的一个字符需要转义，\n\n仔细思考上面的信息，我们可以大概的写出一个可用的demo（建议先自己尝试一下，还是有一点难度的）\npackage Winter.Parser.JsonPaser;import java.util.*;public class JsonParser &#123;    String json;    int index;    private JsonParser(String json) &#123;        this.json = json;        this.index = 0;    &#125;    public void skipWhiteSpace() &#123;        while (Character.isWhitespace(json.charAt(index))) &#123;            index++;        &#125;    &#125;//跳过空格的方法    public void expectString(String target) &#123;        int start = index;        for (int i = 0; i &lt; target.length(); i++) &#123;if (target.charAt(i) != json.charAt(start)) &#123;                throw new RuntimeException(&quot;Expecting string at index &quot; + index + &quot; but found &quot; + target.charAt(i));            &#125;            start++;        &#125;//用于检测程序是否是按照我们期望的方式进行    &#125;    public Object parseValue() &#123;        skipWhiteSpace();        char ch = json.charAt(index);        return switch (ch) &#123;            case &#x27;&#123;&#x27; -&gt; parseObject();//通过首个字符类型判断解析方法            case &#x27;[&#x27; -&gt; parseArray();            case &#x27;&quot;&#x27; -&gt; parseString();            case &#x27;t&#x27; -&gt; parseTrue();            case &#x27;f&#x27; -&gt; parseFalse();            case &#x27;n&#x27; -&gt; parseNull();            default -&gt; &#123;                if (ch == &#x27;-&#x27; || Character.isDigit(ch)) &#123;                    yield parseNumber();                &#125;//处理判断数字的情况                throw new RuntimeException(&quot;Unexpected character at position &quot; + index + &quot;: &quot; + ch);            &#125;        &#125;;    &#125;    private Object parseObject() &#123;        Map&lt;String, Object&gt; jsonNodeMap = new LinkedHashMap&lt;&gt;();        expectString(&quot;&#123;&quot;);        index++;        skipWhiteSpace();        if(json.charAt(index)==&#x27;&#125;&#x27;)&#123;            index++;            return jsonNodeMap;        &#125;        while (true)&#123;            skipWhiteSpace();            String key = parseString();//由于key一定是字符串，直接用字符串的方式解析            skipWhiteSpace();            expectString(&quot;:&quot;);            index++;//跳过冒号            Object value = parseValue();//获取value            jsonNodeMap.put(key,value);            if(json.charAt(index)==&#x27;&#125;&#x27;)&#123;break;&#125;            if(json.charAt(index) !=&#x27;,&#x27;)&#123;                throw new RuntimeException(&quot;Unexpected character &#x27;&quot; + json.charAt(index) + &quot;&#x27; at index &quot; + index);            &#125;            index++;//用于跳过键值对之间的逗号        &#125;        return jsonNodeMap;    &#125;    private String parseString() &#123;        StringBuilder stringBuilder = new StringBuilder();        expectString(&quot;\\&quot;&quot;);        index++;//跳过引号        skipWhiteSpace();        while (json.charAt(index) != &#x27;&quot;&#x27;) &#123;//处理可能的转义字符            if (json.charAt(index) == &#x27;\\\\&#x27;) &#123;                index++;//跳过用于转义的\\                char c = json.charAt(index);                switch (c) &#123;                    case &#x27;t&#x27; -&gt; stringBuilder.append(&quot;\\t&quot;);                    case &#x27;f&#x27; -&gt; stringBuilder.append(&quot;\\f&quot;);                    case &#x27;n&#x27; -&gt; stringBuilder.append(&quot;\\n&quot;);                    case &#x27;b&#x27; -&gt; stringBuilder.append(&quot;\\b&quot;);                    case &#x27;r&#x27; -&gt; stringBuilder.append(&quot;\\r&quot;);                    case &#x27;&quot;&#x27; -&gt; stringBuilder.append(&quot;\\&quot;&quot;);                    case &#x27;/&#x27; -&gt; stringBuilder.append(&quot;/&quot;);                    case &#x27;\\\\&#x27; -&gt; stringBuilder.append(&quot;\\\\&quot;);                    case &#x27;u&#x27; -&gt; &#123;//处理特殊的unicode转义                        if (index + 4 &gt;= json.length()) &#123;                            throw new RuntimeException(&quot;Unexpected unicode sequence at index &quot; + index);                        &#125;                        stringBuilder.append((char) Integer.parseInt(json.substring(index+1, index + 4), 16));                        index += 4;                    &#125;                    default -&gt; throw new RuntimeException(&quot;Unexpected character &#x27;&quot; + c + &quot;&#x27; at index &quot; + index);                &#125;                index++;//跳过被转义的字符            &#125; else &#123;                stringBuilder.append(json.charAt(index));                index++;            &#125;        &#125;        index++;//跳过字符串末尾的引号        return stringBuilder.toString();    &#125;    private Number parseNumber() &#123;        skipWhiteSpace();        int start = index;        if(json.charAt(index)==&#x27;-&#x27;)&#123;            index++;        &#125;        while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index))) &#123;index++;&#125;        if(json.charAt(index)==&#x27;.&#x27;)&#123;//处理浮点数            do &#123;                index++;            &#125; while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index)));        &#125;        if(json.charAt(index)==&#x27;e&#x27; || json.charAt(index)==&#x27;E&#x27;)&#123;//处理科学计数法            do &#123;                index++;            &#125; while (index &lt; json.length() &amp;&amp; Character.isDigit(json.charAt(index)));        &#125;        String number = json.substring(start,index);//返回解析得到的数字        if(number.contains(&quot;e&quot;) || number.contains(&quot;E&quot;) || number.contains(&quot;.&quot;))&#123;            return Double.parseDouble(number);        &#125;else &#123;            try &#123;            return Integer.parseInt(number);            &#125;catch (NumberFormatException e)&#123;                return Long.parseLong(number);            &#125;        &#125;    &#125;    public List&lt;Object&gt; parseArray() &#123;        skipWhiteSpace();        List&lt;Object&gt; list = new ArrayList&lt;&gt;();        expectString(&quot;[&quot;);        index++;        skipWhiteSpace();        while (json.charAt(index) != &#x27;]&#x27;) &#123;            skipWhiteSpace();            list.add(parseValue());            if(json.charAt(index)!=&#x27;]&#x27;)&#123;index++;&#125;//用于跳过数组元素之间的逗号        &#125;        index++;//跳过]        return list;    &#125;    private boolean parseFalse() &#123;        expectString(&quot;false&quot;);        index+=5;        return false;    &#125;    private boolean parseTrue()&#123;        expectString(&quot;true&quot;);        index+=4;        return true;    &#125;    private Object parseNull() &#123;        expectString(&quot;null&quot;);        index+=4;        return null;    &#125;    public static void main(String[] args) &#123;        String json = &quot;&#123;\\&quot;greeting\\&quot;:\\&quot;你好，世界！\\&quot;,\\&quot;farewell\\&quot;:\\&quot;再见，朋友！\\&quot;&#125;&quot;;        JsonParser parser = new JsonParser(json);        Object value = parser.parseValue();        System.out.println(value);    &#125;&#125;\n\n感觉如何？如果能够理清所有的逻辑，自己独立写一个还是比较简单的，毕竟也就不到200行的代码量。当然，这个解析器从效率上来将肯定没有办法和一些主流的库比，但不管怎么说，这玩意能用了。\n建议去找ai写几个测试用例试一试（要求不要进行格式化），这个解析器其实只考虑了一些基本情况，你可以试着补足\n查询支持在完成解析后，我们肯定要做一下查询的支持，这样才能方便我们下一步与框架的继承，其实有上面的基础，这一步非常简单，基本的思路如下\npublic class JSON &#123;    private final Map&lt;String,Object&gt; jsonMap;    public JSON(String json) &#123;        JsonParser jp = new JsonParser(json);        Object ret = jp.parseValue();        if(!(ret instanceof Map))&#123;            throw new RuntimeException(&quot;JSON parsing failed&quot;);        &#125;        this.jsonMap = (Map&lt;String, Object&gt;) ret;    &#125;    // 新增查询方法    public List&lt;Object&gt; query(String path) &#123;        List&lt;Object&gt; result = new ArrayList&lt;&gt;();        String[] keys = path.split(&quot;\\\\.&quot;);        queryRecursive(jsonMap, keys, 0, result);        return result;    &#125;//查询方法//用于递归查询    private void queryRecursive(Object value, String[] keys, int depth, List&lt;Object&gt; result) &#123;        if (depth &gt;= keys.length) &#123;//如果递归深度达到了数组长度，停止递归，将结果保存到list中            result.add(value);            return;        &#125;        String key = keys[depth];        if (value instanceof Map) &#123;//如果是一堆嵌套的map,反复的递归直到指定层数            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) value;            if (map.containsKey(key)) &#123;                queryRecursive(map.get(key), keys, depth + 1, result);            &#125;        &#125; else if (value instanceof List) &#123;            List&lt;Object&gt; list = (List&lt;Object&gt;) value;//如果发现数组类型，遍历数组类型的所有元素            for (Object item : list) &#123;//用于处理数组类型                queryRecursive(item, keys, depth, result);            &#125;        &#125;    &#125;   &#125;\n\n怎么样，写起来也不是非常困难，反正就是不断递归查找。\n当然，这个方法也存在问题，首先，返回的是一个list,使用的时候还要做各种类型转换与遍历。但不管怎么说，这玩意能用了，这就是好事。\n结语今天就到这里了，嘴上说简单，但还是写的头疼，是在写不动了，先就此打住吧，下一期实现一个线程池，再下一期写一个请求转发器，最后再补充一些事务方面的东西，支持一下数据库交互，这套框架就差不多将就这能用了\n\n","tags":["手写Spring"]},{"title":"Java的反射与代理","url":"/2025/04/04/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E4%B8%8E%E4%BB%A3%E7%90%86/","content":"最近比较闲，所以来整点活，让我们从0到1手写一个Spring框架吧（只使用Java SE部分的相关内容，不使用任何依赖），不过在正式开始之前，我们要去了解一些基础知识（如果你确信了解了这些知识，可以直接跳过）。\n我们今天来讲一讲反射与代理相关的知识。\n首先我们从Java的类加载机制讲起\nJava的类加载机制我们都知道对于Java来说万物皆对象，所以你猜猜类是什么？类当然是对象了，所有的类在JVM中都被视为一种特殊的对象：Class对象。我们先反编译出来看一看，下面是这个类的头部\npublic final class Class&lt;T&gt; implements Serializable, GenericDeclaration, Type, AnnotatedElement, TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;, Constable\n\n类的加载流程大致如下\n\nJVM读取.class文件并将字节码转化为二进制数据，依照二进制数据创建一个上面提到的java.lang.Class对象来表示某个特定的类\n进行验证，确保所有的Class对象符合规范，不会危害JVM安全\n开始为对应的静态属性分配内存并设置默认的初始值\n进行解析，为所有的属性，方法添加对应的引用映射，如将类名指向Class对象\n执行类加载操作，调用对应的类加载器进行类的加载\n\n我们可以在Class类中发现Class类的构造方法\nprivate Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) &#123;    this.classLoader = loader;    this.componentType = arrayComponentType;&#125;\n\n其中的ClassLoader就是我们所说的类加载器\nJava 的类加载器采用层次结构，主要包括以下几种：\n\n启动类加载器（Bootstrap ClassLoader）：\n负责加载 Java 核心类库（如 rt.jar 中的类）。\n它是虚拟机的一部分，通常由 C++ 实现，不是 Java 代码。\n没有父类加载器。\n\n\n扩展类加载器（Extension ClassLoader）：\n负责加载 Java 的扩展类库（如 jre/lib/ext 目录下的 JAR 文件）。\n它是 sun.misc.Launcher$ExtClassLoader 的实例，父类加载器是启动类加载器。\n\n\n应用程序类加载器（Application ClassLoader）：\n也称为系统类加载器，负责加载用户类路径（CLASSPATH）指定的类。\n它是 sun.misc.Launcher$AppClassLoader 的实例，父类加载器是扩展类加载器。\n\n\n自定义类加载器：\n用户可以通过继承 java.lang.ClassLoader 类来实现自定义类加载器。\n用于加载特定路径或来源的类。\n\n\n\n我们先来看一看这个默认的类加载器在干什么吧，由于私有方法太多，我这里只贴一些比较关键的内容，首先是一个最为重要的类加载方法\npublic Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;    return this.loadClass(name, false);&#125;protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;    synchronized(this.getClassLoadingLock(name)) &#123;        Class&lt;?&gt; c = this.findLoadedClass(name);//这个方法会调用一个通过C++实现方法检测类是否已经被加载        if (c == null) &#123;//如果没有加载则开始加载            long t0 = System.nanoTime();//此处为获取JVM运行时间            try &#123;                if (this.parent != null) &#123;                    c = this.parent.loadClass(name, false);//如果该加载器存在父类则调用父加载器进行加载                &#125; else &#123;                    c = findBootstrapClassOrNull(name);//如果不存在则进行加载 ，这个方法同样是C++实现的                &#125;            &#125; catch (ClassNotFoundException var10) &#123;//如果父加载器加载失败则捕获异常并继续运行            &#125;            if (c == null) &#123;                long t1 = System.nanoTime();                c = this.findClass(name);//这个方法现在实际上是一个空方法，交给子类实现，默认运行到此处时会直接抛异常                PerfCounter.getParentDelegationTime().addTime(t1 - t0);//这些都是用于记录类加载时间的，用于性能优化                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            this.resolveClass(c);//这里是永远不会对外界开放的，不必关心        &#125;        return c;    &#125;&#125;\n\n你会发现这样一个逻辑：一般情况下，总是优先调用父加载器进行加载，这种加载机制被称之为双亲委派机制，原生的所有类加载器都会尽可能的将类加载任务委派给自己的父类的实例，这样做的根本目的是避免一个类被重复加载。\n还有一个比较关键的类加载器方法\nprotected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError     protectionDomain = this.preDefineClass(name, protectionDomain);    String source = this.defineClassSourceLocation(protectionDomain);    Class&lt;?&gt; c = defineClass1(this, name, b, off, len, protectionDomain, source);    this.postDefineClass(c, protectionDomain);    return c;&#125;\n\n这个方法用来将二进制数据转换为类对象，不过很遗憾，这个方法也是C++实现的\n那么这个类加载器在哪里被调用呢，可以简单的认为当某个类第一次被需要时，JVM会尝试调用类加载器来完成加载，这一部分我们在讲解反射部分时会具体的展示。\n我们最后再梳理以下JAVA的类加载机制：当某个类被需要时，JVM将通过类加载器直接加载这个类，这一过程遵循双亲委派机制，加载的结果是一个Class对象\n反射操作接下来我们解释什么是反射。这是我们一般情况下获取对象的方法\nTest test =new Test()\n\n不管怎么改，无论是什么建造者模式，工厂模式等等各种花活，都逃不出在某处new一个对象出来，但是你注意到这样一个问题了吗？Spring的依赖注入是如何实现的，框架的编写者是无法事先得知对象的名称的，又如何获取对象用来注入呢？正是通过反射\n举一个简单的例子，我可以通过这样的方式来构建一个字符串对象\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            String aString =(String) String.class.getConstructor().newInstance();            String bString = (String) Class.forName(&quot;java.lang.String&quot;).getConstructor().newInstance();        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n你看，我全程绝对没有new,哪怕你顺着源码查下去也绝对找不到任何new,这就是创建对象的另一种方式：反射。你或许想不到这有什么用，但是不要着急，我们先来了解以下关于反射的各种使用\n构建对象在知道对象名称时我们可以这样来实现\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Constructor&lt;?&gt; stringConstructor = stringClass.getConstructor();//获得类的构造器        Object string = stringConstructor.newInstance();//使用构造器来完成构造    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n上面的是JDK9之后的写法，如果你使用JDK8,甚至可以直接\npublic static void main(String[] args) &#123;    try &#123;        Class&lt;?&gt; stringClass = Class.forName(&quot;java.lang.String&quot;);        Object string = stringClass.newInstance();    &#125; catch (Exception e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n我们上面还提到了\nClass&lt;?&gt; intClass =int.class;\n\n这样的方法来获取类对象， class属性是直接来自于Object对象的，所有对象都天然的拥有这个属性。\n当然，对于一个对象，你也可以通过\nString s=&quot;Hello World&quot;;Class&lt;?&gt; c =s.getClass();\n\n这样的方式来获取class对象，在获取类对象后你可以按照上面的流程来获取对象。\n请注意\n\n所有的基本数据类型，基本数据类型的数组类型，基本数据类型的包装类型都拥有独立且唯一的Class对象\n类本身和对应的数组类型是拥有独立的Class对象\n所有的类永远只拥有一个类对象（这一点在必要时是可以被手动打破的）\n\n值得一提的是在利用类对象获取构造器时我们可以主动的选择构造方法，例如对于这个类\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;&#125;\n\n我们可以做一个这样的测试\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);            Constructor&lt;?&gt; constructor1 = clazz.getConstructor();//获取无参构造            Constructor&lt;?&gt; constructor2 = clazz.getConstructor(String.class,int.class);//获取全参构造            Student student1 = (Student) constructor1.newInstance();            Student student2 = (Student) constructor2.newInstance(&quot;aaa&quot;,111);            System.out.println(student1.test());            System.out.println(student2.test());        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n获取对象信息我们可以通过反射来获取一些类的信息\nClass&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);System.out.println(clazz.getSuperclass().getName());//获取父类for(Class&lt;?&gt; c: clazz.getInterfaces())&#123;    System.out.println(clazz.getName());//获取接口&#125;for (Annotation annotation: clazz.getAnnotations())&#123;    System.out.println(annotation.annotationType().getName());&#125;//获取注解\n\n此外，反射还能允许我们做一些比较疯狂的事情，比如访问私有字段，还是上面的Student类，age字段显然是私有的，且不存在任何方法进行访问，真的吗\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Field field = student.getClass().getDeclaredField(&quot;age&quot;);//获取字段            field.setAccessible(true);//强制运行字段访问            System.out.println(field.get(student));//输出0            field.setInt(student, 11);//修改字段值            System.out.println(field.get(student));//输出11        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n实际上哪怕是final字段。只要愿意也是可以修改的(不过JDK9之后禁止了，但仍然可以通过一些方式开启)\n这也意味这个一个问题：Java的一个核心理念：封装被突破了。你不让我访问？这是你能挡得住的？我不但能访问，我还能修改。所以实际上所有的封装实际上来自于程序员之间的君子约定：我们互相约定好这部分只在规定范围内访问，当然如果你非要访问，也没什么办法。\n调用方法我们甚至都已经访问了属性了，怎么能做不到调用方法呢？为了方便解释我们先改一改Student方法\npublic class Student &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student()&#123;        this.age = 0;        this.name = &quot;0&quot;;    &#125;    public String test()&#123;        return name;    &#125;    public String test(String s)&#123;        return s+name;    &#125;&#125;\n\n然后直接上\npublic class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Student student = new Student();            Method method = student.getClass().getMethod(&quot;test&quot;,String.class);//通过名称与参数类型来获取方法            System.out.println(method.invoke(student,&quot;1&quot;));        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n由于编译时形参无法被保留，我们无法直接通过名称获得\n特别的，如果参数类型为可变参数，可选择\nMethod method = clazz.getDeclaredMethod(&quot;test&quot;, String[].class);\n\n不过对于私有方法，就像final字段一样，默认情况下无法被直接使用，需要在启动时添加\n--add-opens java.base/java.lang=ALL-UNNAMED\n\n来允许所有反射\n实现一个简单的IoC容器有了上面的基础，我们已经可以实现一个简单的Bean管理器了。我们先回忆以下Spring中Bean管理器拥有哪些功能：\n\n扫面并创建所有的Bean\n完成依赖注入\n支持在任何地方提供Bean\n\n我们逐个来完成这些需求，为了方便，我们这里只提供注解形式的注册Bean的方法，先写一个注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Componenet &#123;&#125;\n\n还要写一个用于自动绑定的注解\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface AutoWired &#123;&#125;\n\n我们尝试搭建一个大概的框架\npublic class MyIocContainer &#123;    private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;();    private List&lt;String&gt; basePackageList =new ArrayList&lt;&gt;();    private final ClassPathLoader classPathLoader = new ClassPathLoader();    public void addBasePackage(String basePackage) &#123;        this.basePackageList.add(basePackage);    &#125;//用于规定扫描路径    public void scanPackage(Class&lt;?&gt; clazz) &#123;//此处模仿Spring,填入Main.class来确定运行位置        if(basePackageList.isEmpty()) &#123;            basePackageList.add(clazz.getPackage().getName());        &#125;        for (String basePackage : basePackageList) &#123;//遍历所有路径加载Bean            try &#123;                loadBean(beanMap, basePackage);            &#125; catch (Exception e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        autoWiring();    &#125;    public Object getBean(String className) &#123;        return beanMap.get(className);    &#125;    private void autoWiring()&#123;        for (Map.Entry&lt;String, Object&gt; entry : beanMap.entrySet()) &#123;            for (Field field : entry.getValue().getClass().getDeclaredFields()) &#123;//遍历所有的Bean完成依赖注入                field.setAccessible(true);                if(!field.isAnnotationPresent(AutoWired.class))&#123;                    continue;                &#125;                if(beanMap.containsKey(field.getType().getName()))&#123;                    try &#123;                        field.set(entry.getValue(),beanMap.get(field.getType().getName()));                    &#125; catch (IllegalAccessException e) &#123;                        throw new RuntimeException(e);                    &#125;                &#125;else &#123;                    throw new RuntimeException(&quot;只能自动绑定已注册的Bean&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n接下来完成加载Bean的方法\nprivate void loadBean(Map&lt;String,Object&gt; beanMap, String packageName) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;    URL dir = classLoader.getResource(packageName);//这部分文件的获取实际上使用类路径，这个概念我们下一篇再来研究    packageName = packageName.replace(&#x27;/&#x27;, &#x27;.&#x27;);    if (dir == null) &#123;        return;    &#125;//如果投入的路径不存在，直接返回    File dirFile = new File(dir.getFile());    if (!dirFile.exists() || !dirFile.isDirectory()) &#123;        return;    &#125;//对应的类路径不存在或者不是目录，直接返回    File[] files = dirFile.listFiles();    if (files != null) &#123;        for (File file : files) &#123;            if (file.isDirectory()) &#123;                loadBean(beanMap, packageName.replace(&quot;.&quot;,&quot;/&quot;) + &quot;/&quot; + file.getName());                continue;            &#125;            String className = packageName + &quot;.&quot; + file.getName().replace(&quot;.class&quot;, &quot;&quot;);            Class&lt;?&gt; clazz = classLoader.loadClass(className);            if(clazz.isInterface() || clazz.isAnnotation() || clazz.isEnum() || Modifier.isAbstract(clazz.getModifiers())) &#123;                continue;            &#125;//接口，抽象类和注解都不能使用构造方法构造，直接跳过避免报错            if(clazz.isAnnotationPresent(Componenet.class)) &#123;                Constructor&lt;?&gt; constructor =clazz.getConstructor();                constructor.setAccessible(true);                beanMap.put(className,constructor.newInstance());            &#125;//加载类        &#125;    &#125;&#125;\n\n虽然非常的简陋，但是这个IoC容器在功能上已经和Spring的IoC容器一致了，我们的全部实现只有不到100行代码。不过，这个容器仍然存在很多问题，举个简单的例子，如果有些类中包含一些static属性，这些属性对应的类在加载当前类时并没有被正确的加载，那么报错是必然的，想一想该怎么处理这个问题。此外，如果类足够多，我们是不是需要添加对应的多线程支持，这个类显然没有考虑多线程的情况，该怎么解决？这些问题我先留在，我们将来再解决。\n动态代理是什么所谓的动态代理就是通过反射获取类的相关方法，在执行时代替这个类去执行对应的方法，在这一过程中可以对方法进行一定的修饰\n所以这有什么用？仔细想想，Mybatis是怎么实现的？不就是通过对接口方法的代理吗？Spring的AOP或者说面向切面怎么实现的，不也是通过对类的代理吗？\n如果你想的话可以直接自己手搓一个动态代理机制出来，不过Java毕竟原生提供了动态代理的实现，我们还是直接调用吧，其中的关键是两个类\n\njava.lang.reflect.Proxy：代理类，用于动态创建代理对象。\njava.lang.reflect.InvocationHandler：调用句柄接口，用于处理代理对象的方法调用。\n\n我们写一个简单的例子，这是一个接口\npublic interface Service &#123;    void doSomething();    String test();&#125;\n\n接着完成这个接口的实现\npublic class ServiceImpl implements Service &#123;    public void doSomething() &#123;        System.out.println(&quot;doSomething&quot;);    &#125;    public String test() &#123;        return &quot;test&quot;;    &#125;&#125;\n\n接下来我们完成一个代理类\npublic class MyProxy implements InvocationHandler &#123;    private final Object target;    public MyProxy(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;        System.out.println(&quot;执行前操作&quot;);        Object result = method.invoke(target, objects);        System.out.println(&quot;执行后操作&quot;);        return result;    &#125;    public static Object getProxyInstance(Object target) &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(),//获得类加载器                target.getClass().getInterfaces(),//获得所实现的接口                new MyProxy(target));//提供一个调用句柄    &#125;&#125;\n\n你会发现这个代理类是通用的，接下来我们尝试使用以下代理类\npublic class Main &#123;    public static void main(String[] args) &#123;        Service service1 = new ServiceImpl();        Service service2 = (Service) MyProxy.getProxyInstance(service1);        service1.doSomething();        service2.doSomething();        System.out.println(service1.test());        System.out.println(service2.test());        System.out.println(service1.hashCode());        System.out.println(service2.hashCode());        System.out.println(service1.getClass().getName());        System.out.println(service2.getClass().getName());    &#125;&#125;\n\n运行结果如下\n执行前操作doSomething执行后操作test执行前操作执行后操作test2084435065执行前操作执行后操作2084435065abc.proxy.ServiceImpljdk.proxy1.$Proxy0\n\n在我不解释的情况下你是否能理解为什么会出现这样的输出结果呢，我们分段来看\n首先是前四行输出，无代理的对象直接输出，有代理的对象按照我们所规定的操作顺序来处理\n接着看5到8行，执行顺序变了吗？并没有，只不过在受到代理的对象中，调用任何一个方法本质上都是通过我们重写的invoke方法来实现的，控制台输出在Invoke方法执行完毕后才得到了要输出的结果\n再来看一看这个8到11行，不是说会产生新的代理类吗，那么为什么哈希是相同的，有点诡异。\n再看一看12和13行，类名不一样，是符合我们预期的，不过还有一个问题，这次从结果上看居然没有被代理？这是什么情况？原因实际上非常简单，如果粗暴的将所有的方法代理，那么区分代理类与原来的类就成了一件麻烦的事情，所以这个方法并没有被代理。\n实现一个简单的AOP框架我们可以使用动态代理来实现一个简单的AOP框架，不过很遗憾我们现有的知识是不足以让我们完整的实现Spring的AOP能力的，JDK的动态代理只做到了类一级，不能精细的对方法进行控制，这种能力需要对特定的字节码进行操作，所以我们还是暂时不讲了。\n不过简单的类级别的AOP框架还是很容易实现的，我们试着写一个吧，为了方便，我们这里只考虑三种情况：执行前，执行后，抛出异常时。我们将这三种情况规范为对应的接口\npublic interface BeforeExecution &#123;    void before(Object[] objects) throws Throwable;&#125;public interface BeforeExecution &#123;    void before(Object[] objects) throws Throwable;&#125;public interface ThrowException &#123;    void throwException(Object[] objects，Throwable throwable) throws Throwable;&#125;//这里的objects实际上是方法的参数，使用者可以利用这些参数\n\n然后考虑创建对应的代理类，我随便写一个可能的例子\npublic class ProxyFactory  &#123;    private static final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    private static AfterExecution afterExecution = null;    private static ThrowException throwException = null;    private static BeforeExecution beforeExecution = null;    private static boolean isClean=true;    public static void setAfterExecution(AfterExecution afterExecution) &#123;        ProxyFactory.afterExecution = afterExecution;    &#125;    public static void setThrowException(ThrowException throwException) &#123;        ProxyFactory.throwException = throwException;    &#125;    public static void setBeforeExecution(BeforeExecution beforeExecution) &#123;        ProxyFactory.beforeExecution = beforeExecution;    &#125;    private static Object getProxy0(Object target,InvocationHandler invocationHandler) throws Throwable &#123;        return Proxy.newProxyInstance(classLoader, target.getClass().getInterfaces(), invocationHandler);    &#125;    public static Object getProxy(Object target) throws Throwable &#123;        if(!isClean) &#123;            throw new RuntimeException(&quot;使用后未复位&quot;);        &#125;else&#123;            isClean=false;        &#125;        //这里其实采用的是装饰模式的思想，不断的对原来的类进行装饰最终得到我们想要的对象        if (beforeExecution != null) &#123;            target = getProxy0(target, (o, method, objects) -&gt; &#123;                beforeExecution.before(objects);                return method.invoke(o, objects);            &#125;);        &#125;        if (afterExecution != null) &#123;            target =getProxy0(target,(o,method,objects)-&gt;&#123;                Object result = method.invoke(o, objects);                afterExecution.afterExecution(objects);                return result;            &#125;);        &#125;        if (throwException != null) &#123;            target =getProxy0(target,(o,method,objects)-&gt;&#123;                Object result = null;                try &#123;                    result = method.invoke(o, objects);                &#125;catch (Throwable throwable) &#123;                    throwException.throwException(objects ,throwable);                &#125;                return result;            &#125;);        &#125;        return target;    &#125;    public static void clean() &#123;//这是一个复位方法，避免产生不必要的代理        isClean=true;        afterExecution=null;        throwException=null;        beforeExecution=null;    &#125;&#125;\n\n结语这部分的知识就讲到这里，我们下一篇将会探讨关于文件处理相关的问题，顺路继续优化我们的IoC容器\n\n","tags":["手写Spring"]},{"title":"NIO体系","url":"/2025/05/07/NIO%E4%BD%93%E7%B3%BB/","content":"理论上来说下一步应该是实现一些SpringWeb中的相关功能了，比如基本的HTTP通信实现，但是要实现Spring中的效果需要用Java的异步IO体系，这一部分比较复杂，且网上我也没找到太多比较好的资料，所以就有了这一篇，我们专门来讨论一下NIO体系的相关知识\n缓冲区相信大家都使用过BufferedReader等带缓冲的输入输出流，这些自带缓冲区的输入输出流主要被用于在数据量比较大的时候的数据输入输出，这些流都在java.io包下，但这些不是我们今天真正要介绍的内容下。在java.nio包下还有一套单独实现的缓冲机制，所有缓冲类从一个叫做Buffer的类开始，下面是这个类的一些基础内容\npublic abstract sealed class Buffer permits ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer &#123;//sealed是jdk17的新特性，称为密封类，及只允许permits后的类继承    static final Unsafe UNSAFE = Unsafe.getUnsafe();//unsafe类提供了直接的内存操作能力    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();    //内存范围      static final int SPLITERATOR_CHARACTERISTICS = 16464;      private int mark = -1;      private int position = 0;      private int limit;      private final int capacity;      long address;      final MemorySegment segment;      &#125;\n我们最好还是实际操作一下创建一个缓冲区来看看到底是怎么操作的，这个类是个抽象类，我们选择这个类的一个子类 intbuffer 来创建一个子类吧。大概的流程如下\npublic class Main &#123;    public static void main(String[] args) &#123;        IntBuffer intBuffer = IntBuffer.allocate(10);//直接申请一个大小为10的缓存        int[] ints = new int[10];        IntBuffer intBuffer2 = IntBuffer.wrap(ints);//将这个数组放到缓存中    &#125;&#125;\n我们接下来可以看看发生了什么\npublic static IntBuffer allocate(int capacity) &#123;    if (capacity &lt; 0) &#123;        throw createCapacityException(capacity);    &#125; else &#123;        return new HeapIntBuffer(capacity, capacity, (MemorySegment)null);//如果容量大于等0，创建一个堆int缓存    &#125;&#125;\n然后追踪几层找到实际的构造方法这个构造方法长这样\nHeapIntBuffer(int cap, int lim, MemorySegment segment) &#123;      super(-1, 0, lim, cap, new int[cap], 0, segment);      this.address = ARRAY_BASE_OFFSET;  &#125;\n然后继续往下找 super 方法就可以发现下面这个\nIntBuffer(int mark, int pos, int lim, int cap, int[] hb, int offset, MemorySegment segment) &#123;      super(mark, pos, lim, cap, segment);      this.hb = hb;      this.offset = offset;  &#125;//这里其实就体现出来了，实际上这个类也是在使用数组在存储int，就存在hb中\n接着看 super 就是下面这个\nBuffer(int mark, int pos, int lim, int cap, MemorySegment segment) &#123;        if (cap &lt; 0) &#123;            throw createCapacityException(cap);        &#125; else &#123;            this.capacity = cap;            this.segment = segment;            this.limit(lim);            this.position(pos);            if (mark &gt;= 0) &#123;                if (mark &gt; pos) &#123;                    throw new IllegalArgumentException(&quot;mark &gt; position: (&quot; + mark + &quot; &gt; &quot; + pos + &quot;)&quot;);                &#125;                this.mark = mark;            &#125;        &#125;    &#125;\n\n这里存在四个量：mark, position, limit, capacity。这四个量分别代表标记位置，实际位置，最大位置，数组容量。标记位置用于标记特定的位置实现跳转读取，所以初始状态为-1 即表示没有标记，实际位置就是数组的 index，最大位置为允许实际位置的最大值，数组容量是数组的实际容量。此外还有一个 offset 是操作的偏移量\n常见操作接下来我们看几个比较常见的操作，首先是写操作，主要使用 put 方法，实现如下\n//ix用来确定偏移量protected int ix(int i) &#123;    return i + this.offset;&#125;//获取下一个位置final int nextPutIndex() &#123;    int p = this.position;    if (p &gt;= this.limit) &#123;        throw new BufferOverflowException();    &#125; else &#123;        this.position = p + 1;        return p;    &#125;&#125;public IntBuffer put(int x) &#123;      this.hb[this.ix(this.nextPutIndex())] = x;      return this;  &#125;    public IntBuffer put(int i, int x) &#123;      this.hb[this.ix(this.checkIndex(i))] = x;      return this;  &#125;\n\n然后还包括两个针对数组和缓冲区的 put 方法我就不展示了，接下来看一眼获取的 get 方法\n//nextGetIndex和put中的nextPutIndex实现是相同的public int get() &#123;      return this.hb[this.ix(this.nextGetIndex())];  &#125;    public int get(int i) &#123;      return this.hb[this.ix(this.checkIndex(i))];  &#125;    public IntBuffer get(int[] dst, int offset, int length) &#123;      this.checkSession();//无需在意的合法性检查      Objects.checkFromIndexSize(offset, length, dst.length);      int pos = this.position();      if (length &gt; this.limit() - pos) &#123;          throw new BufferUnderflowException();      &#125; else &#123;          System.arraycopy(this.hb, this.ix(pos), dst, offset, length);        //从当前的position开始复制          this.position(pos + length);          return this;      &#125;  &#125;\n然后是 mark 和 reset 方法\npublic Buffer mark() &#123;      this.mark = this.position;      return this;  &#125;//将当前位置标记    public Buffer reset() &#123;      int m = this.mark;      if (m &lt; 0) &#123;          throw new InvalidMarkException();      &#125; else &#123;          this.position = m;          return this;      &#125;  &#125;//位置指针跳转到mark处\n缓冲区的基本操作就了解到这里，内部的其余方法有兴趣的可以自己看看，但个人觉得也没什么必要，用得着的时候查就对了，这不是我们今天的重点，我们来看看下个部分\n直接缓冲区我们之前的缓冲占用的是 jvm 的堆内存，本质上就是几个数组，那么我们是否可以申请一些对外内存来使用呢，当然可以，我们可以选择使用下面的这个方法来实现\npublic static void main(String[] args) &#123; //这里我们申请一个直接缓冲区    ByteBuffer buffer = ByteBuffer.allocateDirect(10); //使用方式基本和之前是一样的    buffer.put((byte) 66);    buffer.flip();//这个方法将缓冲区翻转，简单理解就是将指针移动的方向反向   System.out.println(buffer.get()); &#125;\n这个缓冲区在使用上与堆缓冲的使用是一致的，但差别在于这个缓冲区直接通过系统的 IO 实现，理论上会比堆缓冲快一点\n通道类与选择器那么缓冲类有什么用，有这功夫我不如直接使用一个 List，还更方便一些。事实上这些类是专门用于适配通道类的。通道类包括文件通道和网络通道，是 NIO 机制的实现。所有的通道类都继承自 Channel 类。这些通道类有什么作用呢？我们以网络通信为例来做一个比较，在没有 NIO 机制的情况下如果我们要实现一个网络通信，我们可以这么写：\npublic static void main(String[] args) &#123;      try &#123;          Executor executor = Executors.newFixedThreadPool(12);          ServerSocket serverSocket = new ServerSocket(8080);          BlockingDeque&lt;Socket&gt; sockets = new LinkedBlockingDeque&lt;&gt;();          executor.execute(() -&gt; &#123;              while(true)&#123;                  try &#123;                      Socket socket =serverSocket.accept();                      sockets.add(socket);                  &#125; catch (IOException e) &#123;                      throw new RuntimeException(e);                  &#125;              &#125;          &#125;);          while(true)&#123;              Socket socket = sockets.poll();              executor.execute(() -&gt; &#123;                  try &#123;                      while(true)&#123;                          BufferedReader bufferedReader =new BufferedReader(new InputStreamReader(socket.getInputStream()));                        //在这里如果读不到信息回阻塞到有信息为止                          String s = bufferedReader.readLine();                          BufferedWriter bufferedWriter =new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));                          bufferedWriter.write(s);                          bufferedWriter.flush();                      &#125;                  &#125; catch (IOException e) &#123;                      throw new RuntimeException(e);                  &#125;              &#125;)                        &#125;      &#125; catch (IOException e) &#123;          throw new RuntimeException(e);      &#125;  &#125;\n\n这么搞在人数比较少的前提下当然没什么问题，但如果同时连接的客户端足够多，那么每个连接都需要消耗一个线程，而如你所见，我们只给这个程序分配了 12 个线程，也就是说最大处理 12 个连接，这怎么够呢？有没有什么办法可以解决这个问题呢？当然有，我们可以通过异步 IO 来解决这个问题，像下面这样\npublic class Main &#123;      public static void main(String[] args) &#123;          try &#123;              ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();            //选用通道版本ServerSocket             serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8888));              //绑定端口            Selector selector = Selector.open();//创建一个选择器              serverSocketChannel.configureBlocking(false);            //默认状态下通道版本的Socket同样会在调用acept方法时阻塞直到有连接加入，我们这里手动配置为非阻塞            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);              //将这个通道注册到刚刚的选择器中，并要求选择器监听接受事件            ExecutorService executor = Executors.newFixedThreadPool(12);              while (true) &#123;                  Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                  Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                //从选择器中获得所有的事件并创造一个迭代器                  while (iterator.hasNext()) &#123;                      SelectionKey key = iterator.next();                      if (key.isAcceptable()) &#123;  //对于一个接受事件，放到线程池中要求线程池创建对应的Socket通道                        executor.execute(() -&gt; &#123;                              try &#123;                                  SocketChannel socketChannel = serverSocketChannel.accept();                                  socketChannel.configureBlocking(false);                                  //既然这也是一个通道那么自然也可以注册到选择器中，这次我们监听可读事件                                socketChannel.register(selector, SelectionKey.OP_READ);                              &#125; catch (IOException e) &#123;                                  throw new RuntimeException(e);                              &#125;                          &#125;);                        &#125; else if (key.isReadable()) &#123;                          executor.execute(() -&gt; &#123;                         //如果出现了可读事件，那么就执行对应的信心处理操作                            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                              SocketChannel socketChannel = (SocketChannel) key.channel();                              try &#123;                                  socketChannel.read(byteBuffer);                                  byteBuffer.flip();                                  String message = new String(byteBuffer.array());                                  System.out.println(message);                                  String message2 = &quot;收到信息&quot;+message;                                  socketChannel.write(ByteBuffer.wrap(message2.getBytes()));                              &#125; catch (IOException e) &#123;                                  throw new RuntimeException(e);                              &#125;                          &#125;);                        &#125;                    //最后记得将处理过的事件移除                      iterator.remove();                  &#125;                &#125;            &#125; catch (IOException e) &#123;              throw new RuntimeException(e);          &#125;      &#125;  &#125;\n不知道你能否理解这种写法的好处，在这种写法中，没有一个线程会陷入阻塞去等待客户端的消息，每个线程都是去处理一个已经存在的确定可行的事件，单个线程可以处理多个来自不同连接的消息。这就是我们所说的异步 IO 机制。首先解释一下上面的一些内容，通道的事件可以分为四种\n\nconnect 连接事件，说明与对应的资源建立起了连接，这种连接可以是网络连接也可以是与文件资源的连接\naccept 接受事件，监听到了对应的连接需求，可以与对应的资源建立连接\nread 读就绪事件，有内容可以从通道中读取\nwrite 写就绪事件，可以向通道中写入内容，这个事件在没有锁时一般是一直允许的当然，并不是所有的通道都实现了这四种事件，有些通道只支持部分事件。当我们将通道与对应的事件注册到选择器中时，选择器就会监听并记录对应通道的对应事件。通过这种方法，我们可以很好的避免单个线程陷入无意义的阻塞。大大提高单个线程的利用率。那么你可以猜猜选择器到底是怎样工作的？最简单的方法其实是选择器在每次被询问有哪些事件时通过对所有通道进行轮询，如果存在对应的事件则进行记录，但是显然这种机制在通道数足够多的状态下每次轮询都要消耗大量的时间，这完全不可接受，那该怎么办？聪明人们想到了一种办法：事件驱动机制\n\n什么是事件驱动机制？简单来说事件驱动就是通过对对应的事件增添一个回调处理器，这个回调处理器中的操作会在事件发生时执行，而只要在回调处理器的操作中添加通知选择器的操作即可。回调处理器的操作由事件发生所驱动，这样选择器就无需主动询问不同的通道而是被动的接收事件发生的信息，那么无论存在多少个通道，时间复杂度永远是 O (1);\nJava 中选择器的监听\n结语NIO 机制我们暂时先介绍到这里，你可以试着去改进一下上面的代码，重点有三个：\n\n如果连接数特别大一个线程作为监听线程显然不够，尝试着支持多个监听线程\n如果一个连接在客户端被断开，那么上面的代码是没法发现的，还会保留原有的通道，想办法改进（提示：通道的 read 方法会返回读取到的字节数，如果连接断开返回-1）\n我们不可能真的只对客户端的信息做如此简单的处理，想办法创建将上面的流程拆分成几个类，降低耦合度，然后要支持在 excute 方法中放入任意的 Runnable 类\n\n下一篇我们正式的去研究一下 SpringWeb 中的网络机制\n","tags":["手写Spring"]},{"title":"多线程与线程池","url":"/2025/04/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"今天我们来稍微了解一下线程与线程池的相关知识\n多线程的基本操作我们首先从最基本的Thread类讲起。我们知道多线程的基本使用方法大概如下\npublic class Main &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;Hello World&quot;);        &#125;);        thread.start();    &#125;&#125;\n\n每一个Thread对象都是一个单独的线程，当调用这个对象的start方法时这个线程就会被启动。我们可以看看Thread类的构造方法\npublic Thread(Runnable task) &#123;        this((ThreadGroup)null, (String)null, 0, task, 0L, (AccessControlContext)null);    &#125;\n\nemm具体的构造方法到底是怎么实现的暂时先不用管，我们这里只是用来明确我们刚才那个lambda表达式实际上是一个Runnable接口的实现，所以理所当然的，我们可以这样去实现多线程\npublic class Test implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;Hello World&quot;);    &#125;&#125;\n\n然后把这这个类的对象直接丢到线程类的构造方法中。或者你也可以选择继承Thread类，此时可以选择重写Thread类的run方法，然后直接调用子类的start方法。通过这样的方法可以给线程中运行的程序添加一些需要使用的参数\n但这种操作存在一个问题，run方法是void的，所以在某些情况下我们如果需要返回值，可以使用回调类Callable来实现\nimport java.util.concurrent.Callable;class MyCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        int sum = 0;        for (int i = 0; i &lt; 100; i++) &#123;            sum += i;        &#125;        return sum;    &#125;&#125;\n\n先随便定义一个回调类然后通过ExecutorService（实际上就是一个线程池）来运行\nimport java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class Test &#123;    public static void main(String[] args) &#123;        ExecutorService executor = Executors.newFixedThreadPool(2);//新建线程池        MyCallable callable = new MyCallable();        Future&lt;Integer&gt; future1 = executor.submit(callable);        Future&lt;Integer&gt; future2 = executor.submit(callable);        //这里稍微解释一下Future类，当我们使用Future去保存异步方法的返回值时及时运算还没有完成程序也会继续向下运行，直到调用get方法获取值时如果没有运算完成才会造成阻塞        try &#123;            System.out.println(&quot;线程 1 的结果：&quot; + future1.get());            System.out.println(&quot;线程 2 的结果：&quot; + future2.get());        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125; finally &#123;            executor.shutdown();        &#125;    &#125;&#125;\n\n如果你有一定的基础，上面的这些内容对你来说一定是非常简单的，下面我们来聊聊睡眠与锁的问题\n首先来看一个相当经典的例子\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        thread.start();        thread2.start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n此时a的值有很大的可能不是20000，为什么？两个线程分别加了10000次，为什么不是两千呢。非常简单，我们想象一下这个相加的过程：a被保存在内存中，线程1会首先从内存中读取这个值，然后放到累加器中进行累加，再将得到的值写回内存。但是这个过程存在一个问题：线程2也在做同样的事情，如果在线程1读取之后写回之前线程2进行读取，那么必然会导致最终的运算结果小于2000.所以这个问题该怎么解决？\n有一个相当愚蠢的做法是直接睡眠\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        thread.start();        thread2.start();        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n一个干完另一个继续干，这样就不会冲突了。但这样只能保证10000时不出问题，那么如果是一亿呢，睡1秒时间不够呢，如果是10呢，睡一秒又太过奢侈，所以我们这里又创造了更细致的控制方法，首先是interrupt方法\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            while (true)&#123;                if(Thread.currentThread().isInterrupted())&#123;                    break;                &#125;            &#125;//在没有收到中断信号之前始终处于死循环状态            Thread.interrupted();//将终端标记复位            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            for (int i = 1; i &lt;= 10000; i++) &#123;                a++;            &#125;            thread.interrupt();//向线程1发送中断信号        &#125;);        thread2.start();        thread.start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n我们可以看到通过这种方式可以灵活的控制一个线程的睡眠时间，确保结果正确\n当然，其实java在这方面的控制方法还是相当丰富的，我们随便写几个\nThread.currentThread().suspend();//在本线程内调度，直接暂停某个线程t.resume();//恢复t的运行\n\n你可以试着使用这两个方法对上面的代码进行修改，这两个方法相较interrrupt方法的优越性在与线程的暂停本质上是使当前线程处于阻塞状态，此时当前线程不会占用CPU资源，而上面的循环却会无意义的占用CPU资源。\n再看一看这个方法\npublic static void main(String[] args) &#123;    Thread t1 = new Thread(() -&gt; &#123;        System.out.println(&quot;线程1开始运行！&quot;);        for (int i = 0; i &lt; 50; i++) &#123;            System.out.println(&quot;1打印：&quot;+i);        &#125;        System.out.println(&quot;线程1结束！&quot;);    &#125;);    Thread t2 = new Thread(() -&gt; &#123;        System.out.println(&quot;线程2开始运行！&quot;);        for (int i = 0; i &lt; 50; i++) &#123;            System.out.println(&quot;2打印：&quot;+i);            if(i == 10)&#123;                try &#123;                    System.out.println(&quot;线程1加入到此线程！&quot;);                    t1.join();    //在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;);    t1.start();    t2.start();&#125;\n\n这里使用到了join方法，join方法其实可以认为是刚才上面的三个方法的结合，首先将t2阻塞，然后等待t1运行完成后t2收到信号恢复运行。\n接下来继续想办法改进这一段代码，我们需要引入锁的概念，我们之前提到了之所以在多线程状态下会出现问题是因为不同哦ing线程在竞争同一个资源，所以我们之前的解决方法是优先使某个线程使用该资源，在一个线程使用完成后再让其他线程使用。但是一个线程中真正使用资源的时间只占一部分，那么我们能不能想办法把这部分资源节约出来呢？我们就需要使用synchronized关键字\npackage Winter;public class Test &#123;    private static int a = 0;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            synchronized (Test.class) &#123;                for (int i = 1; i &lt;= 10000; i++) &#123;                    a++;                &#125;            &#125;        &#125;);        Thread thread2 = new Thread(() -&gt; &#123;            synchronized (Test.class) &#123;                for (int i = 1; i &lt;= 10000; i++) &#123;                    a++;                &#125;            &#125;        &#125;);        thread2.start();        thread.start();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(a);    &#125;&#125;\n\n所有的synchronized内的代码只能有一个线程执行，其余线程处于阻塞状态（其实你可以试着不用这个关键字而使用上面提到的方法来实现差不多的效果）\nsynchronized 关键自后括号内的是被加锁的对象，我们称这种锁为对象锁，该对象的锁只能被一个线程持有，只有持有锁的线程才能执行被加锁的代码。（这里使用的是Test类的Class对象），但不同的对象锁之间相互无影响\n当然，我们也有更灵活的写法，\nprivate static synchronized void add()&#123;    value++;&#125;\n\n这种写法被成为方法锁，只能有一个线程调用该方法。当然，这种写法实质上和对象锁是同一种东西，如果是静态方法，加锁对象为类的Class对象，如果是动态方法，加锁对象为方法所在对象。\n使用锁可以极大的发挥多线程优势，当然，要注意下面这种情况\npublic static void main(String[] args) throws InterruptedException &#123;    Object o1 = new Object();    Object o2 = new Object();    Thread t1 = new Thread(() -&gt; &#123;        synchronized (o1)&#123;//t1先启动，开始持有o1锁            try &#123;                Thread.sleep(1000);                synchronized (o2)&#123;//在持有o1锁的同时需要使用o2锁，等待o2锁，当前线程阻塞                    System.out.println(&quot;线程1&quot;);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    Thread t2 = new Thread(() -&gt; &#123;        synchronized (o2)&#123;//线程2持有o2锁            try &#123;                Thread.sleep(1000);                synchronized (o1)&#123;//等待o1锁，线程阻塞                    System.out.println(&quot;线程2&quot;);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    t1.start();    t2.start();&#125;\n\n此时两个线程均开始等待对方持有的锁，同时陷入阻塞，那么这两个线程都永远不会被唤醒，这种状态我们称之为死锁。\n另外，考虑到某些需求，我们需要在满足某些条件时主动的释放锁，交给其他线程，此时可以这样写\npublic static void main(String[] args) throws InterruptedException &#123;    Object o1 = new Object();    Thread t1 = new Thread(() -&gt; &#123;        synchronized (o1)&#123;            try &#123;                System.out.println(&quot;开始等待&quot;);                o1.wait();     //进入等待状态并释放锁                System.out.println(&quot;等待结束！&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    Thread t2 = new Thread(() -&gt; &#123;        synchronized (o1)&#123;            System.out.println(&quot;开始唤醒！&quot;);            o1.notify();     //唤醒处于等待状态的线程          \tfor (int i = 0; i &lt; 50; i++) &#123;               \tSystem.out.println(i);               &#125;          \t//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续        &#125;    &#125;);    t1.start();    Thread.sleep(1000);    t2.start();&#125;\n\n这种方法可以很好的控制锁的获取与释放。此外还有一个notifyall方法，这个方法可以直接唤醒所有处于等待的线程，而上面提到的notify只能唤醒随机的一个\n一些简单的进阶知识synchronized的实现机制首先回答我一个问题：锁机制的底层实现是怎样的？你可以猜一猜。\n在比较久远的时代，Java中的synchronized被成为重量级锁，实质上将获取锁与释放锁的操作映射为CPU实际线程的阻塞与唤醒，这一过程由操作系统负责调度。但是有一点令人不爽：实际的阻塞与唤醒操作是一种开销很大的操作，过于频繁的阻塞与唤醒会消耗大量资源，后来人们针对性的做出了一定的改进。\n改进的成果被称为自旋锁，什么是自旋锁？当线程需要获取锁时不再被阻塞，而是进入一个循环反复试图获取锁。等等，这难道不是越改经越回去了吗？但是仔细想想，在一个锁的所有权被频繁切换的场景下，这种操作是不是就可理解多了，最多不过是浪费几次循环的算力，相比阻塞与唤醒的操作，其消耗的资源少得多。但是在另一个方面，如果锁的切换不是那么频繁呢？那样就会消耗大量资源，所以经过改进的synchronized 实际上在初始状态下是一个自旋锁，在自旋时间超过一定的界限后就自动转换为一个重量级锁。\n但改进并没有停止，既然有重量级锁，那么必然有轻量级锁。轻量级锁是一种乐观锁，上面提到的两种锁都总是认为有其他的线程想要和自己抢夺资源，所以总是要自己实质上拥有锁，但乐观锁不这么认为，乐观锁如轻量级锁总是认为没有人和自己争抢锁，所以在运行时直接读内存并进行计算，但同时保存内存中的初始值，在运算完成后先将保存的初始值与当前内存中的值做比较，如果内存中的值与刚刚保存的值一致，说明这期间没有其他线程修改，直接将运算结果写回，如果发生了变化则说明有其他线程进行了修改，放弃此次操作，重头开始，如果这种机制多次失败，那么向上转化为自旋锁\n但优化还没有停止，人们又创造出了偏向锁。人们注意到，在某些情况下，一个对象很多时候都只被一个线程使用,所以直接在这个锁内部添加添加一条信息用于记录线程的id,如果id匹配，那么当前线程直接将这个对象当作无锁对象使用，直到有别的线程来尝试获取这个锁，此时偏向锁向轻量级锁升级。\n可以看到synchronized的机制实质上是一个逐渐升级的过程，从偏向锁开始逐渐的随着竞争的程度向上升级直到使用重量级锁。这个流程被称为锁粗化。\n内存可见性问题我们来看一看下面这段代码\npublic class Test &#123;      private static int a = 0;      public static void main(String[] args) throws InterruptedException &#123;          new Thread(() -&gt; &#123;              while (a == 0);              System.out.println(&quot;线程结束！&quot;);          &#125;).start();            Thread.sleep(1000);          System.out.println(&quot;正在修改a的值...&quot;);          a = 1;         &#125;  &#125;\n\n表面上看这段代码似乎不存在任何问题，但实际上这玩意会变成一个死循环，为什么呢？这里我们可以简单的介绍以下java的内存模型\njava的内存分为主内存和工作内存两个部分，所有的线程在实际的操作中会先从主内存读取值并存储到自己的工作内存中，然后进行使用，在更新值之后再将值写回主内存，其余时间一直在使用工作内存中的值。在上面的例子中，主线程更新了主内存中的值，但另一个线程实际上一直在循环使用工作线程中的值，并不知道主内存中的值已经被更新，导致出现死循环。\n这个问题到底该如何解决？最直接的办法就是加锁，当一个对象被加锁后每次调用时都会从工作内存刷新这个值,可以参考下面的这段代码，此时受到锁机制的影响，代码的循环是有限的\npublic class Main &#123;    private static int a = 0;    public static void main(String[] args) throws InterruptedException &#123;       new Thread(() -&gt; &#123;            while (a == 0) &#123;                synchronized (Main.class)&#123;&#125;            &#125;            System.out.println(&quot;线程结束！&quot;);        &#125;).start();        Thread.sleep(1000);        System.out.println(&quot;正在修改a的值...&quot;);        synchronized (Main.class)&#123;            a = 1;        &#125;    &#125;&#125;\n这里稍微解释一下，加锁的对象的Main的Class对象，Main类的静态属性正是包含在Class对象中的，此时对Class对象加锁，那么每次获得锁时都会从主内存内获取属性的实际值\n但是除了这种方法以外再没有别的办法了吗，还是有的，这里我们再介绍一个关键字volitale，我们可以重新修改之前的代码\npublic class Main &#123;    //添加volatile关键字    private static volatile int a = 0;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            while (a == 0) ;            System.out.println(&quot;线程结束！&quot;);        &#125;).start();        Thread.sleep(1000);        System.out.println(&quot;正在修改a的值...&quot;);        a = 1;    &#125;&#125;\n\n此时的代码也不会出现问题，这个关键字的功能在于两点\n\n保证不同线程之间数据的可见性\n阻止编译器的重排序，编译器在编译时可能对部分代码进行优化，其中一个比较重要的过程就是进行重排序调整代码的执行顺序，但是在多线程环境下这种重排序是可能出现问题的，所以对于跨线程调用的变量即使不加锁也至少应该使用这个关键字\n\n当然，还有一个小知识点，既然我们可以要求某个变量在多个线程内可见，那么也自然可以创造出仅在线程的工作内存内使用的属性，代码如下\npackage Winter;public class Main &#123;    public static void main(String[] args) &#123;        ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();        threadLocal.set(0);        Thread thread = new Thread(() -&gt; &#123;            threadLocal.set(1);            System.out.println(threadLocal.get());        &#125;);        thread.start();        System.out.println(threadLocal.get());            &#125;&#125;\nThreadLocal类中的值存储在每个线程的工作内存中，各自独立，互不干涉。可以被用来实现一些比较奇怪的需求，不过我个人似乎没怎么用过。\n现代锁框架接下来我们聊一聊现代锁框架。从java5开始，java的锁机制发生了一次重大更新，诞生了除了synchronized之外的另一套锁机制，这套锁机制更加的灵活，这里简单的介绍一下。\n现代锁框架主要涉及Lock类，Condition类以及几个原子类，我们首先可以看一看Lock类的接口\npublic interface Lock &#123;      void lock();//获取锁,如果拿不到锁会造成阻塞        void lockInterruptibly() throws InterruptedException;//获取锁且响应中断      boolean tryLock();  //尝试获取锁，但不会造成阻塞      boolean tryLock(long var1, TimeUnit var3) throws InterruptedException;//尝试获取锁，其中两个参数用来设置最大等待时间      void unlock();  //释放锁      Condition newCondition();  //这个下面讲&#125;\n\n这里再对lockInterruptibly方法做一点解释，这个方法提供了对中断的支持，我们前面提到每个线程都会有一个interrupt方法,这个方法不会真的打断线程，只是对线程进行一个通知，Lock类中的lockInterruptibly方法可以监测这个通知，当收到通知时即使处在阻塞状态也会直接抛出InterruptedException异常\n此时的锁从一个依赖于具体对象的关键字变成了一个实际存在的锁对象，这在设计上显然符合Java的万物皆对象的思想，接下来我们可以来简单的了解一下Condition类，这个类可以被认为是Object类中wait方法的上位替代，可以简单的看一下\npublic interface Condition &#123;      void await() throws InterruptedException;  //相当与wait      void awaitUninterruptibly();  //相当于wait但不会被中断      long awaitNanos(long var1) throws InterruptedException;//  等待固定的时间，如果在时间内唤醒则返回剩余时间，如果超时则返回负数，注意单位是纳秒      boolean await(long var1, TimeUnit var3) throws InterruptedException;//同上但支持更细致的时间控制        boolean awaitUntil(Date var1) throws InterruptedException;  //等待到固定的时间点      void signal();  //唤醒随机的一个      void signalAll();  //唤醒全部&#125;\n\n一个Lock下可以包含多个Conditon,来实现更细致的控制。\n特别说明，上面两个类的方法中涉及类TimeUtil类，这是一个枚举类，指的是时间的单位\n可重入锁接下来介绍Lock接口的两个重要实现：可重入锁与读写锁，我们先来了解一下可重入锁。所谓的可重入锁指的是可以被多次加锁的锁对象，大概就像这样\npublic class Main &#123;    public static void main(String[] args) &#123;        Lock lock = new ReentrantLock();        lock.lock();//可以反复加锁        lock.lock();        ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();        threadLocal.set(0);        Thread thread = new Thread(() -&gt; &#123;        lock.lock();//尝试获得锁，进入阻塞            System.out.println(&quot;获得锁&quot;);        &#125;);        thread.start();        lock.unlock();        System.out.println(&quot;第一次释放锁&quot;);        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(&quot;第二次释放锁&quot;);        lock.unlock();    &#125;&#125;\n可以看到我们在第一次释放锁后thread并没有获得锁，而是等到两次释放锁之后才真正获得了锁。\n此处我们进一步引入公平锁与非公平锁的概念，两者的区别如下\n\n公平锁中维护了一个等待队列，所有尝试获取锁的线程都将进入这个队列，按照先进先出的顺序来获取锁\n非公平锁中同样拥有一个等待队列，但此时当一个线程需要获取锁时会尝试先获取锁，如果获取失败则进入等待队列\n\n我们上面展示的可重入锁就是非公平锁，不过我们也可以选择公平锁模式，就像这样\nLock lock = new ReentrantLock(true);\n此时的锁就是一个公平锁\n读写锁接下来我们介绍读写锁，这种锁的创造时考虑到了这样一个事实：对同一个变量，部分线程只需要读取，部分线程需要修改，而对于只有读取需求的线程来说，可以不占用锁。在这种情况下，读写锁将锁分成了两部分：\n\n读锁：在没有任何线程占用写锁的情况下可以被多个线程获取\n写锁：在没有任何线程占用读锁的情况下可以被唯一一个线程获取\n\n大致的使用方式如下\npublic class Main &#123;    public static void main(String[] args) &#123;        ReentrantReadWriteLock lock = new ReentrantReadWriteLock();        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;加写锁&quot;);            lock.writeLock().lock();            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(&quot;释放写锁&quot;);            lock.writeLock().unlock();            System.out.println(&quot;加读锁&quot;);            lock.readLock().lock();        &#125;);        thread.start();        lock.writeLock().lock();        System.out.println(&quot;获得写锁&quot;);        lock.writeLock().unlock();        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        lock.readLock().lock();        System.out.println(&quot;获取写锁&quot;);    &#125;&#125;\n\n这种锁在部分线程需要读取部分线程需要写入时很好的满足了需求\n原子类有些时候我们只需要一些简单的操作，此时为了简化操作，人们又创造了原子类，类中所有的方法都是线程安全的。原子类包含三种\n\nAtomicInteger：原子更新int\nAtomicLong：原子更新long\nAtomicBoolean：原子更新boolean由于在使用上比较简单，我这里只放一个例子，就不做具体的解释了\n\npublic class Main &#123;    private static AtomicInteger i = new AtomicInteger(0);    public static void main(String[] args) throws InterruptedException &#123;        Runnable r = () -&gt; &#123;            for (int j = 0; j &lt; 100000; j++)                i.getAndIncrement();            System.out.println(&quot;自增完成！&quot;);        &#125;;        new Thread(r).start();        new Thread(r).start();        TimeUnit.SECONDS.sleep(1);        System.out.println(i.get());    &#125;&#125;\n\n并发容器最后再介绍一下jdk提供的并发容器，我们之前习惯的ArrayList，HashMap等容器实际上是线程不安全的，我们这里可以使用线程安全的并发容器，比较常用的包括\n\nCopyOnWriteArrayList\nConcurrentHashMap\nBlockingQueue由于在使用时与普通容器没什么大的区别，这里就不做介绍了\n\n线程池接下来我们来了解一下java的线程池相关内容，线程的创建与销毁是一个开销很大的工作，所以我们倾向于在有长期使用需要时创建一个线程池，一次性创建足够的线程病保存在池中，之后只使用池中线程java提供了一个原生的线程池实现，大概使用方式如下\npublic class Main &#123;    public static void main(String[] args) &#123;        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5, 0L,                TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(200));        for (int i = 0; i &lt; 10; i++) &#123;            executor.execute(() -&gt; &#123;                System.out.println(Thread.currentThread().getName());            &#125;);        &#125;        System.exit(0);    &#125;&#125;\n\n接下来我们去底层看一看到底是做了什么，下面是全参的构造方法\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;        this.ctl = new AtomicInteger(ctlOf(-536870912, 0));        this.mainLock = new ReentrantLock();        this.workers = new HashSet();        this.termination = this.mainLock.newCondition();        if (corePoolSize &gt;= 0 &amp;&amp; maximumPoolSize &gt; 0 &amp;&amp; maximumPoolSize &gt;= corePoolSize &amp;&amp; keepAliveTime &gt;= 0L) &#123;            if (workQueue != null &amp;&amp; threadFactory != null &amp;&amp; handler != null) &#123;                this.corePoolSize = corePoolSize;                this.maximumPoolSize = maximumPoolSize;                this.workQueue = workQueue;                this.keepAliveTime = unit.toNanos(keepAliveTime);                this.threadFactory = threadFactory;                this.handler = handler;                String name = Objects.toIdentityString(this);                this.container = SharedThreadContainer.create(name);            &#125; else &#123;                throw new NullPointerException();            &#125;        &#125; else &#123;            throw new IllegalArgumentException();        &#125;    &#125;\n我们先简单的看一下各个参数\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;\n下面是名词解释：\n\ncorePoolSize：核心线程数量\nmaximumPoolSize：最大线程数量\nkeepAliveTime：非核心线程等待时间\nunit：等待时间的单位\nworkQueue：任务队列\nthreadFactory：线程工厂\nhandaler：拒绝策略线程池中的线程被分为核心线程与非核心线程，所有的任务都被放入任务队列中，线程从任务队列中获取任务进行执行，如果所有核心线程都有任务，就注册新的非核心线程进行处理，如果达到最大线程数量就将任务保留在任务队列中，如果任务队列已满，则按照拒绝策略进行处理\n\n我们再来看一看exucute方法具体的实现\npublic void execute(Runnable command) &#123;       if (command == null) &#123;           throw new NullPointerException();       &#125; else &#123;           int c = this.ctl.get();//此处稍微解释一下，ctl这个变量同时存储了线程池中工作线程的数量和线程池的状态，需要通过位运算分离           //如果正在工作的线程数小于核心线程数，直接将任务给核心线程中           if (workerCountOf(c) &lt; this.corePoolSize) &#123;               if (this.addWorker(command, true)) &#123;                   return;               &#125;               c = this.ctl.get();//此时没有成功的插入任务，说明发生了某种异常，重新获取ctl           &#125;           //isRunning方法检查线程池是否正在运行，尝试将任务放到任务队列           if (isRunning(c) &amp;&amp; this.workQueue.offer(command)) &#123;               int recheck = this.ctl.get();//再次检查线程池的工作状态               if (!isRunning(recheck) &amp;&amp; this.remove(command)) &#123;                   this.reject(command);//此分支说明线程池被设置为拒绝加入，使用拒绝策略               &#125; else if (workerCountOf(recheck) == 0) &#123;                   this.addWorker((Runnable)null, false);//此分支说明线程池中无线程               &#125;           &#125; else if (!this.addWorker(command, false)) &#123;//尝试将线程放到非核心线程中               this.reject(command);           &#125;       &#125;   &#125;\n\n这里有一个额外需要解释的点事ctl,这个原子整数中保存了一个32位的int,其中部分位用来保存线程池的状态,部分位用来保存线程池中线程的数量,通过位运算获得具体位的数字得到信息\n我们可以继续深入,看看addWorker方法干了些什么\nprivate boolean addWorker(Runnable firstTask, boolean core) &#123;        for(int c = this.ctl.get(); !runStateAtLeast(c, 0) || !runStateAtLeast(c, 536870912) &amp;&amp; firstTask == null &amp;&amp; !this.workQueue.isEmpty(); c = this.ctl.get()) &#123;            while(workerCountOf(c) &lt; ((core ? this.corePoolSize : this.maximumPoolSize) &amp; 536870911)) &#123;//这个奇奇怪怪的长整数转换为二进制为 `00011111111111111111111111111111`，是用来和ctl做位运算获得线程池的不同信息的                if (this.compareAndIncrementWorkerCount(c)) &#123;//此处利用CAS操作增加c的值                    c = 0;                    boolean workerAdded = false;                    Worker w = null;                    try &#123;                        w = new Worker(firstTask);//创建一个Worker,其实就是Thread套皮                        Thread t = w.thread;                        if (t != null) &#123;                            ReentrantLock mainLock = this.mainLock;                            mainLock.lock();                            try &#123;                                int c = this.ctl.get();                                if (isRunning(c) || runStateLessThan(c, 536870912) &amp;&amp; firstTask == null) &#123;                                    if (t.getState() != State.NEW) &#123;                                        throw new IllegalThreadStateException();                                    &#125;                                    this.workers.add(w);                                    workerAdded = true;                                    int s = this.workers.size();                                    if (s &gt; this.largestPoolSize) &#123;                                        this.largestPoolSize = s;                                    &#125;                                &#125;                            &#125; finally &#123;                                mainLock.unlock();                            &#125;                            if (workerAdded) &#123;                                this.container.start(t);                                c = 1;                            &#125;                        &#125;                    &#125; finally &#123;                        if (!c) &#123;                            this.addWorkerFailed(w);                        &#125;                    &#125;                    return (boolean)c;                &#125;            &#125;            return false;        &#125;        return false;    &#125;\n看不懂没关系,我们来直接自己实现一个线程池,只实现最基本的功能，一切追求简单\npublic class ThreadPool &#123;    private AtomicInteger coreThreadCount;    private AtomicInteger maxThreadCount;    private ArrayBlockingQueue&lt;Runnable&gt; workQueue;    private AtomicInteger activeThreadCount;    private long activeTime;    public ThreadPool(int coreThreadCount, int maxThreadCount,int workQueueSize, int activeThreadCount) &#123;      this.coreThreadCount = new AtomicInteger(coreThreadCount);      this.maxThreadCount = new AtomicInteger(maxThreadCount);      this.workQueue = new ArrayBlockingQueue&lt;&gt;(workQueueSize);      this.activeThreadCount = new AtomicInteger(0);      this.activeTime = activeThreadCount;  &#125;//简单的构造方法，全都是直接赋值        public void excute(Runnable task) &#123;        if(activeThreadCount.get()&lt;coreThreadCount.get())&#123;            Thread thread = new Thread(()-&gt;&#123;                task.run();                while(true)&#123;                    Runnable r = workQueue.poll();//这里直接利用阻塞队列的特性，如果队列中没有任务会陷入阻塞                    if(r!=null)&#123;                        r.run();                    &#125;                &#125;            &#125;);//核心线程反复尝试获取任务，注册后用不销毁            thread.start();            activeThreadCount.incrementAndGet();            coreThreadCount.incrementAndGet();        &#125; else if (activeThreadCount.get()&lt;maxThreadCount.get()) &#123;            Thread thread = new Thread(()-&gt;&#123;                task.run();                while(true)&#123;                    try &#123;                    Runnable r = workQueue.poll(activeTime,TimeUnit.MILLISECONDS);                    //此处设置非核心线程的等待时间，如果时间超过了设置的时间还没有任务则退出                    if(r!=null)&#123;                        r.run();                    &#125;                    &#125;catch (InterruptedException e)&#123;                        activeThreadCount.decrementAndGet();//记得在销毁线程时活动线程数减1                        break;                    &#125;                &#125;            &#125;);            thread.start();            activeThreadCount.incrementAndGet();        &#125;else &#123;            throw new RuntimeException(&quot;超出最大线程数量&quot;);        &#125;    &#125;    &#125;\n我们总计使用了56行就实现了一个最为简单的线程池，当然，你也可以试着自己优化这个线程池，加点什么状态控制，拒绝策略等等，但后面都是一些很好实现的东西了。\n工具类最后的最后我们还需要了解一下几个简单的工具类\nCountDownLatch计数器锁假设我们存在一个多线程任务，我们需要所有线程都完成后再在主线程执行下一步，各个线程执行时间未知，该怎么实现？我们可以使用计数器锁，大概如下\npublic class Main &#123;    public static void main(String[] args) &#123;        CountDownLatch countDownLatch = new CountDownLatch(10);//计数器中有10个数        Runnable runnable = new Runnable() &#123;            public void run() &#123;                try&#123;                    Thread.sleep(1000);                    countDownLatch.countDown();//每次调用这个方法都将初始的值减1                &#125;catch (InterruptedException e)&#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(runnable).start();        &#125;        countDownLatch.await();//等待减到0才会执行下一步        System.out.println(&quot;All done&quot;);            &#125;&#125;\n\nCyclicBarrier循环屏障上面我们使用for循环来启动了10个线程，但在某些需求下我们可能会要求线程同步启动，此时可以使用循环屏障\npublic static void main(String[] args) &#123;    CyclicBarrier barrier = new CyclicBarrier(10,   //创建一个初始值为10的循环屏障                () -&gt; System.out.println(&quot;飞机马上就要起飞了，各位特种兵请准备！&quot;));   //人等够之后执行的任务    for (int i = 0; i &lt; 10; i++) &#123;        int finalI = i;        new Thread(() -&gt; &#123;            try &#123;                Thread.sleep((long) (2000 * new Random().nextDouble()));                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入房间进行等待... (&quot;+barrier.getNumberWaiting()+&quot;/10)&quot;);                barrier.await();    //调用await方法进行等待，直到等待的线程足够多为止                //开始游戏，所有玩家一起进入游戏                System.out.println(&quot;玩家 &quot;+ finalI +&quot; 进入游戏！&quot;);            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n直到达到要求的线程数量所有线程才能进入下一步\n此外，循环屏障可以被重复使用，每次达到约定的线程后都会重置；\nExchanger数据交换类借助这个类我们可以实现不同线程之间的数据交换，大概如下\npublic static void main(String[] args) throws InterruptedException &#123;    Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();    new Thread(() -&gt; &#123;        try &#123;            System.out.println(&quot;收到主线程传递的交换数据：&quot;+exchanger.exchange(&quot;AAAA&quot;));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;).start();    System.out.println(&quot;收到子线程传递的交换数据：&quot;+exchanger.exchange(&quot;BBBB&quot;));&#125;\n\n我个人感觉有那么点鸡肋；\n结语好的，到这里多线程的部分就算结束了，下一期我们来研究一下HTTP解析，实现简单的网络通讯。\n\n","tags":["手写Spring"]},{"title":"网络通信","url":"/2025/05/08/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","content":"今天我们来聊聊网络通信的部分，我们知道的是Spring框架使用的是一个名为DispatchServlet的类作为网络通信的处理器，而这个类实际上来自于TomCat中的Servlet，我们先一层层推进看看这些东西到底是怎么实现的\nDispatchServlet分析从流程上看，首先存在一个简单的服务器用于监听端口，一般是TomCat，在TomCat发现请求后会转发给DisPatchServlet中的doService方法，其实现如下\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;      this.logRequest(request);      Map&lt;String, Object&gt; attributesSnapshot = null;      if (WebUtils.isIncludeRequest(request)) &#123;          attributesSnapshot = new HashMap();          Enumeration&lt;?&gt; attrNames = request.getAttributeNames();          while(attrNames.hasMoreElements()) &#123;              String attrName = (String)attrNames.nextElement();              if (this.cleanupAfterInclude || attrName.startsWith(&quot;org.springframework.web.servlet&quot;)) &#123;                  attributesSnapshot.put(attrName, request.getAttribute(attrName));              &#125;          &#125;      &#125;      request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.getWebApplicationContext());      request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);      request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);      request.setAttribute(THEME_SOURCE_ATTRIBUTE, this.getThemeSource());      if (this.flashMapManager != null) &#123;          FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);          if (inputFlashMap != null) &#123;              request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));          &#125;          request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());          request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);      &#125;      RequestPath previousRequestPath = null;      if (this.parseRequestPath) &#123;          previousRequestPath = (RequestPath)request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);          ServletRequestPathUtils.parseAndCache(request);      &#125;    //上面的一大堆都是缓存机制和纠错机制，有兴趣的可以自己学习，其实很简单      try &#123;          this.doDispatch(request, response);//这里是重点，开始分发      &#125; finally &#123;          if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != null) &#123;              this.restoreAttributesAfterInclude(request, attributesSnapshot);          &#125;          if (this.parseRequestPath) &#123;              ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);          &#125;      &#125;  &#125;\n也就是说真正的分发出现在doDispatch方法中，我们再去这个方法看一看发生了什么\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;      HttpServletRequest processedRequest = request;      HandlerExecutionChain mappedHandler = null;      boolean multipartRequestParsed = false;      WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);      try &#123;          try &#123;              ModelAndView mv = null;              Exception dispatchException = null;              try &#123;                  processedRequest = this.checkMultipart(request);//检查是否是Multipart类型的请求                  multipartRequestParsed = processedRequest != request;                //在这一步获得一个包含了我们自定义的Controller和拦截器的处理器                  mappedHandler = this.getHandler(processedRequest);                  if (mappedHandler == null) &#123;                      this.noHandlerFound(processedRequest, response);                      return;                  &#125;                  HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());                  String method = request.getMethod();                  boolean isGet = HttpMethod.GET.matches(method);//判断是否的Get类型的请求                  if (isGet || HttpMethod.HEAD.matches(method)) &#123;                //对方法为Get的请求，使用getLastModified方法检查锁请求的资源是否发生变动，如果资源没有发生修改则返回304，说明资源没有发生变动，要求使用客户端缓存的资源                      long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                      if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;                          return;                      &#125;                  &#125;                //这里开始调用拦截器的prehandle方法，如果方法返回false那么直接返回拒绝执行                  if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;                      return;                  &#125;                //在这里真正执行了处理器中的内容，获得了一个ModeAndView对象                  mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                  if (asyncManager.isConcurrentHandlingStarted()) &#123;                      return;                  &#125;                //这一步用于检查是否包含View视图，如果包含那么将视图用request命名                  this.applyDefaultViewName(processedRequest, mv);                //这一步开始再次调用拦截器，处理拦截器中的postHandle                mappedHandler.applyPostHandle(processedRequest, response, mv);              &#125; catch (Exception ex) &#123;                  dispatchException = ex;              &#125; catch (Throwable err) &#123;                  dispatchException = new ServletException(&quot;Handler dispatch failed: &quot; + err, err);              &#125;            //这一步实际上将结果返回              this.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);          &#125; catch (Exception ex) &#123;              triggerAfterCompletion(processedRequest, response, mappedHandler, ex);          &#125; catch (Throwable err) &#123;              triggerAfterCompletion(processedRequest, response, mappedHandler, new ServletException(&quot;Handler processing failed: &quot; + err, err));          &#125;      &#125; finally &#123;          if (asyncManager.isConcurrentHandlingStarted()) &#123;              if (mappedHandler != null) &#123;                  mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);              &#125;          &#125; else if (multipartRequestParsed) &#123;              this.cleanupMultipart(processedRequest);          &#125;      &#125;  &#125;\n\n好的，我们现在发现追到可processDispatchResult方法，我们继续查看，看看这个方法干了什么\nprivate void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123;      boolean errorView = false;    //公共的异常处理流程      if (exception != null) &#123;          if (exception instanceof ModelAndViewDefiningException) &#123;              ModelAndViewDefiningException mavDefiningException = (ModelAndViewDefiningException)exception;              this.logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);              mv = mavDefiningException.getModelAndView();          &#125; else &#123;              Object handler = mappedHandler != null ? mappedHandler.getHandler() : null;              mv = this.processHandlerException(request, response, handler, exception);              errorView = mv != null;          &#125;      &#125;    //尝试对可能存在的视图进行渲染  \t    if (mv != null &amp;&amp; !mv.wasCleared()) &#123;\t    //调用渲染方法，如果存在视图名则进行渲染否则什么都不做，将渲染结果写到response中         this.render(mv, request, response);          if (errorView) &#123;              WebUtils.clearErrorRequestAttributes(request);          &#125;      &#125; else if (this.logger.isTraceEnabled()) &#123;          this.logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);      &#125;    //在不存在异步处理机制的情况下执行，异步处理有一套独立的机制      if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;          if (mappedHandler != null) &#123;        //调用拦截器中的AfterCompletion方法              mappedHandler.triggerAfterCompletion(request, response, (Exception)null);          &#125;      &#125;  &#125;\n\n到这里Spring的处理流程就已经结束了，剩下的部分由TomCat完成，将对应的相应返回。\nTomCat机制分析通过上面的那些分析，我们已经走完了Spring在网络通信中负责的任务，接下来我们就要去TomCat中看一看了，研究一下在实际的网络通信流程中TomCat到底在干什么。\n接下来的内容需要你对 java 的异步 IO 机制有一定的了解，可以参考NIO 机制\nTomCat有几个核心组件，分别是Connector,Server,Service.当我们通过脚本启动TomCat时这几个组件都会开始运行，其中Connecter负责监听端口，所以我们先从这个组件开始\n在启动这个组件时会调用下面的方法\nprotected void startInternal() throws LifecycleException &#123;      String id = this.protocolHandler != null ? this.protocolHandler.getId() : null;    //一连串的异常检查      if (id == null &amp;&amp; this.getPortWithOffset() &lt; 0) &#123;          throw new LifecycleException(sm.getString(&quot;coyoteConnector.invalidPort&quot;, new Object[]&#123;this.getPortWithOffset()&#125;));      &#125; else &#123;          this.setState(LifecycleState.STARTING);          if (this.protocolHandler != null &amp;&amp; this.service != null) &#123;              this.protocolHandler.setUtilityExecutor(this.service.getServer().getUtilityExecutor());//获取一个用于处理非核心任务的线程池          &#125;          try &#123;              this.protocolHandler.start();//启动协议处理器          &#125; catch (Exception e) &#123;              throw new LifecycleException(sm.getString(&quot;coyoteConnector.protocolHandlerStartFailed&quot;), e);          &#125;      &#125;  &#125;\n我们注意到这个方法的实质就是在进行了几个基本的检查之后启动了一个叫做 protocolHandler 的对象，这个对象被称为协议处理器，这个处理器有多个实现用来适配不同的协议如HTTP1.0,HTTP1.1,AJP等，我们这里以当下比较常用的HTTP1.1为例，HTTP1.1对应的协议处理器叫做 HTTP11NIOProtocol,但你会发现里面并没有start方法的实现，往上找几层继承后你会来到一个叫做 AbstractProtocol 的类，这个类中实现了start方法\npublic void start() throws Exception &#123;      if (this.getLog().isInfoEnabled()) &#123;          this.getLog().info(sm.getString(&quot;abstractProtocolHandler.start&quot;, new Object[]&#123;this.getName()&#125;));          this.logPortOffset();      &#125;//获取日志对象记录日志      this.endpoint.start();//endpoint是TomCat自己实现的线程池，启动线程池      this.monitorFuture = this.getUtilityExecutor().scheduleWithFixedDelay(() -&gt; this.startAsyncTimeout(), 0L, 60L, TimeUnit.SECONDS);//调用之前Connecter设置的非核心任务的线程池，添加一个定时任务，作用是每60秒启动检查是否有异步任务超时  &#125;\n这部分的核心是启动了线程池，我们继续前进看看这个线程池的启动方法\n//start方法实现在AbstractEndPoint类public final void start() throws Exception &#123;      if (this.bindState == AbstractEndpoint.BindState.UNBOUND) &#123;//检查端口绑定状态，如果等于没有绑定          this.bindWithCleanup();//进行绑定并执行必要的清理工作        this.bindState = AbstractEndpoint.BindState.BOUND_ON_START;      &#125;      this.startInternal();//内部启动  &#125;\n我们先看看这个绑定端口的方法，这个方法的实现有两个版本，分别是NioEndPoint和Nio2EndPoint，这两个类分别使用了java的1.0和2.0的NIO API，我们这里统一看2.0版本的API\n//上面那个有清理的bindWithCleanup就是在下面这个方法外套了一个异常捕获public void bind() throws Exception &#123;      if (this.getExecutor() == null) &#123;          this.createExecutor();//如果线程池不存在那么创建一个新的线程池     &#125;      if (this.getExecutor() instanceof ExecutorService) &#123;          this.threadGroup = AsynchronousChannelGroup.withThreadPool((ExecutorService)this.getExecutor());  \t    &#125;//创建一个异步服务套接字组共享上面创建的线程池,负责接下来的实际网络通信    if (!this.internalExecutor) &#123;          log.warn(sm.getString(&quot;endpoint.nio2.exclusiveExecutor&quot;));//检查线程池是否是TomCat内部创建的，如果不是则做出警告     &#125;      this.serverSock = AsynchronousServerSocketChannel.open(this.threadGroup);//打开上面的套接字组    this.socketProperties.setProperties(this.serverSock);//配置套接字相关的属性      InetSocketAddress addr = new InetSocketAddress(this.getAddress(), this.getPortWithOffset());//创建监听端口的相关信息      this.serverSock.bind(addr, this.getAcceptCount());//绑定端口     this.initialiseSsl();//初始化ssl相关内容&#125;\n\n我们暂时就到这一步，有兴趣的话可以自己进一步看看异步套接字组的实现，接下来我们看看另一个内部启动方法，我们继续选择NIO2版本的实现\npublic void startInternal() throws Exception &#123;      if (!this.running) &#123;          this.allClosed = false;          this.running = true;          this.paused = false;          if (this.socketProperties.getProcessorCache() != 0) &#123;              this.processorCache = new SynchronizedStack(128, this.socketProperties.getProcessorCache());          &#125;//创建一个线程安全的栈作为处理器缓存         int actualBufferPool = this.socketProperties.getActualBufferPool(this.isSSLEnabled() ? this.getSniParseLimit() * 2 : 0);          if (actualBufferPool != 0) &#123;              this.nioChannels = new SynchronizedStack(128, actualBufferPool);          &#125;//创建缓存池来缓存网络IO中的建立的通道        if (this.getExecutor() == null) &#123;              this.createExecutor();          &#125;          this.initializeConnectionLatch();//创建一个连接计数器          this.startAcceptorThread();//初始化监听线程     &#125;  &#125;\n我们继续往下追查监听线程的任务，\nprotected void startAcceptorThread() &#123;      if (this.acceptor == null) &#123;          this.acceptor = new Nio2Acceptor(this);          this.acceptor.setThreadName(this.getName() + &quot;-Acceptor&quot;);      &#125;      this.acceptor.state = AcceptorState.RUNNING;      this.getExecutor().execute(this.acceptor);  &#125;//看来下一个目标是acceptor\n我直接贴对应的run方法\npublic void run() &#123;      if (!Nio2Endpoint.this.isPaused()) &#123;          try &#123;              Nio2Endpoint.this.countUpOrAwaitConnection();//计数或等待连接，如果连接数没有达到最大那么计数器加一，如果达到最大则当前线程等待          &#125; catch (InterruptedException var2) &#123;          &#125;          if (!Nio2Endpoint.this.isPaused()) &#123;              Nio2Endpoint.this.serverSock.accept((Object)null, this);// 监听端口然后处理信息          &#125; else &#123;              this.state = AcceptorState.PAUSED;          &#125;      &#125; else &#123;          this.state = AcceptorState.PAUSED;      &#125;  &#125;\n好吧，我们的下一步是accept方法，这个方法在叠了几层继承后有这样的实现,看起来有点复杂\nFuture&lt;AsynchronousSocketChannel&gt; implAccept(Object att, CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; handler) &#123;      if (!this.isOpen()) &#123;//如果没有打开，那么直接进入异常处理流程          Throwable e = new ClosedChannelException();          if (handler == null) &#123;              return CompletedFuture.withFailure(e);          &#125; else &#123;              Invoker.invoke(this, handler, att, (Object)null, e);              return null;          &#125;      &#125; else if (this.localAddress == null) &#123;          throw new NotYetBoundException();      &#125; else if (this.isAcceptKilled()) &#123;          throw new RuntimeException(&quot;Accept not allowed due cancellation&quot;);      &#125; else if (!this.accepting.compareAndSet(false, true)) &#123;          throw new AcceptPendingException();      &#125; else &#123;//从这里开始进入正常情况的处理流程          FileDescriptor newfd = new FileDescriptor();          InetSocketAddress[] isaa = new InetSocketAddress[1];          Throwable exc = null;          try &#123;              this.begin();//这里只是简单的为接下来的操作加了一个读锁              int n = Net.accept(this.fd, newfd, isaa);//这个方法是使用C++实现的，看不了源码，比较遗憾，但就是这个方法实现了对端口的监听，其中this.fd就是对之前绑定的端口的描述,返回的n是接收到的可用连接数             if (n == -2) &#123;//如果n是-2，当前不存在可用的连接事件                PendingFuture&lt;AsynchronousSocketChannel, Object&gt; result = null;                  synchronized(this.updateLock) &#123;                      if (handler == null) &#123;                          this.acceptHandler = null;                          result = new PendingFuture(this);                          this.acceptFuture = result;                      &#125; else &#123;                          this.acceptHandler = handler;                          this.acceptAttachment = att;                      &#125;                      this.acceptAcc = System.getSecurityManager() == null ? null : AccessController.getContext();                      this.acceptPending = true;                  &#125;                  this.port.startPoll(this.fdVal, Net.POLLIN);                //这里是通过对系统底层的异步IO机制注册事件监听，相当于向选择器注册对对应事件的监听                  PendingFuture var8 = result;                //既然不存在可用的监听事件，那么返回一个PendingFuture表示待处理并结束当前线程的运行                  return var8;              &#125;          &#125; catch (Throwable var17) &#123;              Throwable x = var17;              if (var17 instanceof ClosedChannelException) &#123;                  x = new AsynchronousCloseException();              &#125;              exc = x;          &#125; finally &#123;              this.end();//释放读锁          &#125;          AsynchronousSocketChannel child = null;          if (exc == null) &#123;              try &#123;                  child = this.finishAccept(newfd, isaa[0], (AccessControlContext)null);                //这里创建了一个新的异步通道，将由这个异步通道负责接下来对连接的处理              &#125; catch (Throwable x) &#123;                  exc = x;              &#125;          &#125;          this.enableAccept();//重置标志位，运行继续创建连接          if (handler == null) &#123;//如果没有提供完成处理器，那么返回一个表示完成的future对象              return CompletedFuture.withResult(child, exc);  \t        &#125; else &#123;\t        //如果存在回调处理器那么调用处理器进行处理，注意，这里的回调并不是发生在当前线程              Invoker.invokeIndirectly(this, handler, att, child, exc);             return null;          &#125;      &#125;  &#125;\n这里要特别说明两个关键点\n\n文件描述符：上面的方法中使用了文件描述符来指代一个网络通信，这来自于unix系统的万物皆文件的思想，注意，这个类本身就叫做UnixAsynchronousServerSocketChannelImpl，在操作系统中所有的文件都有一个非负的整数作为标识，而万物皆文件，自然而然的网络连接也是一个文件，所以我们通过这个数字来访问网络通信（注意，这是 Linux 版本的实现方式，在 Windows 上存在另一套实现方式）\n第二个问题是我们一直捋到这里都没有发现一个循环机制，那么为什么可以持续监听端口？我们这里选择的是nio2版本的处理流程，如果你选择去查看nio1.0版本的流程，你会发现一个while循环，但在新的版本中使用了另一种的办法：回调机制我们可以从头捋一捋这一套机制，首先回到 Nio2EndPointAcceptor 这个类，这个类的声明如下\n\nprotected class Nio2Acceptor extends Acceptor&lt;AsynchronousSocketChannel&gt;      implements CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;\n可以看到这个类实现了一个叫做 CompletionHandler 的接口，也就是我们前面提到的完成处理器，结构如下\npublic interface CompletionHandler&lt;V, A&gt; &#123;      void completed(V var1, A var2);        void failed(Throwable var1, A var2);  &#125;\n这个接口的实现规定了当某种操作结束时针对是否失败的不同情况的不同处理方法，而 Acceptor 中对 Completed 方法的实现如下\n public void completed(AsynchronousSocketChannel socket,          Void attachment) &#123;      // Successful accept, reset the error delay      errorDelay = 0;      // Continue processing the socket on the current thread      // Configure the socket    if (isRunning() &amp;&amp; !isPaused()) &#123;          if (getMaxConnections() == -1) &#123;              serverSock.accept(null, this);          &#125; else if (getConnectionCount() &lt; getMaxConnections()) &#123;              try &#123;                  // This will not block                  countUpOrAwaitConnection();//如果当前连接数小于最大值则当前连接数加1，否则阻塞             &#125; catch (InterruptedException e) &#123;                  // Ignore              &#125;              serverSock.accept(null, this); //看，这里有一次调用了accept方法        &#125; else &#123;              // Accept again on a new thread since countUpOrAwaitConnection may block              getExecutor().execute(this);          &#125;        //         if (!setSocketOptions(socket)) &#123;              closeSocket(socket);          &#125;      &#125; else &#123;          if (isRunning()) &#123;              state = AcceptorState.PAUSED;          &#125;          destroySocket(socket);      &#125;  &#125;\n还记得吗，Acceptor 的 run 方法实现其实也是调用了 serverSock.accept(null, this) 方法，注意，这个方法的两个参数分别如下\npublic abstract &lt;A&gt; void accept(A var1, CompletionHandler&lt;AsynchronousSocketChannel, ? super A&gt; var2);\n也就是说这里将自己做回完成处理器传入，进一步的，这个方法的实现是上面的 implAccept，这个方法在通道正常打开的情况下执行下面的代码\nFileDescriptor newfd = new FileDescriptor();          InetSocketAddress[] isaa = new InetSocketAddress[1];          Throwable exc = null;          try &#123;              this.begin();//这里只是简单的为接下来的操作加了一个读锁              int n = Net.accept(this.fd, newfd, isaa);            /*            *这个方法时是真正的连接方法，根据文件描述符去查询是否有可用的连接，这个方法时基于异步的NIO机制实现的，不会发生阻            *塞，其中返回的n是发现的可用的连接事件，及OP_Accept事件            */            if (n == -2) &#123;//如果n是-2，当前不存在可用的连接事件                PendingFuture&lt;AsynchronousSocketChannel, Object&gt; result = null;                  synchronized(this.updateLock) &#123;                      if (handler == null) &#123;                          this.acceptHandler = null;                          result = new PendingFuture(this);                          this.acceptFuture = result;                      &#125; else &#123;                          this.acceptHandler = handler;                          this.acceptAttachment = att;                      &#125;                      this.acceptAcc = System.getSecurityManager() == null ? null : AccessController.getContext();                      this.acceptPending = true;                  &#125;                 this.port.startPoll(this.fdVal, Net.POLLIN);                //这个方法是阻塞的，直到出现对应的事件才会继续执行                  PendingFuture var8 = result;                //既然不存在可用的监听事件，那么返回一个PendingFuture表示待处理并结束当前线程的运行                  return var8;              &#125;  \n这里有一点需要解释：既然 startPoll 方法是阻塞的，然后又返回了一个 PendingFuture，但在更上层的 completeed 和 run 方法中没有对返回值有任何处理呢？这源于对操作系统底层的回调机制的的处理，在 startPoll 方法中，向操作系统注册了对对应事件的监听，如果发生了对应事件，操作系统将会调用对应的回调方法将连接加入通道组，这个过程发生在操作系统中，所以在代码中不可见。当然，也存在当前有可用连接的情况，此时向下执行\nAsynchronousSocketChannel child = null;  if (exc == null) &#123;      try &#123;          child = this.finishAccept(newfd, isaa[0], (AccessControlContext)null);      &#125; catch (Throwable x) &#123;          exc = x;      &#125;  &#125;    this.enableAccept();  if (handler == null) &#123;      return CompletedFuture.withResult(child, exc);  &#125; else &#123;      Invoker.invokeIndirectly(this, handler, att, child, exc);      return null;  &#125;\n我们可以先看看这个 finishAccept 方法到底做了些什么\nprivate AsynchronousSocketChannel finishAccept(FileDescriptor newfd, final InetSocketAddress remote, AccessControlContext acc) throws IOException, SecurityException &#123;      AsynchronousSocketChannel ch = null;        try &#123;          ch = new UnixAsynchronousSocketChannelImpl(this.port, newfd, remote);        //创建一个新的异步通道，三个参数分别为绑定的端口，表示新连接的文件描述符，以及连接的相关信息remote    &#125; catch (IOException x) &#123;          nd.close(newfd);          throw x;      &#125;    //下面是对安全管理的一些设置，我们暂且略过    try &#123;          if (acc != null) &#123;              AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;                  public Void run() &#123;                      SecurityManager sm = System.getSecurityManager();                      if (sm != null) &#123;                          sm.checkAccept(remote.getAddress().getHostAddress(), remote.getPort());                      &#125;                        return null;                  &#125;              &#125;, acc);          &#125; else &#123;              SecurityManager sm = System.getSecurityManager();              if (sm != null) &#123;                  sm.checkAccept(remote.getAddress().getHostAddress(), remote.getPort());              &#125;          &#125;            return ch;      &#125; catch (SecurityException var8) &#123;          try &#123;              ch.close();          &#125; catch (Throwable suppressed) &#123;              var8.addSuppressed(suppressed);          &#125;            throw var8;      &#125;  &#125;\n然后还有一个值得一看的是 Invoker 的执行流程\nstatic &lt;V, A&gt; void invokeIndirectly(AsynchronousChannel channel, final CompletionHandler&lt;V, ? super A&gt; handler, final A attachment, final V result, final Throwable exc) &#123;      try &#123;          ((Groupable)channel).group().executeOnPooledThread(new Runnable() &#123;              public void run() &#123;//可以看到在这里使用了对应的线程池在新的线程中执行了下面的任务                  GroupAndInvokeCount thisGroupAndInvokeCount = (GroupAndInvokeCount)Invoker.myGroupAndInvokeCount.get();                  if (thisGroupAndInvokeCount != null) &#123;                      thisGroupAndInvokeCount.setInvokeCount(1);                  &#125;                    Invoker.invokeUnchecked(handler, attachment, result, exc);                  //这个方法就是直接调用了completed方法            &#125;          &#125;);      &#125; catch (RejectedExecutionException var6) &#123;          throw new ShutdownChannelGroupException();      &#125;  &#125;\n走到这一步，一个连接就被建立了起来，那么接下来了，是谁去处理连接后的任务呢，我们需要再往回倒一倒，看看 completed 方法\n@Override  public void completed(AsynchronousSocketChannel socket,          Void attachment) &#123;      // Successful accept, reset the error delay      errorDelay = 0;      // Continue processing the socket on the current thread      // Configure the socket    if (isRunning() &amp;&amp; !isPaused()) &#123;          if (getMaxConnections() == -1) &#123;              serverSock.accept(null, this);          &#125; else if (getConnectionCount() &lt; getMaxConnections()) &#123;              try &#123;                  // This will not block                  countUpOrAwaitConnection();              &#125; catch (InterruptedException e) &#123;                  // Ignore              &#125;              serverSock.accept(null, this);          &#125; else &#123;              // Accept again on a new thread since countUpOrAwaitConnection may block              getExecutor().execute(this);          &#125;        //注意这里，setSocketOptions中的参数为刚刚建立的连接，也就是说这里有对刚建立的连接的进一步处理         if (!setSocketOptions(socket)) &#123;              closeSocket(socket);          &#125;      &#125; else &#123;          if (isRunning()) &#123;              state = AcceptorState.PAUSED;          &#125;          destroySocket(socket);      &#125;  &#125;\n所以我们看看 setSocketOption 方法的实现\n@Override  protected boolean setSocketOptions(AsynchronousSocketChannel socket) &#123;      Nio2SocketWrapper socketWrapper = null;      try &#123;          // Allocate channel and wrapper          Nio2Channel channel = null;          if (nioChannels != null) &#123;              channel = nioChannels.pop();          &#125;//这个nioChannels就是在EndPoint启动时创建的通道缓存        //如果没可用的通道就创建一个，如果有那么直接用          if (channel == null) &#123;              SocketBufferHandler bufhandler = new SocketBufferHandler(                      socketProperties.getAppReadBufSize(),                      socketProperties.getAppWriteBufSize(),                      socketProperties.getDirectBuffer());              if (isSSLEnabled()) &#123;                  channel = new SecureNio2Channel(bufhandler, this);              &#125; else &#123;                              channel = new Nio2Channel(bufhandler);              &#125;          &#125;        //创建一个SocketWrapper          Nio2SocketWrapper newWrapper = new Nio2SocketWrapper(channel, this);          //将刚刚创建的连接通道打包进去        channel.reset(socket, newWrapper);        //connections是一个Map，以当前连接的异步通道为键，新打包的Wrapper为值放进去          connections.put(socket, newWrapper);          socketWrapper = newWrapper;            // Set socket properties          socketProperties.setProperties(socket);            socketWrapper.setReadTimeout(getConnectionTimeout());          socketWrapper.setWriteTimeout(getConnectionTimeout());          socketWrapper.setKeepAliveLeft(Nio2Endpoint.this.getMaxKeepAliveRequests());          // Continue processing on the same thread as the acceptor is async        //开始对通道中的信息进行处理，监听可用的读事件          return processSocket(socketWrapper, SocketEvent.OPEN_READ, false);      &#125; catch (Throwable t) &#123;          ExceptionUtils.handleThrowable(t);          log.error(sm.getString(&quot;endpoint.socketOptionsError&quot;), t);          if (socketWrapper == null) &#123;              destroySocket(socket);          &#125;      &#125;      // Tell to close the socket if needed      return false;  &#125;\n顺其自然的我们继续找 processSocket 方法\npublic boolean processSocket(SocketWrapperBase&lt;S&gt; socketWrapper,          SocketEvent event, boolean dispatch) &#123;      try &#123;          if (socketWrapper == null) &#123;              return false;          &#125;        //获取缓存的处理器Processor，如果不存在那么创建一个         SocketProcessorBase&lt;S&gt; sc = null;          if (processorCache != null) &#123;              sc = processorCache.pop();          &#125;          if (sc == null) &#123;              sc = createSocketProcessor(socketWrapper, event);          &#125; else &#123;        //如果处理器存在那么重新将处理器与当前的wrapper关联              sc.reset(socketWrapper, event);          &#125;          Executor executor = getExecutor();          //如果要求分发，在线程池执行，否则直接在当前线程执行        if (dispatch &amp;&amp; executor != null) &#123;              executor.execute(sc);          &#125; else &#123;        //刚刚的setSocketOption用的是false，直接在当前线程执行            sc.run();          &#125;      &#125; catch (RejectedExecutionException ree) &#123;          getLog().warn(sm.getString(&quot;endpoint.executor.fail&quot;, socketWrapper) , ree);          return false;      &#125; catch (Throwable t) &#123;          ExceptionUtils.handleThrowable(t);          // This means we got an OOM or similar creating a thread, or that          // the pool and its queue are full        getLog().error(sm.getString(&quot;endpoint.process.fail&quot;), t);          return false;      &#125;      return true;  &#125;\n那么刚刚 run 的是什么呢\npublic final void run() &#123;      Lock lock = socketWrapper.getLock();      lock.lock();      try &#123;          if (socketWrapper.isClosed()) &#123;              return;          &#125;          doRun();      &#125; finally &#123;          lock.unlock();      &#125;  &#125;\n好吧，加个锁，然后继续 run\n    @Override      protected void doRun() &#123;          boolean launch = false;          try &#123;              int handshake;                try &#123;             //这里时对TCP连接三次握手机制的检查，0表示完成了握手过程                if (socketWrapper.getSocket().isHandshakeComplete()) &#123;                      // No TLS handshaking required. Let the handler                      // process this socket / event combination.                                        handshake = 0;                  &#125; else if (event == SocketEvent.STOP || event == SocketEvent.DISCONNECT ||                          event == SocketEvent.ERROR) &#123;                      // Unable to complete the TLS handshake. Treat it as                      // if the handshake failed.                    handshake = -1;                  &#125; else &#123;                      handshake = socketWrapper.getSocket().handshake();                      event = SocketEvent.OPEN_READ;                  &#125;              &#125; catch (IOException x) &#123;                  handshake = -1;                  if (logHandshake.isDebugEnabled()) &#123;                      logHandshake.debug(sm.getString(&quot;endpoint.err.handshake&quot;,                              socketWrapper.getRemoteAddr(), Integer.toString(socketWrapper.getRemotePort())), x);                  &#125;              &#125;              if (handshake == 0) &#123;                  SocketState state;                  // Process the request from this socket                //这里真正的发生了处理                  state = getHandler().process(socketWrapper, Objects.requireNonNullElse(event, SocketEvent.OPEN_READ));                //检查处理完后的状态                  if (state == SocketState.CLOSED) &#123;                      // Close socket and pool                      socketWrapper.close();                    //如果状态标识为需要升级协议，将launch变为true                 &#125; else if (state == SocketState.UPGRADING) &#123;                      launch = true;                  &#125;              &#125; else if (handshake == -1 ) &#123;                  getHandler().process(socketWrapper, SocketEvent.CONNECT_FAIL);                  socketWrapper.close();              &#125;          &#125; catch (VirtualMachineError vme) &#123;              ExceptionUtils.handleThrowable(vme);          &#125; catch (Throwable t) &#123;              log.error(sm.getString(&quot;endpoint.processing.fail&quot;), t);              if (socketWrapper != null) &#123;                  socketWrapper.close();              &#125;          &#125; finally &#123;              if (launch) &#123;                  try &#123;                //新创建一个处理器处理进一步处理                      getExecutor().execute(new SocketProcessor(socketWrapper, SocketEvent.OPEN_READ));                  &#125; catch (NullPointerException npe) &#123;                      if (running) &#123;                          log.error(sm.getString(&quot;endpoint.launch.fail&quot;),                                  npe);                      &#125;                  &#125;              &#125;              socketWrapper = null;              event = null;              //return to cache            //然后将当前的处理器重新放到缓存中              if (running &amp;&amp; processorCache != null) &#123;                  processorCache.push(this);              &#125;          &#125;      &#125;  &#125;\n接下来看看 process 方法在干什么，这个方法不太好找，位于 AbstractProtocol 类中，而且比较长，所以我只截取部分\nProcessor processor = (Processor) wrapper.takeCurrentProcessor();//在这里获取处理器state = processor.process(wrapper, status);//调用处理器的process方法\n这个 process 方法的实现也不好找，位于AbstractProcessorLight，看一眼具体的实现\n@Override  public SocketState process(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status) throws IOException &#123;        SocketState state = SocketState.CLOSED;      Iterator&lt;DispatchType&gt; dispatches = null;      do &#123;          if (dispatches != null) &#123;              DispatchType nextDispatch = dispatches.next();              if (getLog().isTraceEnabled()) &#123;                  getLog().trace(&quot;Processing dispatch type: [&quot; + nextDispatch + &quot;]&quot;);              &#125;              state = dispatch(nextDispatch.getSocketStatus());              if (!dispatches.hasNext()) &#123;                  state = checkForPipelinedData(state, socketWrapper);              &#125;          &#125; else if (status == SocketEvent.DISCONNECT) &#123;              // Do nothing here, just wait for it to get recycled          &#125; else if (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;              state = dispatch(status);              state = checkForPipelinedData(state, socketWrapper);          &#125; else if (status == SocketEvent.OPEN_WRITE) &#123;              // Extra write event likely after async, ignore              state = SocketState.LONG;          &#125; else if (status == SocketEvent.OPEN_READ) &#123;        //当时传入的状态是读，所以我们直接看这里              state = service(socketWrapper);          &#125; else if (status == SocketEvent.CONNECT_FAIL) &#123;              logAccess(socketWrapper);          &#125; else &#123;              // Default to closing the socket if the SocketEvent passed in              // is not consistent with the current state of the Processor                        state = SocketState.CLOSED;          &#125;            if (getLog().isTraceEnabled()) &#123;              getLog().trace(                      &quot;Socket: [&quot; + socketWrapper + &quot;], Status in: [&quot; + status + &quot;], State out: [&quot; + state + &quot;]&quot;);          &#125;            /*           * If state is already CLOSED don&#x27;t call asyncPostProcess() as that will likely change the state to some                  * other value causing processing to continue when it should cease. The AsyncStateMachine will be recycled                  *          as part of the Processor clean-up on CLOSED so it doesn&#x27;t matter what state it is left in at this point.                   */                 if (isAsync() &amp;&amp; state != SocketState.CLOSED) &#123;              state = asyncPostProcess();              if (getLog().isTraceEnabled()) &#123;                  getLog().trace(                          &quot;Socket: [&quot; + socketWrapper + &quot;], State after async post processing: [&quot; + state + &quot;]&quot;);              &#125;          &#125;            if (dispatches == null || !dispatches.hasNext()) &#123;              // Only returns non-null iterator if there are              // dispatches to process.                        dispatches = getIteratorAndClearDispatches();          &#125;      &#125; while (state == SocketState.ASYNC_END || dispatches != null &amp;&amp; state != SocketState.CLOSED);        return state;  &#125;\n所以接下来我们要看看 service 方法，这个方法也比较长，所以我们只看看关键部分\nsetSocketWrapper(socketWrapper);//直接将打包好的连接放进处理器，之后直接通过处理器来获得对应的信息//首先是这部分，开始尝试对HTTP请求进行解析if (!inputBuffer.parseRequestLine(keptAlive, protocol.getConnectionTimeout(),          protocol.getKeepAliveTimeout())) &#123;      if (inputBuffer.getParsingRequestLinePhase() == -1) &#123;          return SocketState.UPGRADING;      &#125; else if (handleIncompleteRequestLineRead()) &#123;          break;      &#125;  &#125;    // Process the Protocol component of the request line  // Need to know if this is an HTTP 0.9 request before trying to  // parse headers.//开始获取请求的协议  prepareRequestProtocol();    if (protocol.isPaused()) &#123;      // 503 - Service unavailable      response.setStatus(503);      setErrorState(ErrorState.CLOSE_CLEAN, null);  &#125; else &#123;      keptAlive = true;      // Set this every time in case limit has been changed via JMX      request.getMimeHeaders().setLimit(protocol.getMaxHeaderCount());      // Don&#x27;t parse headers for HTTP/0.9      if (!http09 &amp;&amp; !inputBuffer.parseHeaders()) &#123;          // We&#x27;ve read part of the request, don&#x27;t recycle it          // instead associate it with the socket                openSocket = true;          readComplete = false;          break;      &#125;      if (!protocol.getDisableUploadTimeout()) &#123;          socketWrapper.setReadTimeout(protocol.getConnectionUploadTimeout());      &#125;  &#125;\n我们今天只讨论网络通信本身，不会深入的探究具体的对请求的解析流程，所以如果对请求的解析实现有兴趣可以自己看看。接下来会运行到这里\nif (getErrorState().isIoAllowed()) &#123;      // Setting up filters, and parse some request headers      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);      try &#123;              prepareRequest();      &#125; catch (Throwable t) &#123;          ExceptionUtils.handleThrowable(t);          if (log.isDebugEnabled()) &#123;              log.debug(sm.getString(&quot;http11processor.request.prepare&quot;), t);          &#125;          // 500 - Internal Server Error          response.setStatus(500);          setErrorState(ErrorState.CLOSE_CLEAN, t);      &#125;  &#125;\n prepareRequest 方法负责将收到的请求信息转换为能够使用的键值对形式，还是和上面的一样，HTTP 信息解析不属于我们今天讨论的内容，有需要可以自己了解 接下来就是正式的请求处理了 if (getErrorState().isIoAllowed()) &#123;//如果运行进行IO      try &#123;          rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);//将状态切换为正在处理          getAdapter().service(request, response);//调用Adapter进行处理，此时请求的信息已经被封装到了request中        if (keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; !isAsync() &amp;&amp;                  statusDropsConnection(response.getStatus())) &#123;              setErrorState(ErrorState.CLOSE_CLEAN, null);          &#125; 在这里，我们终于见到了 Tomcat 的下一个重要组件：Adapter。这个组件时一个转换组件，负责将获得的 HTTP 请求信息转换为容器能够处理的形式。\n我们在上一部分中看到了 Adapter 组件被调用，adapter 会尝试着对信息做分离，然后将需要处理的信息投送到对应的 Container 组件中进行处理，我们使用 Tomcat 时提供的 Servlet 就是容器的一种，负责具体的业务处理上面我们看到了 adapter 方法被调用，在完成几个异常检查之后会有下面的流程\n//对请求中的信息做必要的处理postParseSuccess = postParseRequest(req, request, res, response);  if (postParseSuccess) &#123;      // check valves if we support async    //检查是否支持异步      request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());      // Calling the container    //开始获取正确的容器然后对请求进行处理      connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);  &#125;\n解释一下最后一行的一长串流式调用，首先获得当前的 connector 对应的 Service，然后从 service 中获取容器，此处的获取容器方法固定返回 Engine 容器，Engine 一般在每个 Service 中只有一个，是顶层容器，负责将请求分发给真正负责处理的容器。然后从 Engine 中获得处理管线，处理管线由一个基本容器 BaseContainer 和一系列可选包装器（Valves）组成，这些包装器负责在正式的请求处理前的检查工作与请求结束后的资源清理工作。Tomcat 原生实现了大量的 Valve，具体可以看一下这张图在默认的情况下 Engine 中的 Valve 是一个 StandardEngineValve（当然可以通过配置加一些实现），实现如下\npublic void invoke(Request request, Response response) throws IOException, ServletException &#123;        // Select the Host to be used for this Request      Host host = request.getHost();      if (host == null) &#123;          if (!response.isError()) &#123;              response.sendError(404);          &#125;          return;      &#125;      if (request.isAsyncSupported()) &#123;          request.setAsyncSupported(host.getPipeline().isAsyncSupported());      &#125;        // Ask this Host to process this request      host.getPipeline().getFirst().invoke(request, response);  &#125;\n我们可以看到这里实际上是将请求分发到了 HOST 容器，HOST 容器包含一个 StandardHostValve，实现如下\npublic void invoke(Request request, Response response) throws IOException, ServletException &#123;        // Select the Context to be used for this Request      Context context = request.getContext();     //尝试获取请求的上下文容器     if (context == null) &#123;          // Don&#x27;t overwrite an existing error          if (!response.isError()) &#123;              response.sendError(404);          &#125;          return;      &#125;        if (request.isAsyncSupported()) &#123;          request.setAsyncSupported(context.getPipeline().isAsyncSupported());      &#125;        boolean asyncAtStart = request.isAsync();        try &#123;          context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);            if (!asyncAtStart &amp;&amp; !context.fireRequestInitEvent(request.getRequest())) &#123;             return;             //异步请求检查        &#125;    .        try &#123;              if (!response.isErrorReportRequired()) &#123;            //尝试将请求分发给context容器                  context.getPipeline().getFirst().invoke(request, response);              &#125;          &#125; catch (Throwable t) &#123;              ExceptionUtils.handleThrowable(t);              container.getLogger().error(sm.getString(&quot;standardHostValve.exception&quot;, request.getRequestURI()), t);  .            if (!response.isErrorReportRequired()) &#123;                  request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);                  throwable(request, response, t);              &#125;          &#125;        //现在请求又回到了Host的控制下          response.setSuspended(false);            Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);          //如果context容器刚刚已经销毁了，直接返回        if (!context.getState().isAvailable()) &#123;              return;          &#125;            //如果程序需要进行错误报告          if (response.isErrorReportRequired()) &#123;            //接下来检测是否运行更进一步的IO              AtomicBoolean result = new AtomicBoolean(false);              response.getCoyoteResponse().action(ActionCode.IS_IO_ALLOWED, result);            //如果允许IO，那么渲染一个错误页面              if (result.get()) &#123;                  if (t != null) &#123;                      throwable(request, response, t);                  &#125; else &#123;                      status(request, response);                  &#125;              &#125;          &#125;            if (!request.isAsync() &amp;&amp; !asyncAtStart) &#123;              context.fireRequestDestroyEvent(request.getRequest());          &#125;      &#125; finally &#123;       //刷新长连接的最后一次访问的时间          if (context.getAlwaysAccessSession()) &#123;              request.getSession(false);          &#125;            context.unbind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);      &#125;  &#125;\n接下来是 context 容器的 invoke 方法，这个方法我就不展示了，在 StandardContextValve 中实现，就是做了一点处理后移交给 Wrapper 容器，我们可以看看 Wrapper 在干什么\n//在跳过错误检查后开始分配Servlet// Allocate a servlet instance to process this request  try &#123;      if (!unavailable) &#123;          servlet = wrapper.allocate();      &#125;  &#125; catch (UnavailableException e) &#123;      container.getLogger().error(sm.getString(&quot;standardWrapper.allocateException&quot;, wrapper.getName()), e);      checkWrapperAvailable(response, wrapper);  &#125; catch (ServletException e) &#123;      container.getLogger().error(sm.getString(&quot;standardWrapper.allocateException&quot;, wrapper.getName()),              StandardWrapper.getRootCause(e));      throwable = e;      exception(request, response, e);  &#125; catch (Throwable e) &#123;      ExceptionUtils.handleThrowable(e);      container.getLogger().error(sm.getString(&quot;standardWrapper.allocateException&quot;, wrapper.getName()), e);      throwable = e;      exception(request, response, e);      // servlet = null; is set here  &#125;\n对，在上面漫长的兜圈子后我们终于看到了我们熟悉的 Servlet，allocate 方法就不看了，就是将 Wrapper 内携带的单例容器返回来而已，如果没有创建单例就自己创建一个\nif ((servlet != null) &amp;&amp; (filterChain != null)) &#123;      // Swallow output if needed      if (context.getSwallowOutput()) &#123;    //判断是否需要捕获系统输出，如System.in或System.err          try &#123;              SystemLogHandler.startCapture();              if (request.isAsyncDispatching()) &#123;//异步请求处理                  request.getAsyncContextInternal().doInternalDispatch();              &#125; else &#123;              //调用过滤链                filterChain.doFilter(request.getRequest(), response.getResponse());              &#125;          &#125; finally &#123;         //最后记录刚刚捕获的信息             String log = SystemLogHandler.stopCapture();              if (log != null &amp;&amp; !log.isEmpty()) &#123;                  context.getLogger().info(log);              &#125;          &#125;      &#125; else &#123;      //不需要捕获输出那么直接处理        if (request.isAsyncDispatching()) &#123;              request.getAsyncContextInternal().doInternalDispatch();          &#125; else &#123;              filterChain.doFilter(request.getRequest(), response.getResponse());          &#125;      &#125;    &#125;\n实质上 Servlet 容器中方法的调用发生在 doFilter 方法中，我们可以看一下\nprivate void internalDoFilter(ServletRequest request, ServletResponse response)          throws IOException, ServletException &#123;        // Call the next filter if there is one      if (pos &lt; n) &#123;        //顺次获取下一个过滤器          ApplicationFilterConfig filterConfig = filters[pos++];          try &#123;              Filter filter = filterConfig.getFilter();                if (request.isAsyncSupported() &amp;&amp; !(filterConfig.getFilterDef().getAsyncSupportedBoolean())) &#123;                  request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);              &#125;              if (Globals.IS_SECURITY_ENABLED) &#123;                  final ServletRequest req = request;                  final ServletResponse res = response;                  Principal principal = ((HttpServletRequest) req).getUserPrincipal();                    Object[] args = new Object[] &#123; req, res, this &#125;;                  SecurityUtil.doAsPrivilege(&quot;doFilter&quot;, filter, classType, args, principal);              &#125; else &#123;            //再次调用相同的方法，调用下一个过滤器，由于一般情况下过滤器是我们自己实现的，我们会在            //doFilter中进行过滤，然后手动调用filterChain.doFilter来实现连续的过滤                  filter.doFilter(request, response, this);              &#125;          &#125; catch (IOException | ServletException | RuntimeException e) &#123;              throw e;          &#125; catch (Throwable e) &#123;              e = ExceptionUtils.unwrapInvocationTargetException(e);              ExceptionUtils.handleThrowable(e);              throw new ServletException(sm.getString(&quot;filterChain.filter&quot;), e);          &#125;          return;      &#125;        // We fell off the end of the chain -- call the servlet instance     //运行到此处说明走完了所有过滤器，接下来调用Servlet容器     try &#123;          if (dispatcherWrapsSameObject) &#123;              lastServicedRequest.set(request);              lastServicedResponse.set(response);          &#125;            if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;              request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);          &#125;          // Use potentially wrapped request from this point          if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp;                  Globals.IS_SECURITY_ENABLED) &#123;              final ServletRequest req = request;              final ServletResponse res = response;              Principal principal = ((HttpServletRequest) req).getUserPrincipal();              Object[] args = new Object[] &#123; req, res &#125;;              SecurityUtil.doAsPrivilege(&quot;service&quot;, servlet, classTypeUsedInService, args, principal);          &#125; else &#123;        //一般的HTTP请求直接运行到这里，然后调用Service方法              servlet.service(request, response);          &#125;      &#125; catch (IOException | ServletException | RuntimeException e) &#123;          throw e;      &#125; catch (Throwable e) &#123;          e = ExceptionUtils.unwrapInvocationTargetException(e);          ExceptionUtils.handleThrowable(e);          throw new ServletException(sm.getString(&quot;filterChain.servlet&quot;), e);      &#125; finally &#123;          if (dispatcherWrapsSameObject) &#123;              lastServicedRequest.set(null);              lastServicedResponse.set(null);          &#125;      &#125;  &#125;\n\n显然，到这一步请求对应的相应已经有了，该返回对应的结果了，那么返回怎么走，来，回忆上面的流程，我们实际是调用了 Adapter 组件的 service 方法，然后一层一层的调用容器，现在我们继续返回 service 方法，看看接下来该干什么，比较关键的是这个\n// Recycle the wrapper request and response  if (!async) &#123;      updateWrapperErrorCount(request, response);      request.recycle();      response.recycle();  &#125;\n我们注意到分别调用了请求和响应的 recycle 方法，这个方法会释放对象内所有的引用，即清理对象，使对象可以循环使用。再往回是 processor 的 service 方法，最后部分的实现如下\nif (getErrorState().isError() || (protocol.isPaused() &amp;&amp; !isAsync())) &#123;      return SocketState.CLOSED;//如果存在错误或者协议处理器中标注被暂停且不是异步请求  &#125; else if (isAsync()) &#123;      return SocketState.LONG;  &#125; else if (isUpgrade()) &#123;      return SocketState.UPGRADING;  &#125; else &#123;      if (sendfileState == SendfileState.PENDING) &#123;          return SocketState.SENDFILE;  //可能的状态为Pending，即等待处理，此时需要发送文件    &#125; else &#123;          if (openSocket) &#123;              if (readComplete) &#123;                  return SocketState.OPEN;              &#125; else &#123;                  return SocketState.LONG;              &#125;          &#125; else &#123;              return SocketState.CLOSED; //对于一个非异步的，没有出错的，不要求长连接的请求，返回关闭信号        &#125;      &#125;  &#125;\n接下来是协议处理器的 process 方法，我就不展示了，检测到 closed 状态直接返回，最后一路收到 closed 状态一路关闭与回收，最终关闭 Socket 通道\n我们可以大概的梳理一下上面的过程，当 Tomcat 启动时 Service 组件启动Connector ，Connector组件启动线程池与监听端口的 Acceptor，监听到的请求被 SocketWrapper，SocketWrapper 实现了 Runnable 接口，自己将自己传递给 Protocol 协议处理器，协议处理器内部通过 Adapter 将请求转发给 Container，在经历了 Engine，Host，Context，Wrapper 容器的 Valve 后被传递给负责实际业务逻辑的 Servlet，在 Servlet 内发生实际的请求处理，将相应结果写回。\n在最后的最后，我们再回到一个问题，Spring 框架与 Tomcat 时怎么整合的？答案非常简单，DisPatchServlet 是 HttpServlet 的一个子类，然后在启动时相 Tomcat 只注册了这一个 Servlet，然后由 DisPatchServlet 来调用不同的 Controller 实现。\n结语终于写完了，心累啊。不过讲了这么多，还是存在不少问题，比如我们实际上没有去关注 TCP 协议，HTTP 协议等内容，只是泛泛的谈了一下 Tomcat 的思路，下期吧，下一篇我们直接从网络架构开讲，好好说说各个协议的实现。\n\n","tags":["手写Spring"]}]